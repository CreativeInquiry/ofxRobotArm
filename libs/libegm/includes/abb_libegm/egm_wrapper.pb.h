// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm_wrapper.proto

#ifndef PROTOBUF_INCLUDED_egm_5fwrapper_2eproto
#define PROTOBUF_INCLUDED_egm_5fwrapper_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto 

namespace protobuf_egm_5fwrapper_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_egm_5fwrapper_2eproto
namespace abb {
namespace egm {
namespace wrapper {
class Cartesian;
class CartesianDefaultTypeInternal;
extern CartesianDefaultTypeInternal _Cartesian_default_instance_;
class CartesianPose;
class CartesianPoseDefaultTypeInternal;
extern CartesianPoseDefaultTypeInternal _CartesianPose_default_instance_;
class CartesianSpace;
class CartesianSpaceDefaultTypeInternal;
extern CartesianSpaceDefaultTypeInternal _CartesianSpace_default_instance_;
class CartesianVelocity;
class CartesianVelocityDefaultTypeInternal;
extern CartesianVelocityDefaultTypeInternal _CartesianVelocity_default_instance_;
class Clock;
class ClockDefaultTypeInternal;
extern ClockDefaultTypeInternal _Clock_default_instance_;
class Euler;
class EulerDefaultTypeInternal;
extern EulerDefaultTypeInternal _Euler_default_instance_;
class External;
class ExternalDefaultTypeInternal;
extern ExternalDefaultTypeInternal _External_default_instance_;
class Feedback;
class FeedbackDefaultTypeInternal;
extern FeedbackDefaultTypeInternal _Feedback_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Input;
class InputDefaultTypeInternal;
extern InputDefaultTypeInternal _Input_default_instance_;
class JointSpace;
class JointSpaceDefaultTypeInternal;
extern JointSpaceDefaultTypeInternal _JointSpace_default_instance_;
class Joints;
class JointsDefaultTypeInternal;
extern JointsDefaultTypeInternal _Joints_default_instance_;
class Output;
class OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class Planned;
class PlannedDefaultTypeInternal;
extern PlannedDefaultTypeInternal _Planned_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Robot;
class RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
}  // namespace wrapper
}  // namespace egm
}  // namespace abb
namespace google {
namespace protobuf {
template<> ::abb::egm::wrapper::Cartesian* Arena::CreateMaybeMessage<::abb::egm::wrapper::Cartesian>(Arena*);
template<> ::abb::egm::wrapper::CartesianPose* Arena::CreateMaybeMessage<::abb::egm::wrapper::CartesianPose>(Arena*);
template<> ::abb::egm::wrapper::CartesianSpace* Arena::CreateMaybeMessage<::abb::egm::wrapper::CartesianSpace>(Arena*);
template<> ::abb::egm::wrapper::CartesianVelocity* Arena::CreateMaybeMessage<::abb::egm::wrapper::CartesianVelocity>(Arena*);
template<> ::abb::egm::wrapper::Clock* Arena::CreateMaybeMessage<::abb::egm::wrapper::Clock>(Arena*);
template<> ::abb::egm::wrapper::Euler* Arena::CreateMaybeMessage<::abb::egm::wrapper::Euler>(Arena*);
template<> ::abb::egm::wrapper::External* Arena::CreateMaybeMessage<::abb::egm::wrapper::External>(Arena*);
template<> ::abb::egm::wrapper::Feedback* Arena::CreateMaybeMessage<::abb::egm::wrapper::Feedback>(Arena*);
template<> ::abb::egm::wrapper::Header* Arena::CreateMaybeMessage<::abb::egm::wrapper::Header>(Arena*);
template<> ::abb::egm::wrapper::Input* Arena::CreateMaybeMessage<::abb::egm::wrapper::Input>(Arena*);
template<> ::abb::egm::wrapper::JointSpace* Arena::CreateMaybeMessage<::abb::egm::wrapper::JointSpace>(Arena*);
template<> ::abb::egm::wrapper::Joints* Arena::CreateMaybeMessage<::abb::egm::wrapper::Joints>(Arena*);
template<> ::abb::egm::wrapper::Output* Arena::CreateMaybeMessage<::abb::egm::wrapper::Output>(Arena*);
template<> ::abb::egm::wrapper::Planned* Arena::CreateMaybeMessage<::abb::egm::wrapper::Planned>(Arena*);
template<> ::abb::egm::wrapper::Quaternion* Arena::CreateMaybeMessage<::abb::egm::wrapper::Quaternion>(Arena*);
template<> ::abb::egm::wrapper::Robot* Arena::CreateMaybeMessage<::abb::egm::wrapper::Robot>(Arena*);
template<> ::abb::egm::wrapper::Status* Arena::CreateMaybeMessage<::abb::egm::wrapper::Status>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace abb {
namespace egm {
namespace wrapper {

enum Header_MessageType {
  Header_MessageType_UNDEFINED = 0,
  Header_MessageType_DATA = 1
};
bool Header_MessageType_IsValid(int value);
const Header_MessageType Header_MessageType_MessageType_MIN = Header_MessageType_UNDEFINED;
const Header_MessageType Header_MessageType_MessageType_MAX = Header_MessageType_DATA;
const int Header_MessageType_MessageType_ARRAYSIZE = Header_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_MessageType_descriptor();
inline const ::std::string& Header_MessageType_Name(Header_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_MessageType_descriptor(), value);
}
inline bool Header_MessageType_Parse(
    const ::std::string& name, Header_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_MessageType>(
    Header_MessageType_descriptor(), name, value);
}
enum Header_RWVersion {
  Header_RWVersion_RW_UNKNOWN = 0,
  Header_RWVersion_RW_6_10_AND_NEWER = 1,
  Header_RWVersion_RW_BETWEEN_6_AND_6_06_03 = 2,
  Header_RWVersion_RW_BETWEEN_6_07_AND_6_09_02 = 3
};
bool Header_RWVersion_IsValid(int value);
const Header_RWVersion Header_RWVersion_RWVersion_MIN = Header_RWVersion_RW_UNKNOWN;
const Header_RWVersion Header_RWVersion_RWVersion_MAX = Header_RWVersion_RW_BETWEEN_6_07_AND_6_09_02;
const int Header_RWVersion_RWVersion_ARRAYSIZE = Header_RWVersion_RWVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_RWVersion_descriptor();
inline const ::std::string& Header_RWVersion_Name(Header_RWVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_RWVersion_descriptor(), value);
}
inline bool Header_RWVersion_Parse(
    const ::std::string& name, Header_RWVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_RWVersion>(
    Header_RWVersion_descriptor(), name, value);
}
enum Header_EGMVersion {
  Header_EGMVersion_EGM_UNKNOWN = 0,
  Header_EGMVersion_EGM_1_0 = 1,
  Header_EGMVersion_EGM_1_1 = 2
};
bool Header_EGMVersion_IsValid(int value);
const Header_EGMVersion Header_EGMVersion_EGMVersion_MIN = Header_EGMVersion_EGM_UNKNOWN;
const Header_EGMVersion Header_EGMVersion_EGMVersion_MAX = Header_EGMVersion_EGM_1_1;
const int Header_EGMVersion_EGMVersion_ARRAYSIZE = Header_EGMVersion_EGMVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_EGMVersion_descriptor();
inline const ::std::string& Header_EGMVersion_Name(Header_EGMVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_EGMVersion_descriptor(), value);
}
inline bool Header_EGMVersion_Parse(
    const ::std::string& name, Header_EGMVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_EGMVersion>(
    Header_EGMVersion_descriptor(), name, value);
}
enum Status_EGMState {
  Status_EGMState_EGM_UNDEFINED = 0,
  Status_EGMState_EGM_ERROR = 1,
  Status_EGMState_EGM_STOPPED = 2,
  Status_EGMState_EGM_RUNNING = 3
};
bool Status_EGMState_IsValid(int value);
const Status_EGMState Status_EGMState_EGMState_MIN = Status_EGMState_EGM_UNDEFINED;
const Status_EGMState Status_EGMState_EGMState_MAX = Status_EGMState_EGM_RUNNING;
const int Status_EGMState_EGMState_ARRAYSIZE = Status_EGMState_EGMState_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_EGMState_descriptor();
inline const ::std::string& Status_EGMState_Name(Status_EGMState value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_EGMState_descriptor(), value);
}
inline bool Status_EGMState_Parse(
    const ::std::string& name, Status_EGMState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status_EGMState>(
    Status_EGMState_descriptor(), name, value);
}
enum Status_MotorState {
  Status_MotorState_MOTORS_UNDEFINED = 0,
  Status_MotorState_MOTORS_ON = 1,
  Status_MotorState_MOTORS_OFF = 2
};
bool Status_MotorState_IsValid(int value);
const Status_MotorState Status_MotorState_MotorState_MIN = Status_MotorState_MOTORS_UNDEFINED;
const Status_MotorState Status_MotorState_MotorState_MAX = Status_MotorState_MOTORS_OFF;
const int Status_MotorState_MotorState_ARRAYSIZE = Status_MotorState_MotorState_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_MotorState_descriptor();
inline const ::std::string& Status_MotorState_Name(Status_MotorState value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_MotorState_descriptor(), value);
}
inline bool Status_MotorState_Parse(
    const ::std::string& name, Status_MotorState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status_MotorState>(
    Status_MotorState_descriptor(), name, value);
}
enum Status_RAPIDExecutionState {
  Status_RAPIDExecutionState_RAPID_UNDEFINED = 0,
  Status_RAPIDExecutionState_RAPID_STOPPED = 1,
  Status_RAPIDExecutionState_RAPID_RUNNING = 2
};
bool Status_RAPIDExecutionState_IsValid(int value);
const Status_RAPIDExecutionState Status_RAPIDExecutionState_RAPIDExecutionState_MIN = Status_RAPIDExecutionState_RAPID_UNDEFINED;
const Status_RAPIDExecutionState Status_RAPIDExecutionState_RAPIDExecutionState_MAX = Status_RAPIDExecutionState_RAPID_RUNNING;
const int Status_RAPIDExecutionState_RAPIDExecutionState_ARRAYSIZE = Status_RAPIDExecutionState_RAPIDExecutionState_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_RAPIDExecutionState_descriptor();
inline const ::std::string& Status_RAPIDExecutionState_Name(Status_RAPIDExecutionState value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_RAPIDExecutionState_descriptor(), value);
}
inline bool Status_RAPIDExecutionState_Parse(
    const ::std::string& name, Status_RAPIDExecutionState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status_RAPIDExecutionState>(
    Status_RAPIDExecutionState_descriptor(), name, value);
}
// ===================================================================

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return CreateMaybeMessage<Header>(NULL);
  }

  Header* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Header_MessageType MessageType;
  static const MessageType UNDEFINED =
    Header_MessageType_UNDEFINED;
  static const MessageType DATA =
    Header_MessageType_DATA;
  static inline bool MessageType_IsValid(int value) {
    return Header_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    Header_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    Header_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    Header_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return Header_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return Header_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return Header_MessageType_Parse(name, value);
  }

  typedef Header_RWVersion RWVersion;
  static const RWVersion RW_UNKNOWN =
    Header_RWVersion_RW_UNKNOWN;
  static const RWVersion RW_6_10_AND_NEWER =
    Header_RWVersion_RW_6_10_AND_NEWER;
  static const RWVersion RW_BETWEEN_6_AND_6_06_03 =
    Header_RWVersion_RW_BETWEEN_6_AND_6_06_03;
  static const RWVersion RW_BETWEEN_6_07_AND_6_09_02 =
    Header_RWVersion_RW_BETWEEN_6_07_AND_6_09_02;
  static inline bool RWVersion_IsValid(int value) {
    return Header_RWVersion_IsValid(value);
  }
  static const RWVersion RWVersion_MIN =
    Header_RWVersion_RWVersion_MIN;
  static const RWVersion RWVersion_MAX =
    Header_RWVersion_RWVersion_MAX;
  static const int RWVersion_ARRAYSIZE =
    Header_RWVersion_RWVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RWVersion_descriptor() {
    return Header_RWVersion_descriptor();
  }
  static inline const ::std::string& RWVersion_Name(RWVersion value) {
    return Header_RWVersion_Name(value);
  }
  static inline bool RWVersion_Parse(const ::std::string& name,
      RWVersion* value) {
    return Header_RWVersion_Parse(name, value);
  }

  typedef Header_EGMVersion EGMVersion;
  static const EGMVersion EGM_UNKNOWN =
    Header_EGMVersion_EGM_UNKNOWN;
  static const EGMVersion EGM_1_0 =
    Header_EGMVersion_EGM_1_0;
  static const EGMVersion EGM_1_1 =
    Header_EGMVersion_EGM_1_1;
  static inline bool EGMVersion_IsValid(int value) {
    return Header_EGMVersion_IsValid(value);
  }
  static const EGMVersion EGMVersion_MIN =
    Header_EGMVersion_EGMVersion_MIN;
  static const EGMVersion EGMVersion_MAX =
    Header_EGMVersion_EGMVersion_MAX;
  static const int EGMVersion_ARRAYSIZE =
    Header_EGMVersion_EGMVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EGMVersion_descriptor() {
    return Header_EGMVersion_descriptor();
  }
  static inline const ::std::string& EGMVersion_Name(EGMVersion value) {
    return Header_EGMVersion_Name(value);
  }
  static inline bool EGMVersion_Parse(const ::std::string& name,
      EGMVersion* value) {
    return Header_EGMVersion_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 sequence_number = 1;
  bool has_sequence_number() const;
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::uint32 sequence_number() const;
  void set_sequence_number(::google::protobuf::uint32 value);

  // optional uint32 time_stamp = 2;
  bool has_time_stamp() const;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  ::google::protobuf::uint32 time_stamp() const;
  void set_time_stamp(::google::protobuf::uint32 value);

  // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
  bool has_message_type() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 3;
  ::abb::egm::wrapper::Header_MessageType message_type() const;
  void set_message_type(::abb::egm::wrapper::Header_MessageType value);

  // optional .abb.egm.wrapper.Header.RWVersion rw_version = 4 [default = RW_UNKNOWN];
  bool has_rw_version() const;
  void clear_rw_version();
  static const int kRwVersionFieldNumber = 4;
  ::abb::egm::wrapper::Header_RWVersion rw_version() const;
  void set_rw_version(::abb::egm::wrapper::Header_RWVersion value);

  // optional .abb.egm.wrapper.Header.EGMVersion egm_version = 5 [default = EGM_UNKNOWN];
  bool has_egm_version() const;
  void clear_egm_version();
  static const int kEgmVersionFieldNumber = 5;
  ::abb::egm::wrapper::Header_EGMVersion egm_version() const;
  void set_egm_version(::abb::egm::wrapper::Header_EGMVersion value);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Header)
 private:
  void set_has_sequence_number();
  void clear_has_sequence_number();
  void set_has_time_stamp();
  void clear_has_time_stamp();
  void set_has_message_type();
  void clear_has_message_type();
  void set_has_rw_version();
  void clear_has_rw_version();
  void set_has_egm_version();
  void clear_has_egm_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 sequence_number_;
  ::google::protobuf::uint32 time_stamp_;
  int message_type_;
  int rw_version_;
  int egm_version_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Status) */ {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(Status&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Status* other);
  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(NULL);
  }

  Status* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Status_EGMState EGMState;
  static const EGMState EGM_UNDEFINED =
    Status_EGMState_EGM_UNDEFINED;
  static const EGMState EGM_ERROR =
    Status_EGMState_EGM_ERROR;
  static const EGMState EGM_STOPPED =
    Status_EGMState_EGM_STOPPED;
  static const EGMState EGM_RUNNING =
    Status_EGMState_EGM_RUNNING;
  static inline bool EGMState_IsValid(int value) {
    return Status_EGMState_IsValid(value);
  }
  static const EGMState EGMState_MIN =
    Status_EGMState_EGMState_MIN;
  static const EGMState EGMState_MAX =
    Status_EGMState_EGMState_MAX;
  static const int EGMState_ARRAYSIZE =
    Status_EGMState_EGMState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EGMState_descriptor() {
    return Status_EGMState_descriptor();
  }
  static inline const ::std::string& EGMState_Name(EGMState value) {
    return Status_EGMState_Name(value);
  }
  static inline bool EGMState_Parse(const ::std::string& name,
      EGMState* value) {
    return Status_EGMState_Parse(name, value);
  }

  typedef Status_MotorState MotorState;
  static const MotorState MOTORS_UNDEFINED =
    Status_MotorState_MOTORS_UNDEFINED;
  static const MotorState MOTORS_ON =
    Status_MotorState_MOTORS_ON;
  static const MotorState MOTORS_OFF =
    Status_MotorState_MOTORS_OFF;
  static inline bool MotorState_IsValid(int value) {
    return Status_MotorState_IsValid(value);
  }
  static const MotorState MotorState_MIN =
    Status_MotorState_MotorState_MIN;
  static const MotorState MotorState_MAX =
    Status_MotorState_MotorState_MAX;
  static const int MotorState_ARRAYSIZE =
    Status_MotorState_MotorState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MotorState_descriptor() {
    return Status_MotorState_descriptor();
  }
  static inline const ::std::string& MotorState_Name(MotorState value) {
    return Status_MotorState_Name(value);
  }
  static inline bool MotorState_Parse(const ::std::string& name,
      MotorState* value) {
    return Status_MotorState_Parse(name, value);
  }

  typedef Status_RAPIDExecutionState RAPIDExecutionState;
  static const RAPIDExecutionState RAPID_UNDEFINED =
    Status_RAPIDExecutionState_RAPID_UNDEFINED;
  static const RAPIDExecutionState RAPID_STOPPED =
    Status_RAPIDExecutionState_RAPID_STOPPED;
  static const RAPIDExecutionState RAPID_RUNNING =
    Status_RAPIDExecutionState_RAPID_RUNNING;
  static inline bool RAPIDExecutionState_IsValid(int value) {
    return Status_RAPIDExecutionState_IsValid(value);
  }
  static const RAPIDExecutionState RAPIDExecutionState_MIN =
    Status_RAPIDExecutionState_RAPIDExecutionState_MIN;
  static const RAPIDExecutionState RAPIDExecutionState_MAX =
    Status_RAPIDExecutionState_RAPIDExecutionState_MAX;
  static const int RAPIDExecutionState_ARRAYSIZE =
    Status_RAPIDExecutionState_RAPIDExecutionState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RAPIDExecutionState_descriptor() {
    return Status_RAPIDExecutionState_descriptor();
  }
  static inline const ::std::string& RAPIDExecutionState_Name(RAPIDExecutionState value) {
    return Status_RAPIDExecutionState_Name(value);
  }
  static inline bool RAPIDExecutionState_Parse(const ::std::string& name,
      RAPIDExecutionState* value) {
    return Status_RAPIDExecutionState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool egm_convergence_met = 1;
  bool has_egm_convergence_met() const;
  void clear_egm_convergence_met();
  static const int kEgmConvergenceMetFieldNumber = 1;
  bool egm_convergence_met() const;
  void set_egm_convergence_met(bool value);

  // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
  bool has_egm_state() const;
  void clear_egm_state();
  static const int kEgmStateFieldNumber = 2;
  ::abb::egm::wrapper::Status_EGMState egm_state() const;
  void set_egm_state(::abb::egm::wrapper::Status_EGMState value);

  // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
  bool has_motor_state() const;
  void clear_motor_state();
  static const int kMotorStateFieldNumber = 3;
  ::abb::egm::wrapper::Status_MotorState motor_state() const;
  void set_motor_state(::abb::egm::wrapper::Status_MotorState value);

  // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
  bool has_rapid_execution_state() const;
  void clear_rapid_execution_state();
  static const int kRapidExecutionStateFieldNumber = 4;
  ::abb::egm::wrapper::Status_RAPIDExecutionState rapid_execution_state() const;
  void set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value);

  // optional double utilization_rate = 5;
  bool has_utilization_rate() const;
  void clear_utilization_rate();
  static const int kUtilizationRateFieldNumber = 5;
  double utilization_rate() const;
  void set_utilization_rate(double value);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Status)
 private:
  void set_has_egm_convergence_met();
  void clear_has_egm_convergence_met();
  void set_has_egm_state();
  void clear_has_egm_state();
  void set_has_motor_state();
  void clear_has_motor_state();
  void set_has_rapid_execution_state();
  void clear_has_rapid_execution_state();
  void set_has_utilization_rate();
  void clear_has_utilization_rate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool egm_convergence_met_;
  int egm_state_;
  int motor_state_;
  int rapid_execution_state_;
  double utilization_rate_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Clock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Clock) */ {
 public:
  Clock();
  virtual ~Clock();

  Clock(const Clock& from);

  inline Clock& operator=(const Clock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Clock(Clock&& from) noexcept
    : Clock() {
    *this = ::std::move(from);
  }

  inline Clock& operator=(Clock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Clock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Clock* internal_default_instance() {
    return reinterpret_cast<const Clock*>(
               &_Clock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Clock* other);
  friend void swap(Clock& a, Clock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Clock* New() const final {
    return CreateMaybeMessage<Clock>(NULL);
  }

  Clock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Clock>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Clock& from);
  void MergeFrom(const Clock& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Clock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 sec = 1;
  bool has_sec() const;
  void clear_sec();
  static const int kSecFieldNumber = 1;
  ::google::protobuf::uint64 sec() const;
  void set_sec(::google::protobuf::uint64 value);

  // optional uint64 usec = 2;
  bool has_usec() const;
  void clear_usec();
  static const int kUsecFieldNumber = 2;
  ::google::protobuf::uint64 usec() const;
  void set_usec(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Clock)
 private:
  void set_has_sec();
  void clear_has_sec();
  void set_has_usec();
  void clear_has_usec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 sec_;
  ::google::protobuf::uint64 usec_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Joints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Joints) */ {
 public:
  Joints();
  virtual ~Joints();

  Joints(const Joints& from);

  inline Joints& operator=(const Joints& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Joints(Joints&& from) noexcept
    : Joints() {
    *this = ::std::move(from);
  }

  inline Joints& operator=(Joints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Joints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Joints* internal_default_instance() {
    return reinterpret_cast<const Joints*>(
               &_Joints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Joints* other);
  friend void swap(Joints& a, Joints& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Joints* New() const final {
    return CreateMaybeMessage<Joints>(NULL);
  }

  Joints* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Joints>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Joints& from);
  void MergeFrom(const Joints& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Joints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::google::protobuf::RepeatedField< double >&
      values() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Joints)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< double > values_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JointSpace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.JointSpace) */ {
 public:
  JointSpace();
  virtual ~JointSpace();

  JointSpace(const JointSpace& from);

  inline JointSpace& operator=(const JointSpace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointSpace(JointSpace&& from) noexcept
    : JointSpace() {
    *this = ::std::move(from);
  }

  inline JointSpace& operator=(JointSpace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JointSpace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointSpace* internal_default_instance() {
    return reinterpret_cast<const JointSpace*>(
               &_JointSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(JointSpace* other);
  friend void swap(JointSpace& a, JointSpace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointSpace* New() const final {
    return CreateMaybeMessage<JointSpace>(NULL);
  }

  JointSpace* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JointSpace>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JointSpace& from);
  void MergeFrom(const JointSpace& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointSpace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.Joints position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  private:
  const ::abb::egm::wrapper::Joints& _internal_position() const;
  public:
  const ::abb::egm::wrapper::Joints& position() const;
  ::abb::egm::wrapper::Joints* release_position();
  ::abb::egm::wrapper::Joints* mutable_position();
  void set_allocated_position(::abb::egm::wrapper::Joints* position);

  // optional .abb.egm.wrapper.Joints velocity = 2;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  private:
  const ::abb::egm::wrapper::Joints& _internal_velocity() const;
  public:
  const ::abb::egm::wrapper::Joints& velocity() const;
  ::abb::egm::wrapper::Joints* release_velocity();
  ::abb::egm::wrapper::Joints* mutable_velocity();
  void set_allocated_velocity(::abb::egm::wrapper::Joints* velocity);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.JointSpace)
 private:
  void set_has_position();
  void clear_has_position();
  void set_has_velocity();
  void clear_has_velocity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::Joints* position_;
  ::abb::egm::wrapper::Joints* velocity_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Cartesian : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Cartesian) */ {
 public:
  Cartesian();
  virtual ~Cartesian();

  Cartesian(const Cartesian& from);

  inline Cartesian& operator=(const Cartesian& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Cartesian(Cartesian&& from) noexcept
    : Cartesian() {
    *this = ::std::move(from);
  }

  inline Cartesian& operator=(Cartesian&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cartesian& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Cartesian* internal_default_instance() {
    return reinterpret_cast<const Cartesian*>(
               &_Cartesian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Cartesian* other);
  friend void swap(Cartesian& a, Cartesian& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Cartesian* New() const final {
    return CreateMaybeMessage<Cartesian>(NULL);
  }

  Cartesian* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Cartesian>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Cartesian& from);
  void MergeFrom(const Cartesian& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cartesian* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Cartesian)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Euler : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Euler) */ {
 public:
  Euler();
  virtual ~Euler();

  Euler(const Euler& from);

  inline Euler& operator=(const Euler& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Euler(Euler&& from) noexcept
    : Euler() {
    *this = ::std::move(from);
  }

  inline Euler& operator=(Euler&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Euler& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Euler* internal_default_instance() {
    return reinterpret_cast<const Euler*>(
               &_Euler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Euler* other);
  friend void swap(Euler& a, Euler& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Euler* New() const final {
    return CreateMaybeMessage<Euler>(NULL);
  }

  Euler* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Euler>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Euler& from);
  void MergeFrom(const Euler& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Euler* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Euler)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Quaternion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Quaternion) */ {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Quaternion* other);
  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const final {
    return CreateMaybeMessage<Quaternion>(NULL);
  }

  Quaternion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double u0 = 1;
  bool has_u0() const;
  void clear_u0();
  static const int kU0FieldNumber = 1;
  double u0() const;
  void set_u0(double value);

  // optional double u1 = 2;
  bool has_u1() const;
  void clear_u1();
  static const int kU1FieldNumber = 2;
  double u1() const;
  void set_u1(double value);

  // optional double u2 = 3;
  bool has_u2() const;
  void clear_u2();
  static const int kU2FieldNumber = 3;
  double u2() const;
  void set_u2(double value);

  // optional double u3 = 4;
  bool has_u3() const;
  void clear_u3();
  static const int kU3FieldNumber = 4;
  double u3() const;
  void set_u3(double value);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Quaternion)
 private:
  void set_has_u0();
  void clear_has_u0();
  void set_has_u1();
  void clear_has_u1();
  void set_has_u2();
  void clear_has_u2();
  void set_has_u3();
  void clear_has_u3();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double u0_;
  double u1_;
  double u2_;
  double u3_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CartesianPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.CartesianPose) */ {
 public:
  CartesianPose();
  virtual ~CartesianPose();

  CartesianPose(const CartesianPose& from);

  inline CartesianPose& operator=(const CartesianPose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianPose(CartesianPose&& from) noexcept
    : CartesianPose() {
    *this = ::std::move(from);
  }

  inline CartesianPose& operator=(CartesianPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianPose* internal_default_instance() {
    return reinterpret_cast<const CartesianPose*>(
               &_CartesianPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CartesianPose* other);
  friend void swap(CartesianPose& a, CartesianPose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianPose* New() const final {
    return CreateMaybeMessage<CartesianPose>(NULL);
  }

  CartesianPose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CartesianPose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CartesianPose& from);
  void MergeFrom(const CartesianPose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.Cartesian position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  private:
  const ::abb::egm::wrapper::Cartesian& _internal_position() const;
  public:
  const ::abb::egm::wrapper::Cartesian& position() const;
  ::abb::egm::wrapper::Cartesian* release_position();
  ::abb::egm::wrapper::Cartesian* mutable_position();
  void set_allocated_position(::abb::egm::wrapper::Cartesian* position);

  // optional .abb.egm.wrapper.Euler euler = 2;
  bool has_euler() const;
  void clear_euler();
  static const int kEulerFieldNumber = 2;
  private:
  const ::abb::egm::wrapper::Euler& _internal_euler() const;
  public:
  const ::abb::egm::wrapper::Euler& euler() const;
  ::abb::egm::wrapper::Euler* release_euler();
  ::abb::egm::wrapper::Euler* mutable_euler();
  void set_allocated_euler(::abb::egm::wrapper::Euler* euler);

  // optional .abb.egm.wrapper.Quaternion quaternion = 3;
  bool has_quaternion() const;
  void clear_quaternion();
  static const int kQuaternionFieldNumber = 3;
  private:
  const ::abb::egm::wrapper::Quaternion& _internal_quaternion() const;
  public:
  const ::abb::egm::wrapper::Quaternion& quaternion() const;
  ::abb::egm::wrapper::Quaternion* release_quaternion();
  ::abb::egm::wrapper::Quaternion* mutable_quaternion();
  void set_allocated_quaternion(::abb::egm::wrapper::Quaternion* quaternion);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianPose)
 private:
  void set_has_position();
  void clear_has_position();
  void set_has_euler();
  void clear_has_euler();
  void set_has_quaternion();
  void clear_has_quaternion();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::Cartesian* position_;
  ::abb::egm::wrapper::Euler* euler_;
  ::abb::egm::wrapper::Quaternion* quaternion_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CartesianVelocity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.CartesianVelocity) */ {
 public:
  CartesianVelocity();
  virtual ~CartesianVelocity();

  CartesianVelocity(const CartesianVelocity& from);

  inline CartesianVelocity& operator=(const CartesianVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianVelocity(CartesianVelocity&& from) noexcept
    : CartesianVelocity() {
    *this = ::std::move(from);
  }

  inline CartesianVelocity& operator=(CartesianVelocity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianVelocity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianVelocity* internal_default_instance() {
    return reinterpret_cast<const CartesianVelocity*>(
               &_CartesianVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CartesianVelocity* other);
  friend void swap(CartesianVelocity& a, CartesianVelocity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianVelocity* New() const final {
    return CreateMaybeMessage<CartesianVelocity>(NULL);
  }

  CartesianVelocity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CartesianVelocity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CartesianVelocity& from);
  void MergeFrom(const CartesianVelocity& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianVelocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.Cartesian linear = 1;
  bool has_linear() const;
  void clear_linear();
  static const int kLinearFieldNumber = 1;
  private:
  const ::abb::egm::wrapper::Cartesian& _internal_linear() const;
  public:
  const ::abb::egm::wrapper::Cartesian& linear() const;
  ::abb::egm::wrapper::Cartesian* release_linear();
  ::abb::egm::wrapper::Cartesian* mutable_linear();
  void set_allocated_linear(::abb::egm::wrapper::Cartesian* linear);

  // optional .abb.egm.wrapper.Euler angular = 2;
  bool has_angular() const;
  void clear_angular();
  static const int kAngularFieldNumber = 2;
  private:
  const ::abb::egm::wrapper::Euler& _internal_angular() const;
  public:
  const ::abb::egm::wrapper::Euler& angular() const;
  ::abb::egm::wrapper::Euler* release_angular();
  ::abb::egm::wrapper::Euler* mutable_angular();
  void set_allocated_angular(::abb::egm::wrapper::Euler* angular);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianVelocity)
 private:
  void set_has_linear();
  void clear_has_linear();
  void set_has_angular();
  void clear_has_angular();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::Cartesian* linear_;
  ::abb::egm::wrapper::Euler* angular_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CartesianSpace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.CartesianSpace) */ {
 public:
  CartesianSpace();
  virtual ~CartesianSpace();

  CartesianSpace(const CartesianSpace& from);

  inline CartesianSpace& operator=(const CartesianSpace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianSpace(CartesianSpace&& from) noexcept
    : CartesianSpace() {
    *this = ::std::move(from);
  }

  inline CartesianSpace& operator=(CartesianSpace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianSpace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianSpace* internal_default_instance() {
    return reinterpret_cast<const CartesianSpace*>(
               &_CartesianSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CartesianSpace* other);
  friend void swap(CartesianSpace& a, CartesianSpace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianSpace* New() const final {
    return CreateMaybeMessage<CartesianSpace>(NULL);
  }

  CartesianSpace* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CartesianSpace>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CartesianSpace& from);
  void MergeFrom(const CartesianSpace& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianSpace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 1;
  private:
  const ::abb::egm::wrapper::CartesianPose& _internal_pose() const;
  public:
  const ::abb::egm::wrapper::CartesianPose& pose() const;
  ::abb::egm::wrapper::CartesianPose* release_pose();
  ::abb::egm::wrapper::CartesianPose* mutable_pose();
  void set_allocated_pose(::abb::egm::wrapper::CartesianPose* pose);

  // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  private:
  const ::abb::egm::wrapper::CartesianVelocity& _internal_velocity() const;
  public:
  const ::abb::egm::wrapper::CartesianVelocity& velocity() const;
  ::abb::egm::wrapper::CartesianVelocity* release_velocity();
  ::abb::egm::wrapper::CartesianVelocity* mutable_velocity();
  void set_allocated_velocity(::abb::egm::wrapper::CartesianVelocity* velocity);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianSpace)
 private:
  void set_has_pose();
  void clear_has_pose();
  void set_has_velocity();
  void clear_has_velocity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::CartesianPose* pose_;
  ::abb::egm::wrapper::CartesianVelocity* velocity_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Robot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Robot) */ {
 public:
  Robot();
  virtual ~Robot();

  Robot(const Robot& from);

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(Robot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Robot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Robot* other);
  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Robot* New() const final {
    return CreateMaybeMessage<Robot>(NULL);
  }

  Robot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Robot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Robot& from);
  void MergeFrom(const Robot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.JointSpace joints = 1;
  bool has_joints() const;
  void clear_joints();
  static const int kJointsFieldNumber = 1;
  private:
  const ::abb::egm::wrapper::JointSpace& _internal_joints() const;
  public:
  const ::abb::egm::wrapper::JointSpace& joints() const;
  ::abb::egm::wrapper::JointSpace* release_joints();
  ::abb::egm::wrapper::JointSpace* mutable_joints();
  void set_allocated_joints(::abb::egm::wrapper::JointSpace* joints);

  // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
  bool has_cartesian() const;
  void clear_cartesian();
  static const int kCartesianFieldNumber = 2;
  private:
  const ::abb::egm::wrapper::CartesianSpace& _internal_cartesian() const;
  public:
  const ::abb::egm::wrapper::CartesianSpace& cartesian() const;
  ::abb::egm::wrapper::CartesianSpace* release_cartesian();
  ::abb::egm::wrapper::CartesianSpace* mutable_cartesian();
  void set_allocated_cartesian(::abb::egm::wrapper::CartesianSpace* cartesian);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Robot)
 private:
  void set_has_joints();
  void clear_has_joints();
  void set_has_cartesian();
  void clear_has_cartesian();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::JointSpace* joints_;
  ::abb::egm::wrapper::CartesianSpace* cartesian_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class External : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.External) */ {
 public:
  External();
  virtual ~External();

  External(const External& from);

  inline External& operator=(const External& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  External(External&& from) noexcept
    : External() {
    *this = ::std::move(from);
  }

  inline External& operator=(External&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const External& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const External* internal_default_instance() {
    return reinterpret_cast<const External*>(
               &_External_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(External* other);
  friend void swap(External& a, External& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline External* New() const final {
    return CreateMaybeMessage<External>(NULL);
  }

  External* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<External>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const External& from);
  void MergeFrom(const External& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(External* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.JointSpace joints = 1;
  bool has_joints() const;
  void clear_joints();
  static const int kJointsFieldNumber = 1;
  private:
  const ::abb::egm::wrapper::JointSpace& _internal_joints() const;
  public:
  const ::abb::egm::wrapper::JointSpace& joints() const;
  ::abb::egm::wrapper::JointSpace* release_joints();
  ::abb::egm::wrapper::JointSpace* mutable_joints();
  void set_allocated_joints(::abb::egm::wrapper::JointSpace* joints);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.External)
 private:
  void set_has_joints();
  void clear_has_joints();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::JointSpace* joints_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Feedback : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Feedback) */ {
 public:
  Feedback();
  virtual ~Feedback();

  Feedback(const Feedback& from);

  inline Feedback& operator=(const Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Feedback(Feedback&& from) noexcept
    : Feedback() {
    *this = ::std::move(from);
  }

  inline Feedback& operator=(Feedback&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Feedback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Feedback* internal_default_instance() {
    return reinterpret_cast<const Feedback*>(
               &_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Feedback* other);
  friend void swap(Feedback& a, Feedback& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Feedback* New() const final {
    return CreateMaybeMessage<Feedback>(NULL);
  }

  Feedback* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Feedback>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Feedback& from);
  void MergeFrom(const Feedback& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Feedback* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.Robot robot = 1;
  bool has_robot() const;
  void clear_robot();
  static const int kRobotFieldNumber = 1;
  private:
  const ::abb::egm::wrapper::Robot& _internal_robot() const;
  public:
  const ::abb::egm::wrapper::Robot& robot() const;
  ::abb::egm::wrapper::Robot* release_robot();
  ::abb::egm::wrapper::Robot* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::Robot* robot);

  // optional .abb.egm.wrapper.External external = 2;
  bool has_external() const;
  void clear_external();
  static const int kExternalFieldNumber = 2;
  private:
  const ::abb::egm::wrapper::External& _internal_external() const;
  public:
  const ::abb::egm::wrapper::External& external() const;
  ::abb::egm::wrapper::External* release_external();
  ::abb::egm::wrapper::External* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::External* external);

  // optional .abb.egm.wrapper.Clock time = 3;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  private:
  const ::abb::egm::wrapper::Clock& _internal_time() const;
  public:
  const ::abb::egm::wrapper::Clock& time() const;
  ::abb::egm::wrapper::Clock* release_time();
  ::abb::egm::wrapper::Clock* mutable_time();
  void set_allocated_time(::abb::egm::wrapper::Clock* time);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Feedback)
 private:
  void set_has_robot();
  void clear_has_robot();
  void set_has_external();
  void clear_has_external();
  void set_has_time();
  void clear_has_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::Robot* robot_;
  ::abb::egm::wrapper::External* external_;
  ::abb::egm::wrapper::Clock* time_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Planned : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Planned) */ {
 public:
  Planned();
  virtual ~Planned();

  Planned(const Planned& from);

  inline Planned& operator=(const Planned& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Planned(Planned&& from) noexcept
    : Planned() {
    *this = ::std::move(from);
  }

  inline Planned& operator=(Planned&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Planned& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Planned* internal_default_instance() {
    return reinterpret_cast<const Planned*>(
               &_Planned_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Planned* other);
  friend void swap(Planned& a, Planned& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Planned* New() const final {
    return CreateMaybeMessage<Planned>(NULL);
  }

  Planned* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Planned>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Planned& from);
  void MergeFrom(const Planned& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Planned* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.Robot robot = 1;
  bool has_robot() const;
  void clear_robot();
  static const int kRobotFieldNumber = 1;
  private:
  const ::abb::egm::wrapper::Robot& _internal_robot() const;
  public:
  const ::abb::egm::wrapper::Robot& robot() const;
  ::abb::egm::wrapper::Robot* release_robot();
  ::abb::egm::wrapper::Robot* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::Robot* robot);

  // optional .abb.egm.wrapper.External external = 2;
  bool has_external() const;
  void clear_external();
  static const int kExternalFieldNumber = 2;
  private:
  const ::abb::egm::wrapper::External& _internal_external() const;
  public:
  const ::abb::egm::wrapper::External& external() const;
  ::abb::egm::wrapper::External* release_external();
  ::abb::egm::wrapper::External* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::External* external);

  // optional .abb.egm.wrapper.Clock time = 3;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  private:
  const ::abb::egm::wrapper::Clock& _internal_time() const;
  public:
  const ::abb::egm::wrapper::Clock& time() const;
  ::abb::egm::wrapper::Clock* release_time();
  ::abb::egm::wrapper::Clock* mutable_time();
  void set_allocated_time(::abb::egm::wrapper::Clock* time);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Planned)
 private:
  void set_has_robot();
  void clear_has_robot();
  void set_has_external();
  void clear_has_external();
  void set_has_time();
  void clear_has_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::Robot* robot_;
  ::abb::egm::wrapper::External* external_;
  ::abb::egm::wrapper::Clock* time_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Input : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Input) */ {
 public:
  Input();
  virtual ~Input();

  Input(const Input& from);

  inline Input& operator=(const Input& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Input(Input&& from) noexcept
    : Input() {
    *this = ::std::move(from);
  }

  inline Input& operator=(Input&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Input& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Input* internal_default_instance() {
    return reinterpret_cast<const Input*>(
               &_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Input* other);
  friend void swap(Input& a, Input& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Input* New() const final {
    return CreateMaybeMessage<Input>(NULL);
  }

  Input* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Input>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Input& from);
  void MergeFrom(const Input& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Input* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::abb::egm::wrapper::Header& _internal_header() const;
  public:
  const ::abb::egm::wrapper::Header& header() const;
  ::abb::egm::wrapper::Header* release_header();
  ::abb::egm::wrapper::Header* mutable_header();
  void set_allocated_header(::abb::egm::wrapper::Header* header);

  // optional .abb.egm.wrapper.Feedback feedback = 2;
  bool has_feedback() const;
  void clear_feedback();
  static const int kFeedbackFieldNumber = 2;
  private:
  const ::abb::egm::wrapper::Feedback& _internal_feedback() const;
  public:
  const ::abb::egm::wrapper::Feedback& feedback() const;
  ::abb::egm::wrapper::Feedback* release_feedback();
  ::abb::egm::wrapper::Feedback* mutable_feedback();
  void set_allocated_feedback(::abb::egm::wrapper::Feedback* feedback);

  // optional .abb.egm.wrapper.Planned planned = 3;
  bool has_planned() const;
  void clear_planned();
  static const int kPlannedFieldNumber = 3;
  private:
  const ::abb::egm::wrapper::Planned& _internal_planned() const;
  public:
  const ::abb::egm::wrapper::Planned& planned() const;
  ::abb::egm::wrapper::Planned* release_planned();
  ::abb::egm::wrapper::Planned* mutable_planned();
  void set_allocated_planned(::abb::egm::wrapper::Planned* planned);

  // optional .abb.egm.wrapper.Status status = 4;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  private:
  const ::abb::egm::wrapper::Status& _internal_status() const;
  public:
  const ::abb::egm::wrapper::Status& status() const;
  ::abb::egm::wrapper::Status* release_status();
  ::abb::egm::wrapper::Status* mutable_status();
  void set_allocated_status(::abb::egm::wrapper::Status* status);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Input)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_feedback();
  void clear_has_feedback();
  void set_has_planned();
  void clear_has_planned();
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::Header* header_;
  ::abb::egm::wrapper::Feedback* feedback_;
  ::abb::egm::wrapper::Planned* planned_;
  ::abb::egm::wrapper::Status* status_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Output) */ {
 public:
  Output();
  virtual ~Output();

  Output(const Output& from);

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Output* other);
  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Output* New() const final {
    return CreateMaybeMessage<Output>(NULL);
  }

  Output* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.Robot robot = 1;
  bool has_robot() const;
  void clear_robot();
  static const int kRobotFieldNumber = 1;
  private:
  const ::abb::egm::wrapper::Robot& _internal_robot() const;
  public:
  const ::abb::egm::wrapper::Robot& robot() const;
  ::abb::egm::wrapper::Robot* release_robot();
  ::abb::egm::wrapper::Robot* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::Robot* robot);

  // optional .abb.egm.wrapper.External external = 2;
  bool has_external() const;
  void clear_external();
  static const int kExternalFieldNumber = 2;
  private:
  const ::abb::egm::wrapper::External& _internal_external() const;
  public:
  const ::abb::egm::wrapper::External& external() const;
  ::abb::egm::wrapper::External* release_external();
  ::abb::egm::wrapper::External* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::External* external);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Output)
 private:
  void set_has_robot();
  void clear_has_robot();
  void set_has_external();
  void clear_has_external();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::Robot* robot_;
  ::abb::egm::wrapper::External* external_;
  friend struct ::protobuf_egm_5fwrapper_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// optional uint32 sequence_number = 1;
inline bool Header::has_sequence_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_sequence_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_sequence_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_sequence_number() {
  sequence_number_ = 0u;
  clear_has_sequence_number();
}
inline ::google::protobuf::uint32 Header::sequence_number() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.sequence_number)
  return sequence_number_;
}
inline void Header::set_sequence_number(::google::protobuf::uint32 value) {
  set_has_sequence_number();
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.sequence_number)
}

// optional uint32 time_stamp = 2;
inline bool Header::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 Header::time_stamp() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.time_stamp)
  return time_stamp_;
}
inline void Header::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.time_stamp)
}

// optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
inline bool Header::has_message_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_message_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_message_type() {
  message_type_ = 0;
  clear_has_message_type();
}
inline ::abb::egm::wrapper::Header_MessageType Header::message_type() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.message_type)
  return static_cast< ::abb::egm::wrapper::Header_MessageType >(message_type_);
}
inline void Header::set_message_type(::abb::egm::wrapper::Header_MessageType value) {
  assert(::abb::egm::wrapper::Header_MessageType_IsValid(value));
  set_has_message_type();
  message_type_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.message_type)
}

// optional .abb.egm.wrapper.Header.RWVersion rw_version = 4 [default = RW_UNKNOWN];
inline bool Header::has_rw_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_rw_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_rw_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_rw_version() {
  rw_version_ = 0;
  clear_has_rw_version();
}
inline ::abb::egm::wrapper::Header_RWVersion Header::rw_version() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.rw_version)
  return static_cast< ::abb::egm::wrapper::Header_RWVersion >(rw_version_);
}
inline void Header::set_rw_version(::abb::egm::wrapper::Header_RWVersion value) {
  assert(::abb::egm::wrapper::Header_RWVersion_IsValid(value));
  set_has_rw_version();
  rw_version_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.rw_version)
}

// optional .abb.egm.wrapper.Header.EGMVersion egm_version = 5 [default = EGM_UNKNOWN];
inline bool Header::has_egm_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_egm_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_egm_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_egm_version() {
  egm_version_ = 0;
  clear_has_egm_version();
}
inline ::abb::egm::wrapper::Header_EGMVersion Header::egm_version() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.egm_version)
  return static_cast< ::abb::egm::wrapper::Header_EGMVersion >(egm_version_);
}
inline void Header::set_egm_version(::abb::egm::wrapper::Header_EGMVersion value) {
  assert(::abb::egm::wrapper::Header_EGMVersion_IsValid(value));
  set_has_egm_version();
  egm_version_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.egm_version)
}

// -------------------------------------------------------------------

// Status

// optional bool egm_convergence_met = 1;
inline bool Status::has_egm_convergence_met() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_egm_convergence_met() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_egm_convergence_met() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_egm_convergence_met() {
  egm_convergence_met_ = false;
  clear_has_egm_convergence_met();
}
inline bool Status::egm_convergence_met() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.egm_convergence_met)
  return egm_convergence_met_;
}
inline void Status::set_egm_convergence_met(bool value) {
  set_has_egm_convergence_met();
  egm_convergence_met_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.egm_convergence_met)
}

// optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
inline bool Status::has_egm_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Status::set_has_egm_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Status::clear_has_egm_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Status::clear_egm_state() {
  egm_state_ = 0;
  clear_has_egm_state();
}
inline ::abb::egm::wrapper::Status_EGMState Status::egm_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.egm_state)
  return static_cast< ::abb::egm::wrapper::Status_EGMState >(egm_state_);
}
inline void Status::set_egm_state(::abb::egm::wrapper::Status_EGMState value) {
  assert(::abb::egm::wrapper::Status_EGMState_IsValid(value));
  set_has_egm_state();
  egm_state_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.egm_state)
}

// optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
inline bool Status::has_motor_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Status::set_has_motor_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Status::clear_has_motor_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Status::clear_motor_state() {
  motor_state_ = 0;
  clear_has_motor_state();
}
inline ::abb::egm::wrapper::Status_MotorState Status::motor_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.motor_state)
  return static_cast< ::abb::egm::wrapper::Status_MotorState >(motor_state_);
}
inline void Status::set_motor_state(::abb::egm::wrapper::Status_MotorState value) {
  assert(::abb::egm::wrapper::Status_MotorState_IsValid(value));
  set_has_motor_state();
  motor_state_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.motor_state)
}

// optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
inline bool Status::has_rapid_execution_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Status::set_has_rapid_execution_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Status::clear_has_rapid_execution_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Status::clear_rapid_execution_state() {
  rapid_execution_state_ = 0;
  clear_has_rapid_execution_state();
}
inline ::abb::egm::wrapper::Status_RAPIDExecutionState Status::rapid_execution_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.rapid_execution_state)
  return static_cast< ::abb::egm::wrapper::Status_RAPIDExecutionState >(rapid_execution_state_);
}
inline void Status::set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value) {
  assert(::abb::egm::wrapper::Status_RAPIDExecutionState_IsValid(value));
  set_has_rapid_execution_state();
  rapid_execution_state_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.rapid_execution_state)
}

// optional double utilization_rate = 5;
inline bool Status::has_utilization_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Status::set_has_utilization_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Status::clear_has_utilization_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Status::clear_utilization_rate() {
  utilization_rate_ = 0;
  clear_has_utilization_rate();
}
inline double Status::utilization_rate() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.utilization_rate)
  return utilization_rate_;
}
inline void Status::set_utilization_rate(double value) {
  set_has_utilization_rate();
  utilization_rate_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.utilization_rate)
}

// -------------------------------------------------------------------

// Clock

// optional uint64 sec = 1;
inline bool Clock::has_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Clock::set_has_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Clock::clear_has_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Clock::clear_sec() {
  sec_ = GOOGLE_ULONGLONG(0);
  clear_has_sec();
}
inline ::google::protobuf::uint64 Clock::sec() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Clock.sec)
  return sec_;
}
inline void Clock::set_sec(::google::protobuf::uint64 value) {
  set_has_sec();
  sec_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Clock.sec)
}

// optional uint64 usec = 2;
inline bool Clock::has_usec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Clock::set_has_usec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Clock::clear_has_usec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Clock::clear_usec() {
  usec_ = GOOGLE_ULONGLONG(0);
  clear_has_usec();
}
inline ::google::protobuf::uint64 Clock::usec() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Clock.usec)
  return usec_;
}
inline void Clock::set_usec(::google::protobuf::uint64 value) {
  set_has_usec();
  usec_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Clock.usec)
}

// -------------------------------------------------------------------

// Joints

// repeated double values = 1;
inline int Joints::values_size() const {
  return values_.size();
}
inline void Joints::clear_values() {
  values_.Clear();
}
inline double Joints::values(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Joints.values)
  return values_.Get(index);
}
inline void Joints::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Joints.values)
}
inline void Joints::add_values(double value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:abb.egm.wrapper.Joints.values)
}
inline const ::google::protobuf::RepeatedField< double >&
Joints::values() const {
  // @@protoc_insertion_point(field_list:abb.egm.wrapper.Joints.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< double >*
Joints::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.wrapper.Joints.values)
  return &values_;
}

// -------------------------------------------------------------------

// JointSpace

// optional .abb.egm.wrapper.Joints position = 1;
inline bool JointSpace::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JointSpace::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JointSpace::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JointSpace::clear_position() {
  if (position_ != NULL) position_->Clear();
  clear_has_position();
}
inline const ::abb::egm::wrapper::Joints& JointSpace::_internal_position() const {
  return *position_;
}
inline const ::abb::egm::wrapper::Joints& JointSpace::position() const {
  const ::abb::egm::wrapper::Joints* p = position_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.JointSpace.position)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Joints*>(
      &::abb::egm::wrapper::_Joints_default_instance_);
}
inline ::abb::egm::wrapper::Joints* JointSpace::release_position() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.JointSpace.position)
  clear_has_position();
  ::abb::egm::wrapper::Joints* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointSpace::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.JointSpace.position)
  return position_;
}
inline void JointSpace::set_allocated_position(::abb::egm::wrapper::Joints* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.JointSpace.position)
}

// optional .abb.egm.wrapper.Joints velocity = 2;
inline bool JointSpace::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JointSpace::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JointSpace::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JointSpace::clear_velocity() {
  if (velocity_ != NULL) velocity_->Clear();
  clear_has_velocity();
}
inline const ::abb::egm::wrapper::Joints& JointSpace::_internal_velocity() const {
  return *velocity_;
}
inline const ::abb::egm::wrapper::Joints& JointSpace::velocity() const {
  const ::abb::egm::wrapper::Joints* p = velocity_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.JointSpace.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Joints*>(
      &::abb::egm::wrapper::_Joints_default_instance_);
}
inline ::abb::egm::wrapper::Joints* JointSpace::release_velocity() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.JointSpace.velocity)
  clear_has_velocity();
  ::abb::egm::wrapper::Joints* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointSpace::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArenaNoVirtual());
    velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.JointSpace.velocity)
  return velocity_;
}
inline void JointSpace::set_allocated_velocity(::abb::egm::wrapper::Joints* velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete velocity_;
  }
  if (velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.JointSpace.velocity)
}

// -------------------------------------------------------------------

// Cartesian

// optional double x = 1;
inline bool Cartesian::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cartesian::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cartesian::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cartesian::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Cartesian::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.x)
  return x_;
}
inline void Cartesian::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.x)
}

// optional double y = 2;
inline bool Cartesian::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cartesian::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cartesian::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cartesian::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Cartesian::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.y)
  return y_;
}
inline void Cartesian::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.y)
}

// optional double z = 3;
inline bool Cartesian::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cartesian::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Cartesian::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Cartesian::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Cartesian::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.z)
  return z_;
}
inline void Cartesian::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.z)
}

// -------------------------------------------------------------------

// Euler

// optional double x = 1;
inline bool Euler::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Euler::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Euler::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Euler::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Euler::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.x)
  return x_;
}
inline void Euler::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.x)
}

// optional double y = 2;
inline bool Euler::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Euler::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Euler::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Euler::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Euler::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.y)
  return y_;
}
inline void Euler::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.y)
}

// optional double z = 3;
inline bool Euler::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Euler::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Euler::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Euler::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Euler::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.z)
  return z_;
}
inline void Euler::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.z)
}

// -------------------------------------------------------------------

// Quaternion

// optional double u0 = 1;
inline bool Quaternion::has_u0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion::set_has_u0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion::clear_has_u0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion::clear_u0() {
  u0_ = 0;
  clear_has_u0();
}
inline double Quaternion::u0() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u0)
  return u0_;
}
inline void Quaternion::set_u0(double value) {
  set_has_u0();
  u0_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u0)
}

// optional double u1 = 2;
inline bool Quaternion::has_u1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion::set_has_u1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion::clear_has_u1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion::clear_u1() {
  u1_ = 0;
  clear_has_u1();
}
inline double Quaternion::u1() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u1)
  return u1_;
}
inline void Quaternion::set_u1(double value) {
  set_has_u1();
  u1_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u1)
}

// optional double u2 = 3;
inline bool Quaternion::has_u2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion::set_has_u2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion::clear_has_u2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion::clear_u2() {
  u2_ = 0;
  clear_has_u2();
}
inline double Quaternion::u2() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u2)
  return u2_;
}
inline void Quaternion::set_u2(double value) {
  set_has_u2();
  u2_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u2)
}

// optional double u3 = 4;
inline bool Quaternion::has_u3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion::set_has_u3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion::clear_has_u3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion::clear_u3() {
  u3_ = 0;
  clear_has_u3();
}
inline double Quaternion::u3() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u3)
  return u3_;
}
inline void Quaternion::set_u3(double value) {
  set_has_u3();
  u3_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u3)
}

// -------------------------------------------------------------------

// CartesianPose

// optional .abb.egm.wrapper.Cartesian position = 1;
inline bool CartesianPose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CartesianPose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CartesianPose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CartesianPose::clear_position() {
  if (position_ != NULL) position_->Clear();
  clear_has_position();
}
inline const ::abb::egm::wrapper::Cartesian& CartesianPose::_internal_position() const {
  return *position_;
}
inline const ::abb::egm::wrapper::Cartesian& CartesianPose::position() const {
  const ::abb::egm::wrapper::Cartesian* p = position_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.position)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Cartesian*>(
      &::abb::egm::wrapper::_Cartesian_default_instance_);
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::release_position() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianPose.position)
  clear_has_position();
  ::abb::egm::wrapper::Cartesian* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Cartesian>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.position)
  return position_;
}
inline void CartesianPose::set_allocated_position(::abb::egm::wrapper::Cartesian* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.position)
}

// optional .abb.egm.wrapper.Euler euler = 2;
inline bool CartesianPose::has_euler() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CartesianPose::set_has_euler() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CartesianPose::clear_has_euler() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CartesianPose::clear_euler() {
  if (euler_ != NULL) euler_->Clear();
  clear_has_euler();
}
inline const ::abb::egm::wrapper::Euler& CartesianPose::_internal_euler() const {
  return *euler_;
}
inline const ::abb::egm::wrapper::Euler& CartesianPose::euler() const {
  const ::abb::egm::wrapper::Euler* p = euler_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.euler)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Euler*>(
      &::abb::egm::wrapper::_Euler_default_instance_);
}
inline ::abb::egm::wrapper::Euler* CartesianPose::release_euler() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianPose.euler)
  clear_has_euler();
  ::abb::egm::wrapper::Euler* temp = euler_;
  euler_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Euler* CartesianPose::mutable_euler() {
  set_has_euler();
  if (euler_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Euler>(GetArenaNoVirtual());
    euler_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.euler)
  return euler_;
}
inline void CartesianPose::set_allocated_euler(::abb::egm::wrapper::Euler* euler) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete euler_;
  }
  if (euler) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      euler = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, euler, submessage_arena);
    }
    set_has_euler();
  } else {
    clear_has_euler();
  }
  euler_ = euler;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.euler)
}

// optional .abb.egm.wrapper.Quaternion quaternion = 3;
inline bool CartesianPose::has_quaternion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CartesianPose::set_has_quaternion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CartesianPose::clear_has_quaternion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CartesianPose::clear_quaternion() {
  if (quaternion_ != NULL) quaternion_->Clear();
  clear_has_quaternion();
}
inline const ::abb::egm::wrapper::Quaternion& CartesianPose::_internal_quaternion() const {
  return *quaternion_;
}
inline const ::abb::egm::wrapper::Quaternion& CartesianPose::quaternion() const {
  const ::abb::egm::wrapper::Quaternion* p = quaternion_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.quaternion)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Quaternion*>(
      &::abb::egm::wrapper::_Quaternion_default_instance_);
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::release_quaternion() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianPose.quaternion)
  clear_has_quaternion();
  ::abb::egm::wrapper::Quaternion* temp = quaternion_;
  quaternion_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::mutable_quaternion() {
  set_has_quaternion();
  if (quaternion_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Quaternion>(GetArenaNoVirtual());
    quaternion_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.quaternion)
  return quaternion_;
}
inline void CartesianPose::set_allocated_quaternion(::abb::egm::wrapper::Quaternion* quaternion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete quaternion_;
  }
  if (quaternion) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      quaternion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, quaternion, submessage_arena);
    }
    set_has_quaternion();
  } else {
    clear_has_quaternion();
  }
  quaternion_ = quaternion;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.quaternion)
}

// -------------------------------------------------------------------

// CartesianVelocity

// optional .abb.egm.wrapper.Cartesian linear = 1;
inline bool CartesianVelocity::has_linear() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CartesianVelocity::set_has_linear() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CartesianVelocity::clear_has_linear() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CartesianVelocity::clear_linear() {
  if (linear_ != NULL) linear_->Clear();
  clear_has_linear();
}
inline const ::abb::egm::wrapper::Cartesian& CartesianVelocity::_internal_linear() const {
  return *linear_;
}
inline const ::abb::egm::wrapper::Cartesian& CartesianVelocity::linear() const {
  const ::abb::egm::wrapper::Cartesian* p = linear_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianVelocity.linear)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Cartesian*>(
      &::abb::egm::wrapper::_Cartesian_default_instance_);
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::release_linear() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianVelocity.linear)
  clear_has_linear();
  ::abb::egm::wrapper::Cartesian* temp = linear_;
  linear_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::mutable_linear() {
  set_has_linear();
  if (linear_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Cartesian>(GetArenaNoVirtual());
    linear_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianVelocity.linear)
  return linear_;
}
inline void CartesianVelocity::set_allocated_linear(::abb::egm::wrapper::Cartesian* linear) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete linear_;
  }
  if (linear) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linear = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    set_has_linear();
  } else {
    clear_has_linear();
  }
  linear_ = linear;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianVelocity.linear)
}

// optional .abb.egm.wrapper.Euler angular = 2;
inline bool CartesianVelocity::has_angular() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CartesianVelocity::set_has_angular() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CartesianVelocity::clear_has_angular() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CartesianVelocity::clear_angular() {
  if (angular_ != NULL) angular_->Clear();
  clear_has_angular();
}
inline const ::abb::egm::wrapper::Euler& CartesianVelocity::_internal_angular() const {
  return *angular_;
}
inline const ::abb::egm::wrapper::Euler& CartesianVelocity::angular() const {
  const ::abb::egm::wrapper::Euler* p = angular_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianVelocity.angular)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Euler*>(
      &::abb::egm::wrapper::_Euler_default_instance_);
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::release_angular() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianVelocity.angular)
  clear_has_angular();
  ::abb::egm::wrapper::Euler* temp = angular_;
  angular_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::mutable_angular() {
  set_has_angular();
  if (angular_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Euler>(GetArenaNoVirtual());
    angular_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianVelocity.angular)
  return angular_;
}
inline void CartesianVelocity::set_allocated_angular(::abb::egm::wrapper::Euler* angular) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete angular_;
  }
  if (angular) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angular = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angular, submessage_arena);
    }
    set_has_angular();
  } else {
    clear_has_angular();
  }
  angular_ = angular;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianVelocity.angular)
}

// -------------------------------------------------------------------

// CartesianSpace

// optional .abb.egm.wrapper.CartesianPose pose = 1;
inline bool CartesianSpace::has_pose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CartesianSpace::set_has_pose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CartesianSpace::clear_has_pose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CartesianSpace::clear_pose() {
  if (pose_ != NULL) pose_->Clear();
  clear_has_pose();
}
inline const ::abb::egm::wrapper::CartesianPose& CartesianSpace::_internal_pose() const {
  return *pose_;
}
inline const ::abb::egm::wrapper::CartesianPose& CartesianSpace::pose() const {
  const ::abb::egm::wrapper::CartesianPose* p = pose_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianSpace.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::CartesianPose*>(
      &::abb::egm::wrapper::_CartesianPose_default_instance_);
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::release_pose() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianSpace.pose)
  clear_has_pose();
  ::abb::egm::wrapper::CartesianPose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianPose>(GetArenaNoVirtual());
    pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianSpace.pose)
  return pose_;
}
inline void CartesianSpace::set_allocated_pose(::abb::egm::wrapper::CartesianPose* pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pose_;
  }
  if (pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    set_has_pose();
  } else {
    clear_has_pose();
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianSpace.pose)
}

// optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
inline bool CartesianSpace::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CartesianSpace::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CartesianSpace::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CartesianSpace::clear_velocity() {
  if (velocity_ != NULL) velocity_->Clear();
  clear_has_velocity();
}
inline const ::abb::egm::wrapper::CartesianVelocity& CartesianSpace::_internal_velocity() const {
  return *velocity_;
}
inline const ::abb::egm::wrapper::CartesianVelocity& CartesianSpace::velocity() const {
  const ::abb::egm::wrapper::CartesianVelocity* p = velocity_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianSpace.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::CartesianVelocity*>(
      &::abb::egm::wrapper::_CartesianVelocity_default_instance_);
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::release_velocity() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianSpace.velocity)
  clear_has_velocity();
  ::abb::egm::wrapper::CartesianVelocity* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianVelocity>(GetArenaNoVirtual());
    velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianSpace.velocity)
  return velocity_;
}
inline void CartesianSpace::set_allocated_velocity(::abb::egm::wrapper::CartesianVelocity* velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete velocity_;
  }
  if (velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianSpace.velocity)
}

// -------------------------------------------------------------------

// Robot

// optional .abb.egm.wrapper.JointSpace joints = 1;
inline bool Robot::has_joints() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Robot::set_has_joints() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Robot::clear_has_joints() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Robot::clear_joints() {
  if (joints_ != NULL) joints_->Clear();
  clear_has_joints();
}
inline const ::abb::egm::wrapper::JointSpace& Robot::_internal_joints() const {
  return *joints_;
}
inline const ::abb::egm::wrapper::JointSpace& Robot::joints() const {
  const ::abb::egm::wrapper::JointSpace* p = joints_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Robot.joints)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::JointSpace*>(
      &::abb::egm::wrapper::_JointSpace_default_instance_);
}
inline ::abb::egm::wrapper::JointSpace* Robot::release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Robot.joints)
  clear_has_joints();
  ::abb::egm::wrapper::JointSpace* temp = joints_;
  joints_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::JointSpace* Robot::mutable_joints() {
  set_has_joints();
  if (joints_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::JointSpace>(GetArenaNoVirtual());
    joints_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Robot.joints)
  return joints_;
}
inline void Robot::set_allocated_joints(::abb::egm::wrapper::JointSpace* joints) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete joints_;
  }
  if (joints) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      joints = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, joints, submessage_arena);
    }
    set_has_joints();
  } else {
    clear_has_joints();
  }
  joints_ = joints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Robot.joints)
}

// optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
inline bool Robot::has_cartesian() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Robot::set_has_cartesian() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Robot::clear_has_cartesian() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Robot::clear_cartesian() {
  if (cartesian_ != NULL) cartesian_->Clear();
  clear_has_cartesian();
}
inline const ::abb::egm::wrapper::CartesianSpace& Robot::_internal_cartesian() const {
  return *cartesian_;
}
inline const ::abb::egm::wrapper::CartesianSpace& Robot::cartesian() const {
  const ::abb::egm::wrapper::CartesianSpace* p = cartesian_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Robot.cartesian)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::CartesianSpace*>(
      &::abb::egm::wrapper::_CartesianSpace_default_instance_);
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::release_cartesian() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Robot.cartesian)
  clear_has_cartesian();
  ::abb::egm::wrapper::CartesianSpace* temp = cartesian_;
  cartesian_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::mutable_cartesian() {
  set_has_cartesian();
  if (cartesian_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianSpace>(GetArenaNoVirtual());
    cartesian_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Robot.cartesian)
  return cartesian_;
}
inline void Robot::set_allocated_cartesian(::abb::egm::wrapper::CartesianSpace* cartesian) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cartesian_;
  }
  if (cartesian) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cartesian = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cartesian, submessage_arena);
    }
    set_has_cartesian();
  } else {
    clear_has_cartesian();
  }
  cartesian_ = cartesian;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Robot.cartesian)
}

// -------------------------------------------------------------------

// External

// optional .abb.egm.wrapper.JointSpace joints = 1;
inline bool External::has_joints() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void External::set_has_joints() {
  _has_bits_[0] |= 0x00000001u;
}
inline void External::clear_has_joints() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void External::clear_joints() {
  if (joints_ != NULL) joints_->Clear();
  clear_has_joints();
}
inline const ::abb::egm::wrapper::JointSpace& External::_internal_joints() const {
  return *joints_;
}
inline const ::abb::egm::wrapper::JointSpace& External::joints() const {
  const ::abb::egm::wrapper::JointSpace* p = joints_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.External.joints)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::JointSpace*>(
      &::abb::egm::wrapper::_JointSpace_default_instance_);
}
inline ::abb::egm::wrapper::JointSpace* External::release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.External.joints)
  clear_has_joints();
  ::abb::egm::wrapper::JointSpace* temp = joints_;
  joints_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::JointSpace* External::mutable_joints() {
  set_has_joints();
  if (joints_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::JointSpace>(GetArenaNoVirtual());
    joints_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.External.joints)
  return joints_;
}
inline void External::set_allocated_joints(::abb::egm::wrapper::JointSpace* joints) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete joints_;
  }
  if (joints) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      joints = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, joints, submessage_arena);
    }
    set_has_joints();
  } else {
    clear_has_joints();
  }
  joints_ = joints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.External.joints)
}

// -------------------------------------------------------------------

// Feedback

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Feedback::has_robot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Feedback::set_has_robot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Feedback::clear_has_robot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Feedback::clear_robot() {
  if (robot_ != NULL) robot_->Clear();
  clear_has_robot();
}
inline const ::abb::egm::wrapper::Robot& Feedback::_internal_robot() const {
  return *robot_;
}
inline const ::abb::egm::wrapper::Robot& Feedback::robot() const {
  const ::abb::egm::wrapper::Robot* p = robot_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.robot)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Robot*>(
      &::abb::egm::wrapper::_Robot_default_instance_);
}
inline ::abb::egm::wrapper::Robot* Feedback::release_robot() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Feedback.robot)
  clear_has_robot();
  ::abb::egm::wrapper::Robot* temp = robot_;
  robot_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Robot* Feedback::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Robot>(GetArenaNoVirtual());
    robot_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.robot)
  return robot_;
}
inline void Feedback::set_allocated_robot(::abb::egm::wrapper::Robot* robot) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete robot_;
  }
  if (robot) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      robot = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    set_has_robot();
  } else {
    clear_has_robot();
  }
  robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Feedback::has_external() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Feedback::set_has_external() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Feedback::clear_has_external() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Feedback::clear_external() {
  if (external_ != NULL) external_->Clear();
  clear_has_external();
}
inline const ::abb::egm::wrapper::External& Feedback::_internal_external() const {
  return *external_;
}
inline const ::abb::egm::wrapper::External& Feedback::external() const {
  const ::abb::egm::wrapper::External* p = external_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.external)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::External*>(
      &::abb::egm::wrapper::_External_default_instance_);
}
inline ::abb::egm::wrapper::External* Feedback::release_external() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Feedback.external)
  clear_has_external();
  ::abb::egm::wrapper::External* temp = external_;
  external_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::External* Feedback::mutable_external() {
  set_has_external();
  if (external_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::External>(GetArenaNoVirtual());
    external_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.external)
  return external_;
}
inline void Feedback::set_allocated_external(::abb::egm::wrapper::External* external) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete external_;
  }
  if (external) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      external = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, external, submessage_arena);
    }
    set_has_external();
  } else {
    clear_has_external();
  }
  external_ = external;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.external)
}

// optional .abb.egm.wrapper.Clock time = 3;
inline bool Feedback::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Feedback::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Feedback::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Feedback::clear_time() {
  if (time_ != NULL) time_->Clear();
  clear_has_time();
}
inline const ::abb::egm::wrapper::Clock& Feedback::_internal_time() const {
  return *time_;
}
inline const ::abb::egm::wrapper::Clock& Feedback::time() const {
  const ::abb::egm::wrapper::Clock* p = time_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.time)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Clock*>(
      &::abb::egm::wrapper::_Clock_default_instance_);
}
inline ::abb::egm::wrapper::Clock* Feedback::release_time() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Feedback.time)
  clear_has_time();
  ::abb::egm::wrapper::Clock* temp = time_;
  time_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Clock* Feedback::mutable_time() {
  set_has_time();
  if (time_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Clock>(GetArenaNoVirtual());
    time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.time)
  return time_;
}
inline void Feedback::set_allocated_time(::abb::egm::wrapper::Clock* time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete time_;
  }
  if (time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    set_has_time();
  } else {
    clear_has_time();
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.time)
}

// -------------------------------------------------------------------

// Planned

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Planned::has_robot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Planned::set_has_robot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Planned::clear_has_robot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Planned::clear_robot() {
  if (robot_ != NULL) robot_->Clear();
  clear_has_robot();
}
inline const ::abb::egm::wrapper::Robot& Planned::_internal_robot() const {
  return *robot_;
}
inline const ::abb::egm::wrapper::Robot& Planned::robot() const {
  const ::abb::egm::wrapper::Robot* p = robot_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.robot)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Robot*>(
      &::abb::egm::wrapper::_Robot_default_instance_);
}
inline ::abb::egm::wrapper::Robot* Planned::release_robot() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Planned.robot)
  clear_has_robot();
  ::abb::egm::wrapper::Robot* temp = robot_;
  robot_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Robot* Planned::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Robot>(GetArenaNoVirtual());
    robot_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.robot)
  return robot_;
}
inline void Planned::set_allocated_robot(::abb::egm::wrapper::Robot* robot) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete robot_;
  }
  if (robot) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      robot = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    set_has_robot();
  } else {
    clear_has_robot();
  }
  robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Planned::has_external() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Planned::set_has_external() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Planned::clear_has_external() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Planned::clear_external() {
  if (external_ != NULL) external_->Clear();
  clear_has_external();
}
inline const ::abb::egm::wrapper::External& Planned::_internal_external() const {
  return *external_;
}
inline const ::abb::egm::wrapper::External& Planned::external() const {
  const ::abb::egm::wrapper::External* p = external_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.external)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::External*>(
      &::abb::egm::wrapper::_External_default_instance_);
}
inline ::abb::egm::wrapper::External* Planned::release_external() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Planned.external)
  clear_has_external();
  ::abb::egm::wrapper::External* temp = external_;
  external_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::External* Planned::mutable_external() {
  set_has_external();
  if (external_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::External>(GetArenaNoVirtual());
    external_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.external)
  return external_;
}
inline void Planned::set_allocated_external(::abb::egm::wrapper::External* external) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete external_;
  }
  if (external) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      external = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, external, submessage_arena);
    }
    set_has_external();
  } else {
    clear_has_external();
  }
  external_ = external;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.external)
}

// optional .abb.egm.wrapper.Clock time = 3;
inline bool Planned::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Planned::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Planned::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Planned::clear_time() {
  if (time_ != NULL) time_->Clear();
  clear_has_time();
}
inline const ::abb::egm::wrapper::Clock& Planned::_internal_time() const {
  return *time_;
}
inline const ::abb::egm::wrapper::Clock& Planned::time() const {
  const ::abb::egm::wrapper::Clock* p = time_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.time)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Clock*>(
      &::abb::egm::wrapper::_Clock_default_instance_);
}
inline ::abb::egm::wrapper::Clock* Planned::release_time() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Planned.time)
  clear_has_time();
  ::abb::egm::wrapper::Clock* temp = time_;
  time_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Clock* Planned::mutable_time() {
  set_has_time();
  if (time_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Clock>(GetArenaNoVirtual());
    time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.time)
  return time_;
}
inline void Planned::set_allocated_time(::abb::egm::wrapper::Clock* time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete time_;
  }
  if (time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    set_has_time();
  } else {
    clear_has_time();
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.time)
}

// -------------------------------------------------------------------

// Input

// optional .abb.egm.wrapper.Header header = 1;
inline bool Input::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Input::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Input::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Input::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::abb::egm::wrapper::Header& Input::_internal_header() const {
  return *header_;
}
inline const ::abb::egm::wrapper::Header& Input::header() const {
  const ::abb::egm::wrapper::Header* p = header_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.header)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Header*>(
      &::abb::egm::wrapper::_Header_default_instance_);
}
inline ::abb::egm::wrapper::Header* Input::release_header() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.header)
  clear_has_header();
  ::abb::egm::wrapper::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Header* Input::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.header)
  return header_;
}
inline void Input::set_allocated_header(::abb::egm::wrapper::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.header)
}

// optional .abb.egm.wrapper.Feedback feedback = 2;
inline bool Input::has_feedback() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Input::set_has_feedback() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Input::clear_has_feedback() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Input::clear_feedback() {
  if (feedback_ != NULL) feedback_->Clear();
  clear_has_feedback();
}
inline const ::abb::egm::wrapper::Feedback& Input::_internal_feedback() const {
  return *feedback_;
}
inline const ::abb::egm::wrapper::Feedback& Input::feedback() const {
  const ::abb::egm::wrapper::Feedback* p = feedback_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.feedback)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Feedback*>(
      &::abb::egm::wrapper::_Feedback_default_instance_);
}
inline ::abb::egm::wrapper::Feedback* Input::release_feedback() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.feedback)
  clear_has_feedback();
  ::abb::egm::wrapper::Feedback* temp = feedback_;
  feedback_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Feedback* Input::mutable_feedback() {
  set_has_feedback();
  if (feedback_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Feedback>(GetArenaNoVirtual());
    feedback_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.feedback)
  return feedback_;
}
inline void Input::set_allocated_feedback(::abb::egm::wrapper::Feedback* feedback) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete feedback_;
  }
  if (feedback) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      feedback = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, feedback, submessage_arena);
    }
    set_has_feedback();
  } else {
    clear_has_feedback();
  }
  feedback_ = feedback;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.feedback)
}

// optional .abb.egm.wrapper.Planned planned = 3;
inline bool Input::has_planned() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Input::set_has_planned() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Input::clear_has_planned() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Input::clear_planned() {
  if (planned_ != NULL) planned_->Clear();
  clear_has_planned();
}
inline const ::abb::egm::wrapper::Planned& Input::_internal_planned() const {
  return *planned_;
}
inline const ::abb::egm::wrapper::Planned& Input::planned() const {
  const ::abb::egm::wrapper::Planned* p = planned_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.planned)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Planned*>(
      &::abb::egm::wrapper::_Planned_default_instance_);
}
inline ::abb::egm::wrapper::Planned* Input::release_planned() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.planned)
  clear_has_planned();
  ::abb::egm::wrapper::Planned* temp = planned_;
  planned_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Planned* Input::mutable_planned() {
  set_has_planned();
  if (planned_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Planned>(GetArenaNoVirtual());
    planned_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.planned)
  return planned_;
}
inline void Input::set_allocated_planned(::abb::egm::wrapper::Planned* planned) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete planned_;
  }
  if (planned) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      planned = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, planned, submessage_arena);
    }
    set_has_planned();
  } else {
    clear_has_planned();
  }
  planned_ = planned;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.planned)
}

// optional .abb.egm.wrapper.Status status = 4;
inline bool Input::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Input::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Input::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Input::clear_status() {
  if (status_ != NULL) status_->Clear();
  clear_has_status();
}
inline const ::abb::egm::wrapper::Status& Input::_internal_status() const {
  return *status_;
}
inline const ::abb::egm::wrapper::Status& Input::status() const {
  const ::abb::egm::wrapper::Status* p = status_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.status)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Status*>(
      &::abb::egm::wrapper::_Status_default_instance_);
}
inline ::abb::egm::wrapper::Status* Input::release_status() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.status)
  clear_has_status();
  ::abb::egm::wrapper::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Status* Input::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Status>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.status)
  return status_;
}
inline void Input::set_allocated_status(::abb::egm::wrapper::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.status)
}

// -------------------------------------------------------------------

// Output

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Output::has_robot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Output::set_has_robot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Output::clear_has_robot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Output::clear_robot() {
  if (robot_ != NULL) robot_->Clear();
  clear_has_robot();
}
inline const ::abb::egm::wrapper::Robot& Output::_internal_robot() const {
  return *robot_;
}
inline const ::abb::egm::wrapper::Robot& Output::robot() const {
  const ::abb::egm::wrapper::Robot* p = robot_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Output.robot)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::Robot*>(
      &::abb::egm::wrapper::_Robot_default_instance_);
}
inline ::abb::egm::wrapper::Robot* Output::release_robot() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Output.robot)
  clear_has_robot();
  ::abb::egm::wrapper::Robot* temp = robot_;
  robot_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::Robot* Output::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Robot>(GetArenaNoVirtual());
    robot_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Output.robot)
  return robot_;
}
inline void Output::set_allocated_robot(::abb::egm::wrapper::Robot* robot) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete robot_;
  }
  if (robot) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      robot = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    set_has_robot();
  } else {
    clear_has_robot();
  }
  robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Output.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Output::has_external() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Output::set_has_external() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Output::clear_has_external() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Output::clear_external() {
  if (external_ != NULL) external_->Clear();
  clear_has_external();
}
inline const ::abb::egm::wrapper::External& Output::_internal_external() const {
  return *external_;
}
inline const ::abb::egm::wrapper::External& Output::external() const {
  const ::abb::egm::wrapper::External* p = external_;
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Output.external)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::wrapper::External*>(
      &::abb::egm::wrapper::_External_default_instance_);
}
inline ::abb::egm::wrapper::External* Output::release_external() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Output.external)
  clear_has_external();
  ::abb::egm::wrapper::External* temp = external_;
  external_ = NULL;
  return temp;
}
inline ::abb::egm::wrapper::External* Output::mutable_external() {
  set_has_external();
  if (external_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::External>(GetArenaNoVirtual());
    external_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Output.external)
  return external_;
}
inline void Output::set_allocated_external(::abb::egm::wrapper::External* external) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete external_;
  }
  if (external) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      external = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, external, submessage_arena);
    }
    set_has_external();
  } else {
    clear_has_external();
  }
  external_ = external;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Output.external)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace wrapper
}  // namespace egm
}  // namespace abb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::abb::egm::wrapper::Header_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Header_MessageType>() {
  return ::abb::egm::wrapper::Header_MessageType_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Header_RWVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Header_RWVersion>() {
  return ::abb::egm::wrapper::Header_RWVersion_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Header_EGMVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Header_EGMVersion>() {
  return ::abb::egm::wrapper::Header_EGMVersion_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Status_EGMState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Status_EGMState>() {
  return ::abb::egm::wrapper::Status_EGMState_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Status_MotorState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Status_MotorState>() {
  return ::abb::egm::wrapper::Status_MotorState_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Status_RAPIDExecutionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Status_RAPIDExecutionState>() {
  return ::abb::egm::wrapper::Status_RAPIDExecutionState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_egm_5fwrapper_2eproto
