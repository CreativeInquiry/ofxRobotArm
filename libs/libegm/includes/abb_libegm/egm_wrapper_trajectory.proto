//======================================================================================================================
//
// Wrapper messages for managing trajectories.
//
// These messages are intended to be used by an external EGM trajectory interface.
//
// Note: Used to wrap the actual EGM messages, which are defined in the egm.proto file from ABB Robotics.
//       This can be used in intermediate components that are utilizing EGM communication for motion control.
//
//======================================================================================================================

syntax = "proto2";

import "egm_wrapper.proto";

package abb.egm.wrapper.trajectory;

//======================================================================================================================
//
// Auxiliary messages.
//
//======================================================================================================================

//===========================================================
//
// Trajectory related messages.
//
//===========================================================

// Note: The acceleration field is only used as potential input for interpolation.
message JointGoal
{
  optional Joints position     = 1; // Units [degrees].
  optional Joints velocity     = 2; // Units [degrees/s].
  optional Joints acceleration = 3; // Units [degrees/s^2].
}

// Notes:
// - The Euler angles have higher priority than the quaternions (parts of the pose component).
// - Only linear velocity, because the orientation interpolation method (i.e. Slerp) result in uniform angular speed.
// - Only linear acceleration, and it is only used as potential input for interpolation.
message CartesianGoal
{
  optional CartesianPose pose         = 1; // Units [mm] and [degrees] or [-]
  optional Cartesian     velocity     = 2; // Units [mm/s].
  optional Cartesian     acceleration = 3; // Units [mm/s^2].
}

// Note: Joint or Cartesian motion depends on the used EGM RAPID instructions.
message RobotGoal
{
  optional JointGoal     joints    = 1;
  optional CartesianGoal cartesian = 2;
}

message ExternalGoal
{
  optional JointGoal joints = 1;
}

// Point goal in a trajectory.
message PointGoal
{
  optional double       duration = 1; // Units [s]. I.e. the time it should take to reach the point.
  optional RobotGoal    robot    = 2; // Goal for the robot.
  optional ExternalGoal external = 3; // Goal for external axes.
  optional bool         reach    = 4; // Flag indicating that the point is important to reach or not.
}

//===========================================================
//
// Static goal related messages.
//
//===========================================================

// Note: Joint or Cartesian motion depends on the used EGM RAPID instructions.
message RobotPositionGoal
{
  optional Joints        joints    = 1; // Units [degrees].
  optional CartesianPose cartesian = 2; // Units [mm] and [degrees].
}

// Note: Joint or Cartesian motion depends on the used EGM RAPID instructions.
message RobotVelocityGoal
{
  optional Joints            joints    = 1; // Units [degrees/s].
  optional CartesianVelocity cartesian = 2; // Units [mm/s] and [degrees/s].
}

//======================================================================================================================
//
// Primary messages.
//
//======================================================================================================================

// A trajectory goal that an EGM trajectory interface should follow.
message TrajectoryGoal
{
  repeated PointGoal points = 1;
}

// A static position goal that an EGM trajectory interface should execute.
message StaticPositionGoal
{
  optional RobotPositionGoal robot    = 1; // Units [degrees] and [mm].
  optional Joints            external = 2; // Units [degrees].
}

// A static velocity goal that an EGM trajectory interface should execute.
message StaticVelocityGoal
{
  optional RobotVelocityGoal robot    = 1; // Units [degrees/s] and [mm/s].
  optional Joints            external = 2; // Units [degrees/s].
}

// An execution progress for an EGM trajectory interface.
message ExecutionProgress
{
  // Possible states of the EGM trajectory interface.
  enum State
  {
    UNDEFINED   = 0; // The state is undefined.
    NORMAL      = 1; // Motion references are generated from trajectories added by a user.
    RAMP_DOWN   = 2; // Motion references are being ramped down.
    STATIC_GOAL = 3; // Motion references are generated by tracking a goal point specified by a user.
  }

  // Possible sub states of the EGM trajectory interface's state.
  enum SubState
  {
    NONE     = 0; // The current state has not been activated yet.
    RUNNING  = 1; // The current state is being executed.
    FINISHED = 2; // The current state has finished.
  }

  optional State          state                = 1 [default = UNDEFINED];
  optional SubState       sub_state            = 2 [default = NONE];
  optional Input          inputs               = 3; // The latest inputs received from the robot controller.
  optional Output         outputs              = 4; // The latest outputs sent to the robot controller.
  optional double         time_passed          = 5; // The time [s] passed since the current goal became active.
  optional bool           goal_active          = 6; // Indicates if a goal is currently active or not.
  optional PointGoal      goal                 = 7; // The current goal.
  optional TrajectoryGoal active_trajectory    = 8; // The currently active trajectory (if any has been activated).
  optional uint32         pending_trajectories = 9; // The number of pending trajectories in the queue.
}
