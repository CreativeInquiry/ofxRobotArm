// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm_wrapper.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_egm_5fwrapper_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_egm_5fwrapper_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_egm_5fwrapper_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_egm_5fwrapper_2eproto;
namespace abb {
namespace egm {
namespace wrapper {
class Cartesian;
class CartesianDefaultTypeInternal;
extern CartesianDefaultTypeInternal _Cartesian_default_instance_;
class CartesianPose;
class CartesianPoseDefaultTypeInternal;
extern CartesianPoseDefaultTypeInternal _CartesianPose_default_instance_;
class CartesianSpace;
class CartesianSpaceDefaultTypeInternal;
extern CartesianSpaceDefaultTypeInternal _CartesianSpace_default_instance_;
class CartesianVelocity;
class CartesianVelocityDefaultTypeInternal;
extern CartesianVelocityDefaultTypeInternal _CartesianVelocity_default_instance_;
class Clock;
class ClockDefaultTypeInternal;
extern ClockDefaultTypeInternal _Clock_default_instance_;
class Euler;
class EulerDefaultTypeInternal;
extern EulerDefaultTypeInternal _Euler_default_instance_;
class External;
class ExternalDefaultTypeInternal;
extern ExternalDefaultTypeInternal _External_default_instance_;
class Feedback;
class FeedbackDefaultTypeInternal;
extern FeedbackDefaultTypeInternal _Feedback_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Input;
class InputDefaultTypeInternal;
extern InputDefaultTypeInternal _Input_default_instance_;
class JointSpace;
class JointSpaceDefaultTypeInternal;
extern JointSpaceDefaultTypeInternal _JointSpace_default_instance_;
class Joints;
class JointsDefaultTypeInternal;
extern JointsDefaultTypeInternal _Joints_default_instance_;
class Output;
class OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class Planned;
class PlannedDefaultTypeInternal;
extern PlannedDefaultTypeInternal _Planned_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Robot;
class RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
}  // namespace wrapper
}  // namespace egm
}  // namespace abb
PROTOBUF_NAMESPACE_OPEN
template<> ::abb::egm::wrapper::Cartesian* Arena::CreateMaybeMessage<::abb::egm::wrapper::Cartesian>(Arena*);
template<> ::abb::egm::wrapper::CartesianPose* Arena::CreateMaybeMessage<::abb::egm::wrapper::CartesianPose>(Arena*);
template<> ::abb::egm::wrapper::CartesianSpace* Arena::CreateMaybeMessage<::abb::egm::wrapper::CartesianSpace>(Arena*);
template<> ::abb::egm::wrapper::CartesianVelocity* Arena::CreateMaybeMessage<::abb::egm::wrapper::CartesianVelocity>(Arena*);
template<> ::abb::egm::wrapper::Clock* Arena::CreateMaybeMessage<::abb::egm::wrapper::Clock>(Arena*);
template<> ::abb::egm::wrapper::Euler* Arena::CreateMaybeMessage<::abb::egm::wrapper::Euler>(Arena*);
template<> ::abb::egm::wrapper::External* Arena::CreateMaybeMessage<::abb::egm::wrapper::External>(Arena*);
template<> ::abb::egm::wrapper::Feedback* Arena::CreateMaybeMessage<::abb::egm::wrapper::Feedback>(Arena*);
template<> ::abb::egm::wrapper::Header* Arena::CreateMaybeMessage<::abb::egm::wrapper::Header>(Arena*);
template<> ::abb::egm::wrapper::Input* Arena::CreateMaybeMessage<::abb::egm::wrapper::Input>(Arena*);
template<> ::abb::egm::wrapper::JointSpace* Arena::CreateMaybeMessage<::abb::egm::wrapper::JointSpace>(Arena*);
template<> ::abb::egm::wrapper::Joints* Arena::CreateMaybeMessage<::abb::egm::wrapper::Joints>(Arena*);
template<> ::abb::egm::wrapper::Output* Arena::CreateMaybeMessage<::abb::egm::wrapper::Output>(Arena*);
template<> ::abb::egm::wrapper::Planned* Arena::CreateMaybeMessage<::abb::egm::wrapper::Planned>(Arena*);
template<> ::abb::egm::wrapper::Quaternion* Arena::CreateMaybeMessage<::abb::egm::wrapper::Quaternion>(Arena*);
template<> ::abb::egm::wrapper::Robot* Arena::CreateMaybeMessage<::abb::egm::wrapper::Robot>(Arena*);
template<> ::abb::egm::wrapper::Status* Arena::CreateMaybeMessage<::abb::egm::wrapper::Status>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace abb {
namespace egm {
namespace wrapper {

enum Header_MessageType : int {
  Header_MessageType_UNDEFINED = 0,
  Header_MessageType_DATA = 1
};
bool Header_MessageType_IsValid(int value);
constexpr Header_MessageType Header_MessageType_MessageType_MIN = Header_MessageType_UNDEFINED;
constexpr Header_MessageType Header_MessageType_MessageType_MAX = Header_MessageType_DATA;
constexpr int Header_MessageType_MessageType_ARRAYSIZE = Header_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Header_MessageType_descriptor();
template<typename T>
inline const std::string& Header_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Header_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Header_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Header_MessageType_descriptor(), enum_t_value);
}
inline bool Header_MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Header_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Header_MessageType>(
    Header_MessageType_descriptor(), name, value);
}
enum Header_RWVersion : int {
  Header_RWVersion_RW_UNKNOWN = 0,
  Header_RWVersion_RW_6_10_AND_NEWER = 1,
  Header_RWVersion_RW_BETWEEN_6_AND_6_06_03 = 2,
  Header_RWVersion_RW_BETWEEN_6_07_AND_6_09_02 = 3
};
bool Header_RWVersion_IsValid(int value);
constexpr Header_RWVersion Header_RWVersion_RWVersion_MIN = Header_RWVersion_RW_UNKNOWN;
constexpr Header_RWVersion Header_RWVersion_RWVersion_MAX = Header_RWVersion_RW_BETWEEN_6_07_AND_6_09_02;
constexpr int Header_RWVersion_RWVersion_ARRAYSIZE = Header_RWVersion_RWVersion_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Header_RWVersion_descriptor();
template<typename T>
inline const std::string& Header_RWVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Header_RWVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Header_RWVersion_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Header_RWVersion_descriptor(), enum_t_value);
}
inline bool Header_RWVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Header_RWVersion* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Header_RWVersion>(
    Header_RWVersion_descriptor(), name, value);
}
enum Header_EGMVersion : int {
  Header_EGMVersion_EGM_UNKNOWN = 0,
  Header_EGMVersion_EGM_1_0 = 1,
  Header_EGMVersion_EGM_1_1 = 2
};
bool Header_EGMVersion_IsValid(int value);
constexpr Header_EGMVersion Header_EGMVersion_EGMVersion_MIN = Header_EGMVersion_EGM_UNKNOWN;
constexpr Header_EGMVersion Header_EGMVersion_EGMVersion_MAX = Header_EGMVersion_EGM_1_1;
constexpr int Header_EGMVersion_EGMVersion_ARRAYSIZE = Header_EGMVersion_EGMVersion_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Header_EGMVersion_descriptor();
template<typename T>
inline const std::string& Header_EGMVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Header_EGMVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Header_EGMVersion_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Header_EGMVersion_descriptor(), enum_t_value);
}
inline bool Header_EGMVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Header_EGMVersion* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Header_EGMVersion>(
    Header_EGMVersion_descriptor(), name, value);
}
enum Status_EGMState : int {
  Status_EGMState_EGM_UNDEFINED = 0,
  Status_EGMState_EGM_ERROR = 1,
  Status_EGMState_EGM_STOPPED = 2,
  Status_EGMState_EGM_RUNNING = 3
};
bool Status_EGMState_IsValid(int value);
constexpr Status_EGMState Status_EGMState_EGMState_MIN = Status_EGMState_EGM_UNDEFINED;
constexpr Status_EGMState Status_EGMState_EGMState_MAX = Status_EGMState_EGM_RUNNING;
constexpr int Status_EGMState_EGMState_ARRAYSIZE = Status_EGMState_EGMState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_EGMState_descriptor();
template<typename T>
inline const std::string& Status_EGMState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status_EGMState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_EGMState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_EGMState_descriptor(), enum_t_value);
}
inline bool Status_EGMState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status_EGMState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status_EGMState>(
    Status_EGMState_descriptor(), name, value);
}
enum Status_MotorState : int {
  Status_MotorState_MOTORS_UNDEFINED = 0,
  Status_MotorState_MOTORS_ON = 1,
  Status_MotorState_MOTORS_OFF = 2
};
bool Status_MotorState_IsValid(int value);
constexpr Status_MotorState Status_MotorState_MotorState_MIN = Status_MotorState_MOTORS_UNDEFINED;
constexpr Status_MotorState Status_MotorState_MotorState_MAX = Status_MotorState_MOTORS_OFF;
constexpr int Status_MotorState_MotorState_ARRAYSIZE = Status_MotorState_MotorState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_MotorState_descriptor();
template<typename T>
inline const std::string& Status_MotorState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status_MotorState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_MotorState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_MotorState_descriptor(), enum_t_value);
}
inline bool Status_MotorState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status_MotorState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status_MotorState>(
    Status_MotorState_descriptor(), name, value);
}
enum Status_RAPIDExecutionState : int {
  Status_RAPIDExecutionState_RAPID_UNDEFINED = 0,
  Status_RAPIDExecutionState_RAPID_STOPPED = 1,
  Status_RAPIDExecutionState_RAPID_RUNNING = 2
};
bool Status_RAPIDExecutionState_IsValid(int value);
constexpr Status_RAPIDExecutionState Status_RAPIDExecutionState_RAPIDExecutionState_MIN = Status_RAPIDExecutionState_RAPID_UNDEFINED;
constexpr Status_RAPIDExecutionState Status_RAPIDExecutionState_RAPIDExecutionState_MAX = Status_RAPIDExecutionState_RAPID_RUNNING;
constexpr int Status_RAPIDExecutionState_RAPIDExecutionState_ARRAYSIZE = Status_RAPIDExecutionState_RAPIDExecutionState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_RAPIDExecutionState_descriptor();
template<typename T>
inline const std::string& Status_RAPIDExecutionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status_RAPIDExecutionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_RAPIDExecutionState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_RAPIDExecutionState_descriptor(), enum_t_value);
}
inline bool Status_RAPIDExecutionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status_RAPIDExecutionState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status_RAPIDExecutionState>(
    Status_RAPIDExecutionState_descriptor(), name, value);
}
// ===================================================================

class Header PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  virtual ~Header();

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Header& default_instance();

  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return CreateMaybeMessage<Header>(nullptr);
  }

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Header_MessageType MessageType;
  static constexpr MessageType UNDEFINED =
    Header_MessageType_UNDEFINED;
  static constexpr MessageType DATA =
    Header_MessageType_DATA;
  static inline bool MessageType_IsValid(int value) {
    return Header_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    Header_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    Header_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    Header_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return Header_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return Header_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MessageType* value) {
    return Header_MessageType_Parse(name, value);
  }

  typedef Header_RWVersion RWVersion;
  static constexpr RWVersion RW_UNKNOWN =
    Header_RWVersion_RW_UNKNOWN;
  static constexpr RWVersion RW_6_10_AND_NEWER =
    Header_RWVersion_RW_6_10_AND_NEWER;
  static constexpr RWVersion RW_BETWEEN_6_AND_6_06_03 =
    Header_RWVersion_RW_BETWEEN_6_AND_6_06_03;
  static constexpr RWVersion RW_BETWEEN_6_07_AND_6_09_02 =
    Header_RWVersion_RW_BETWEEN_6_07_AND_6_09_02;
  static inline bool RWVersion_IsValid(int value) {
    return Header_RWVersion_IsValid(value);
  }
  static constexpr RWVersion RWVersion_MIN =
    Header_RWVersion_RWVersion_MIN;
  static constexpr RWVersion RWVersion_MAX =
    Header_RWVersion_RWVersion_MAX;
  static constexpr int RWVersion_ARRAYSIZE =
    Header_RWVersion_RWVersion_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RWVersion_descriptor() {
    return Header_RWVersion_descriptor();
  }
  template<typename T>
  static inline const std::string& RWVersion_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RWVersion>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RWVersion_Name.");
    return Header_RWVersion_Name(enum_t_value);
  }
  static inline bool RWVersion_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RWVersion* value) {
    return Header_RWVersion_Parse(name, value);
  }

  typedef Header_EGMVersion EGMVersion;
  static constexpr EGMVersion EGM_UNKNOWN =
    Header_EGMVersion_EGM_UNKNOWN;
  static constexpr EGMVersion EGM_1_0 =
    Header_EGMVersion_EGM_1_0;
  static constexpr EGMVersion EGM_1_1 =
    Header_EGMVersion_EGM_1_1;
  static inline bool EGMVersion_IsValid(int value) {
    return Header_EGMVersion_IsValid(value);
  }
  static constexpr EGMVersion EGMVersion_MIN =
    Header_EGMVersion_EGMVersion_MIN;
  static constexpr EGMVersion EGMVersion_MAX =
    Header_EGMVersion_EGMVersion_MAX;
  static constexpr int EGMVersion_ARRAYSIZE =
    Header_EGMVersion_EGMVersion_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EGMVersion_descriptor() {
    return Header_EGMVersion_descriptor();
  }
  template<typename T>
  static inline const std::string& EGMVersion_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EGMVersion>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EGMVersion_Name.");
    return Header_EGMVersion_Name(enum_t_value);
  }
  static inline bool EGMVersion_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EGMVersion* value) {
    return Header_EGMVersion_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceNumberFieldNumber = 1,
    kTimeStampFieldNumber = 2,
    kMessageTypeFieldNumber = 3,
    kRwVersionFieldNumber = 4,
    kEgmVersionFieldNumber = 5,
  };
  // optional uint32 sequence_number = 1;
  bool has_sequence_number() const;
  private:
  bool _internal_has_sequence_number() const;
  public:
  void clear_sequence_number();
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence_number() const;
  void set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sequence_number() const;
  void _internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 time_stamp = 2;
  bool has_time_stamp() const;
  private:
  bool _internal_has_time_stamp() const;
  public:
  void clear_time_stamp();
  ::PROTOBUF_NAMESPACE_ID::uint32 time_stamp() const;
  void set_time_stamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_time_stamp() const;
  void _internal_set_time_stamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
  bool has_message_type() const;
  private:
  bool _internal_has_message_type() const;
  public:
  void clear_message_type();
  ::abb::egm::wrapper::Header_MessageType message_type() const;
  void set_message_type(::abb::egm::wrapper::Header_MessageType value);
  private:
  ::abb::egm::wrapper::Header_MessageType _internal_message_type() const;
  void _internal_set_message_type(::abb::egm::wrapper::Header_MessageType value);
  public:

  // optional .abb.egm.wrapper.Header.RWVersion rw_version = 4 [default = RW_UNKNOWN];
  bool has_rw_version() const;
  private:
  bool _internal_has_rw_version() const;
  public:
  void clear_rw_version();
  ::abb::egm::wrapper::Header_RWVersion rw_version() const;
  void set_rw_version(::abb::egm::wrapper::Header_RWVersion value);
  private:
  ::abb::egm::wrapper::Header_RWVersion _internal_rw_version() const;
  void _internal_set_rw_version(::abb::egm::wrapper::Header_RWVersion value);
  public:

  // optional .abb.egm.wrapper.Header.EGMVersion egm_version = 5 [default = EGM_UNKNOWN];
  bool has_egm_version() const;
  private:
  bool _internal_has_egm_version() const;
  public:
  void clear_egm_version();
  ::abb::egm::wrapper::Header_EGMVersion egm_version() const;
  void set_egm_version(::abb::egm::wrapper::Header_EGMVersion value);
  private:
  ::abb::egm::wrapper::Header_EGMVersion _internal_egm_version() const;
  void _internal_set_egm_version(::abb::egm::wrapper::Header_EGMVersion value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence_number_;
  ::PROTOBUF_NAMESPACE_ID::uint32 time_stamp_;
  int message_type_;
  int rw_version_;
  int egm_version_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Status PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  virtual ~Status();

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Status& default_instance();

  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(nullptr);
  }

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Status_EGMState EGMState;
  static constexpr EGMState EGM_UNDEFINED =
    Status_EGMState_EGM_UNDEFINED;
  static constexpr EGMState EGM_ERROR =
    Status_EGMState_EGM_ERROR;
  static constexpr EGMState EGM_STOPPED =
    Status_EGMState_EGM_STOPPED;
  static constexpr EGMState EGM_RUNNING =
    Status_EGMState_EGM_RUNNING;
  static inline bool EGMState_IsValid(int value) {
    return Status_EGMState_IsValid(value);
  }
  static constexpr EGMState EGMState_MIN =
    Status_EGMState_EGMState_MIN;
  static constexpr EGMState EGMState_MAX =
    Status_EGMState_EGMState_MAX;
  static constexpr int EGMState_ARRAYSIZE =
    Status_EGMState_EGMState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EGMState_descriptor() {
    return Status_EGMState_descriptor();
  }
  template<typename T>
  static inline const std::string& EGMState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EGMState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EGMState_Name.");
    return Status_EGMState_Name(enum_t_value);
  }
  static inline bool EGMState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EGMState* value) {
    return Status_EGMState_Parse(name, value);
  }

  typedef Status_MotorState MotorState;
  static constexpr MotorState MOTORS_UNDEFINED =
    Status_MotorState_MOTORS_UNDEFINED;
  static constexpr MotorState MOTORS_ON =
    Status_MotorState_MOTORS_ON;
  static constexpr MotorState MOTORS_OFF =
    Status_MotorState_MOTORS_OFF;
  static inline bool MotorState_IsValid(int value) {
    return Status_MotorState_IsValid(value);
  }
  static constexpr MotorState MotorState_MIN =
    Status_MotorState_MotorState_MIN;
  static constexpr MotorState MotorState_MAX =
    Status_MotorState_MotorState_MAX;
  static constexpr int MotorState_ARRAYSIZE =
    Status_MotorState_MotorState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MotorState_descriptor() {
    return Status_MotorState_descriptor();
  }
  template<typename T>
  static inline const std::string& MotorState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MotorState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MotorState_Name.");
    return Status_MotorState_Name(enum_t_value);
  }
  static inline bool MotorState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MotorState* value) {
    return Status_MotorState_Parse(name, value);
  }

  typedef Status_RAPIDExecutionState RAPIDExecutionState;
  static constexpr RAPIDExecutionState RAPID_UNDEFINED =
    Status_RAPIDExecutionState_RAPID_UNDEFINED;
  static constexpr RAPIDExecutionState RAPID_STOPPED =
    Status_RAPIDExecutionState_RAPID_STOPPED;
  static constexpr RAPIDExecutionState RAPID_RUNNING =
    Status_RAPIDExecutionState_RAPID_RUNNING;
  static inline bool RAPIDExecutionState_IsValid(int value) {
    return Status_RAPIDExecutionState_IsValid(value);
  }
  static constexpr RAPIDExecutionState RAPIDExecutionState_MIN =
    Status_RAPIDExecutionState_RAPIDExecutionState_MIN;
  static constexpr RAPIDExecutionState RAPIDExecutionState_MAX =
    Status_RAPIDExecutionState_RAPIDExecutionState_MAX;
  static constexpr int RAPIDExecutionState_ARRAYSIZE =
    Status_RAPIDExecutionState_RAPIDExecutionState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RAPIDExecutionState_descriptor() {
    return Status_RAPIDExecutionState_descriptor();
  }
  template<typename T>
  static inline const std::string& RAPIDExecutionState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RAPIDExecutionState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RAPIDExecutionState_Name.");
    return Status_RAPIDExecutionState_Name(enum_t_value);
  }
  static inline bool RAPIDExecutionState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RAPIDExecutionState* value) {
    return Status_RAPIDExecutionState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEgmConvergenceMetFieldNumber = 1,
    kEgmStateFieldNumber = 2,
    kMotorStateFieldNumber = 3,
    kRapidExecutionStateFieldNumber = 4,
    kUtilizationRateFieldNumber = 5,
  };
  // optional bool egm_convergence_met = 1;
  bool has_egm_convergence_met() const;
  private:
  bool _internal_has_egm_convergence_met() const;
  public:
  void clear_egm_convergence_met();
  bool egm_convergence_met() const;
  void set_egm_convergence_met(bool value);
  private:
  bool _internal_egm_convergence_met() const;
  void _internal_set_egm_convergence_met(bool value);
  public:

  // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
  bool has_egm_state() const;
  private:
  bool _internal_has_egm_state() const;
  public:
  void clear_egm_state();
  ::abb::egm::wrapper::Status_EGMState egm_state() const;
  void set_egm_state(::abb::egm::wrapper::Status_EGMState value);
  private:
  ::abb::egm::wrapper::Status_EGMState _internal_egm_state() const;
  void _internal_set_egm_state(::abb::egm::wrapper::Status_EGMState value);
  public:

  // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
  bool has_motor_state() const;
  private:
  bool _internal_has_motor_state() const;
  public:
  void clear_motor_state();
  ::abb::egm::wrapper::Status_MotorState motor_state() const;
  void set_motor_state(::abb::egm::wrapper::Status_MotorState value);
  private:
  ::abb::egm::wrapper::Status_MotorState _internal_motor_state() const;
  void _internal_set_motor_state(::abb::egm::wrapper::Status_MotorState value);
  public:

  // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
  bool has_rapid_execution_state() const;
  private:
  bool _internal_has_rapid_execution_state() const;
  public:
  void clear_rapid_execution_state();
  ::abb::egm::wrapper::Status_RAPIDExecutionState rapid_execution_state() const;
  void set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value);
  private:
  ::abb::egm::wrapper::Status_RAPIDExecutionState _internal_rapid_execution_state() const;
  void _internal_set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value);
  public:

  // optional double utilization_rate = 5;
  bool has_utilization_rate() const;
  private:
  bool _internal_has_utilization_rate() const;
  public:
  void clear_utilization_rate();
  double utilization_rate() const;
  void set_utilization_rate(double value);
  private:
  double _internal_utilization_rate() const;
  void _internal_set_utilization_rate(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool egm_convergence_met_;
  int egm_state_;
  int motor_state_;
  int rapid_execution_state_;
  double utilization_rate_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Clock PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Clock) */ {
 public:
  inline Clock() : Clock(nullptr) {}
  virtual ~Clock();

  Clock(const Clock& from);
  Clock(Clock&& from) noexcept
    : Clock() {
    *this = ::std::move(from);
  }

  inline Clock& operator=(const Clock& from) {
    CopyFrom(from);
    return *this;
  }
  inline Clock& operator=(Clock&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Clock& default_instance();

  static inline const Clock* internal_default_instance() {
    return reinterpret_cast<const Clock*>(
               &_Clock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Clock& a, Clock& b) {
    a.Swap(&b);
  }
  inline void Swap(Clock* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Clock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Clock* New() const final {
    return CreateMaybeMessage<Clock>(nullptr);
  }

  Clock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Clock>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Clock& from);
  void MergeFrom(const Clock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Clock* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Clock";
  }
  protected:
  explicit Clock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecFieldNumber = 1,
    kUsecFieldNumber = 2,
  };
  // optional uint64 sec = 1;
  bool has_sec() const;
  private:
  bool _internal_has_sec() const;
  public:
  void clear_sec();
  ::PROTOBUF_NAMESPACE_ID::uint64 sec() const;
  void set_sec(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sec() const;
  void _internal_set_sec(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 usec = 2;
  bool has_usec() const;
  private:
  bool _internal_has_usec() const;
  public:
  void clear_usec();
  ::PROTOBUF_NAMESPACE_ID::uint64 usec() const;
  void set_usec(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_usec() const;
  void _internal_set_usec(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Clock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sec_;
  ::PROTOBUF_NAMESPACE_ID::uint64 usec_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Joints PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Joints) */ {
 public:
  inline Joints() : Joints(nullptr) {}
  virtual ~Joints();

  Joints(const Joints& from);
  Joints(Joints&& from) noexcept
    : Joints() {
    *this = ::std::move(from);
  }

  inline Joints& operator=(const Joints& from) {
    CopyFrom(from);
    return *this;
  }
  inline Joints& operator=(Joints&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Joints& default_instance();

  static inline const Joints* internal_default_instance() {
    return reinterpret_cast<const Joints*>(
               &_Joints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Joints& a, Joints& b) {
    a.Swap(&b);
  }
  inline void Swap(Joints* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Joints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Joints* New() const final {
    return CreateMaybeMessage<Joints>(nullptr);
  }

  Joints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Joints>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Joints& from);
  void MergeFrom(const Joints& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Joints* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Joints";
  }
  protected:
  explicit Joints(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated double values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  double _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_values() const;
  void _internal_add_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_values();
  public:
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Joints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class JointSpace PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.JointSpace) */ {
 public:
  inline JointSpace() : JointSpace(nullptr) {}
  virtual ~JointSpace();

  JointSpace(const JointSpace& from);
  JointSpace(JointSpace&& from) noexcept
    : JointSpace() {
    *this = ::std::move(from);
  }

  inline JointSpace& operator=(const JointSpace& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointSpace& operator=(JointSpace&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const JointSpace& default_instance();

  static inline const JointSpace* internal_default_instance() {
    return reinterpret_cast<const JointSpace*>(
               &_JointSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JointSpace& a, JointSpace& b) {
    a.Swap(&b);
  }
  inline void Swap(JointSpace* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointSpace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JointSpace* New() const final {
    return CreateMaybeMessage<JointSpace>(nullptr);
  }

  JointSpace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JointSpace>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JointSpace& from);
  void MergeFrom(const JointSpace& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointSpace* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.JointSpace";
  }
  protected:
  explicit JointSpace(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kVelocityFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.Joints position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::abb::egm::wrapper::Joints& position() const;
  ::abb::egm::wrapper::Joints* release_position();
  ::abb::egm::wrapper::Joints* mutable_position();
  void set_allocated_position(::abb::egm::wrapper::Joints* position);
  private:
  const ::abb::egm::wrapper::Joints& _internal_position() const;
  ::abb::egm::wrapper::Joints* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::abb::egm::wrapper::Joints* position);
  ::abb::egm::wrapper::Joints* unsafe_arena_release_position();

  // optional .abb.egm.wrapper.Joints velocity = 2;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::abb::egm::wrapper::Joints& velocity() const;
  ::abb::egm::wrapper::Joints* release_velocity();
  ::abb::egm::wrapper::Joints* mutable_velocity();
  void set_allocated_velocity(::abb::egm::wrapper::Joints* velocity);
  private:
  const ::abb::egm::wrapper::Joints& _internal_velocity() const;
  ::abb::egm::wrapper::Joints* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::abb::egm::wrapper::Joints* velocity);
  ::abb::egm::wrapper::Joints* unsafe_arena_release_velocity();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.JointSpace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::Joints* position_;
  ::abb::egm::wrapper::Joints* velocity_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Cartesian PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Cartesian) */ {
 public:
  inline Cartesian() : Cartesian(nullptr) {}
  virtual ~Cartesian();

  Cartesian(const Cartesian& from);
  Cartesian(Cartesian&& from) noexcept
    : Cartesian() {
    *this = ::std::move(from);
  }

  inline Cartesian& operator=(const Cartesian& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cartesian& operator=(Cartesian&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Cartesian& default_instance();

  static inline const Cartesian* internal_default_instance() {
    return reinterpret_cast<const Cartesian*>(
               &_Cartesian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Cartesian& a, Cartesian& b) {
    a.Swap(&b);
  }
  inline void Swap(Cartesian* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cartesian* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Cartesian* New() const final {
    return CreateMaybeMessage<Cartesian>(nullptr);
  }

  Cartesian* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cartesian>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Cartesian& from);
  void MergeFrom(const Cartesian& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cartesian* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Cartesian";
  }
  protected:
  explicit Cartesian(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // optional double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Cartesian)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Euler PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Euler) */ {
 public:
  inline Euler() : Euler(nullptr) {}
  virtual ~Euler();

  Euler(const Euler& from);
  Euler(Euler&& from) noexcept
    : Euler() {
    *this = ::std::move(from);
  }

  inline Euler& operator=(const Euler& from) {
    CopyFrom(from);
    return *this;
  }
  inline Euler& operator=(Euler&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Euler& default_instance();

  static inline const Euler* internal_default_instance() {
    return reinterpret_cast<const Euler*>(
               &_Euler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Euler& a, Euler& b) {
    a.Swap(&b);
  }
  inline void Swap(Euler* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Euler* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Euler* New() const final {
    return CreateMaybeMessage<Euler>(nullptr);
  }

  Euler* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Euler>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Euler& from);
  void MergeFrom(const Euler& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Euler* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Euler";
  }
  protected:
  explicit Euler(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // optional double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Euler)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Quaternion PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Quaternion& default_instance();

  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const final {
    return CreateMaybeMessage<Quaternion>(nullptr);
  }

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kU0FieldNumber = 1,
    kU1FieldNumber = 2,
    kU2FieldNumber = 3,
    kU3FieldNumber = 4,
  };
  // optional double u0 = 1;
  bool has_u0() const;
  private:
  bool _internal_has_u0() const;
  public:
  void clear_u0();
  double u0() const;
  void set_u0(double value);
  private:
  double _internal_u0() const;
  void _internal_set_u0(double value);
  public:

  // optional double u1 = 2;
  bool has_u1() const;
  private:
  bool _internal_has_u1() const;
  public:
  void clear_u1();
  double u1() const;
  void set_u1(double value);
  private:
  double _internal_u1() const;
  void _internal_set_u1(double value);
  public:

  // optional double u2 = 3;
  bool has_u2() const;
  private:
  bool _internal_has_u2() const;
  public:
  void clear_u2();
  double u2() const;
  void set_u2(double value);
  private:
  double _internal_u2() const;
  void _internal_set_u2(double value);
  public:

  // optional double u3 = 4;
  bool has_u3() const;
  private:
  bool _internal_has_u3() const;
  public:
  void clear_u3();
  double u3() const;
  void set_u3(double value);
  private:
  double _internal_u3() const;
  void _internal_set_u3(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Quaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double u0_;
  double u1_;
  double u2_;
  double u3_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class CartesianPose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.CartesianPose) */ {
 public:
  inline CartesianPose() : CartesianPose(nullptr) {}
  virtual ~CartesianPose();

  CartesianPose(const CartesianPose& from);
  CartesianPose(CartesianPose&& from) noexcept
    : CartesianPose() {
    *this = ::std::move(from);
  }

  inline CartesianPose& operator=(const CartesianPose& from) {
    CopyFrom(from);
    return *this;
  }
  inline CartesianPose& operator=(CartesianPose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CartesianPose& default_instance();

  static inline const CartesianPose* internal_default_instance() {
    return reinterpret_cast<const CartesianPose*>(
               &_CartesianPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CartesianPose& a, CartesianPose& b) {
    a.Swap(&b);
  }
  inline void Swap(CartesianPose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CartesianPose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CartesianPose* New() const final {
    return CreateMaybeMessage<CartesianPose>(nullptr);
  }

  CartesianPose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CartesianPose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CartesianPose& from);
  void MergeFrom(const CartesianPose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianPose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.CartesianPose";
  }
  protected:
  explicit CartesianPose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kEulerFieldNumber = 2,
    kQuaternionFieldNumber = 3,
  };
  // optional .abb.egm.wrapper.Cartesian position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::abb::egm::wrapper::Cartesian& position() const;
  ::abb::egm::wrapper::Cartesian* release_position();
  ::abb::egm::wrapper::Cartesian* mutable_position();
  void set_allocated_position(::abb::egm::wrapper::Cartesian* position);
  private:
  const ::abb::egm::wrapper::Cartesian& _internal_position() const;
  ::abb::egm::wrapper::Cartesian* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::abb::egm::wrapper::Cartesian* position);
  ::abb::egm::wrapper::Cartesian* unsafe_arena_release_position();

  // optional .abb.egm.wrapper.Euler euler = 2;
  bool has_euler() const;
  private:
  bool _internal_has_euler() const;
  public:
  void clear_euler();
  const ::abb::egm::wrapper::Euler& euler() const;
  ::abb::egm::wrapper::Euler* release_euler();
  ::abb::egm::wrapper::Euler* mutable_euler();
  void set_allocated_euler(::abb::egm::wrapper::Euler* euler);
  private:
  const ::abb::egm::wrapper::Euler& _internal_euler() const;
  ::abb::egm::wrapper::Euler* _internal_mutable_euler();
  public:
  void unsafe_arena_set_allocated_euler(
      ::abb::egm::wrapper::Euler* euler);
  ::abb::egm::wrapper::Euler* unsafe_arena_release_euler();

  // optional .abb.egm.wrapper.Quaternion quaternion = 3;
  bool has_quaternion() const;
  private:
  bool _internal_has_quaternion() const;
  public:
  void clear_quaternion();
  const ::abb::egm::wrapper::Quaternion& quaternion() const;
  ::abb::egm::wrapper::Quaternion* release_quaternion();
  ::abb::egm::wrapper::Quaternion* mutable_quaternion();
  void set_allocated_quaternion(::abb::egm::wrapper::Quaternion* quaternion);
  private:
  const ::abb::egm::wrapper::Quaternion& _internal_quaternion() const;
  ::abb::egm::wrapper::Quaternion* _internal_mutable_quaternion();
  public:
  void unsafe_arena_set_allocated_quaternion(
      ::abb::egm::wrapper::Quaternion* quaternion);
  ::abb::egm::wrapper::Quaternion* unsafe_arena_release_quaternion();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianPose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::Cartesian* position_;
  ::abb::egm::wrapper::Euler* euler_;
  ::abb::egm::wrapper::Quaternion* quaternion_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class CartesianVelocity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.CartesianVelocity) */ {
 public:
  inline CartesianVelocity() : CartesianVelocity(nullptr) {}
  virtual ~CartesianVelocity();

  CartesianVelocity(const CartesianVelocity& from);
  CartesianVelocity(CartesianVelocity&& from) noexcept
    : CartesianVelocity() {
    *this = ::std::move(from);
  }

  inline CartesianVelocity& operator=(const CartesianVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline CartesianVelocity& operator=(CartesianVelocity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CartesianVelocity& default_instance();

  static inline const CartesianVelocity* internal_default_instance() {
    return reinterpret_cast<const CartesianVelocity*>(
               &_CartesianVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CartesianVelocity& a, CartesianVelocity& b) {
    a.Swap(&b);
  }
  inline void Swap(CartesianVelocity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CartesianVelocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CartesianVelocity* New() const final {
    return CreateMaybeMessage<CartesianVelocity>(nullptr);
  }

  CartesianVelocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CartesianVelocity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CartesianVelocity& from);
  void MergeFrom(const CartesianVelocity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianVelocity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.CartesianVelocity";
  }
  protected:
  explicit CartesianVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kAngularFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.Cartesian linear = 1;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::abb::egm::wrapper::Cartesian& linear() const;
  ::abb::egm::wrapper::Cartesian* release_linear();
  ::abb::egm::wrapper::Cartesian* mutable_linear();
  void set_allocated_linear(::abb::egm::wrapper::Cartesian* linear);
  private:
  const ::abb::egm::wrapper::Cartesian& _internal_linear() const;
  ::abb::egm::wrapper::Cartesian* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::abb::egm::wrapper::Cartesian* linear);
  ::abb::egm::wrapper::Cartesian* unsafe_arena_release_linear();

  // optional .abb.egm.wrapper.Euler angular = 2;
  bool has_angular() const;
  private:
  bool _internal_has_angular() const;
  public:
  void clear_angular();
  const ::abb::egm::wrapper::Euler& angular() const;
  ::abb::egm::wrapper::Euler* release_angular();
  ::abb::egm::wrapper::Euler* mutable_angular();
  void set_allocated_angular(::abb::egm::wrapper::Euler* angular);
  private:
  const ::abb::egm::wrapper::Euler& _internal_angular() const;
  ::abb::egm::wrapper::Euler* _internal_mutable_angular();
  public:
  void unsafe_arena_set_allocated_angular(
      ::abb::egm::wrapper::Euler* angular);
  ::abb::egm::wrapper::Euler* unsafe_arena_release_angular();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianVelocity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::Cartesian* linear_;
  ::abb::egm::wrapper::Euler* angular_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class CartesianSpace PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.CartesianSpace) */ {
 public:
  inline CartesianSpace() : CartesianSpace(nullptr) {}
  virtual ~CartesianSpace();

  CartesianSpace(const CartesianSpace& from);
  CartesianSpace(CartesianSpace&& from) noexcept
    : CartesianSpace() {
    *this = ::std::move(from);
  }

  inline CartesianSpace& operator=(const CartesianSpace& from) {
    CopyFrom(from);
    return *this;
  }
  inline CartesianSpace& operator=(CartesianSpace&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CartesianSpace& default_instance();

  static inline const CartesianSpace* internal_default_instance() {
    return reinterpret_cast<const CartesianSpace*>(
               &_CartesianSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CartesianSpace& a, CartesianSpace& b) {
    a.Swap(&b);
  }
  inline void Swap(CartesianSpace* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CartesianSpace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CartesianSpace* New() const final {
    return CreateMaybeMessage<CartesianSpace>(nullptr);
  }

  CartesianSpace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CartesianSpace>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CartesianSpace& from);
  void MergeFrom(const CartesianSpace& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianSpace* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.CartesianSpace";
  }
  protected:
  explicit CartesianSpace(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
    kVelocityFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::abb::egm::wrapper::CartesianPose& pose() const;
  ::abb::egm::wrapper::CartesianPose* release_pose();
  ::abb::egm::wrapper::CartesianPose* mutable_pose();
  void set_allocated_pose(::abb::egm::wrapper::CartesianPose* pose);
  private:
  const ::abb::egm::wrapper::CartesianPose& _internal_pose() const;
  ::abb::egm::wrapper::CartesianPose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::abb::egm::wrapper::CartesianPose* pose);
  ::abb::egm::wrapper::CartesianPose* unsafe_arena_release_pose();

  // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::abb::egm::wrapper::CartesianVelocity& velocity() const;
  ::abb::egm::wrapper::CartesianVelocity* release_velocity();
  ::abb::egm::wrapper::CartesianVelocity* mutable_velocity();
  void set_allocated_velocity(::abb::egm::wrapper::CartesianVelocity* velocity);
  private:
  const ::abb::egm::wrapper::CartesianVelocity& _internal_velocity() const;
  ::abb::egm::wrapper::CartesianVelocity* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::abb::egm::wrapper::CartesianVelocity* velocity);
  ::abb::egm::wrapper::CartesianVelocity* unsafe_arena_release_velocity();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianSpace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::CartesianPose* pose_;
  ::abb::egm::wrapper::CartesianVelocity* velocity_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Robot PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Robot) */ {
 public:
  inline Robot() : Robot(nullptr) {}
  virtual ~Robot();

  Robot(const Robot& from);
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot& operator=(Robot&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Robot& default_instance();

  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Robot* New() const final {
    return CreateMaybeMessage<Robot>(nullptr);
  }

  Robot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Robot>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Robot& from);
  void MergeFrom(const Robot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Robot";
  }
  protected:
  explicit Robot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesianFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  bool has_joints() const;
  private:
  bool _internal_has_joints() const;
  public:
  void clear_joints();
  const ::abb::egm::wrapper::JointSpace& joints() const;
  ::abb::egm::wrapper::JointSpace* release_joints();
  ::abb::egm::wrapper::JointSpace* mutable_joints();
  void set_allocated_joints(::abb::egm::wrapper::JointSpace* joints);
  private:
  const ::abb::egm::wrapper::JointSpace& _internal_joints() const;
  ::abb::egm::wrapper::JointSpace* _internal_mutable_joints();
  public:
  void unsafe_arena_set_allocated_joints(
      ::abb::egm::wrapper::JointSpace* joints);
  ::abb::egm::wrapper::JointSpace* unsafe_arena_release_joints();

  // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
  bool has_cartesian() const;
  private:
  bool _internal_has_cartesian() const;
  public:
  void clear_cartesian();
  const ::abb::egm::wrapper::CartesianSpace& cartesian() const;
  ::abb::egm::wrapper::CartesianSpace* release_cartesian();
  ::abb::egm::wrapper::CartesianSpace* mutable_cartesian();
  void set_allocated_cartesian(::abb::egm::wrapper::CartesianSpace* cartesian);
  private:
  const ::abb::egm::wrapper::CartesianSpace& _internal_cartesian() const;
  ::abb::egm::wrapper::CartesianSpace* _internal_mutable_cartesian();
  public:
  void unsafe_arena_set_allocated_cartesian(
      ::abb::egm::wrapper::CartesianSpace* cartesian);
  ::abb::egm::wrapper::CartesianSpace* unsafe_arena_release_cartesian();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Robot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::JointSpace* joints_;
  ::abb::egm::wrapper::CartesianSpace* cartesian_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class External PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.External) */ {
 public:
  inline External() : External(nullptr) {}
  virtual ~External();

  External(const External& from);
  External(External&& from) noexcept
    : External() {
    *this = ::std::move(from);
  }

  inline External& operator=(const External& from) {
    CopyFrom(from);
    return *this;
  }
  inline External& operator=(External&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const External& default_instance();

  static inline const External* internal_default_instance() {
    return reinterpret_cast<const External*>(
               &_External_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(External& a, External& b) {
    a.Swap(&b);
  }
  inline void Swap(External* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(External* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline External* New() const final {
    return CreateMaybeMessage<External>(nullptr);
  }

  External* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<External>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const External& from);
  void MergeFrom(const External& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(External* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.External";
  }
  protected:
  explicit External(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
  };
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  bool has_joints() const;
  private:
  bool _internal_has_joints() const;
  public:
  void clear_joints();
  const ::abb::egm::wrapper::JointSpace& joints() const;
  ::abb::egm::wrapper::JointSpace* release_joints();
  ::abb::egm::wrapper::JointSpace* mutable_joints();
  void set_allocated_joints(::abb::egm::wrapper::JointSpace* joints);
  private:
  const ::abb::egm::wrapper::JointSpace& _internal_joints() const;
  ::abb::egm::wrapper::JointSpace* _internal_mutable_joints();
  public:
  void unsafe_arena_set_allocated_joints(
      ::abb::egm::wrapper::JointSpace* joints);
  ::abb::egm::wrapper::JointSpace* unsafe_arena_release_joints();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.External)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::JointSpace* joints_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Feedback PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Feedback) */ {
 public:
  inline Feedback() : Feedback(nullptr) {}
  virtual ~Feedback();

  Feedback(const Feedback& from);
  Feedback(Feedback&& from) noexcept
    : Feedback() {
    *this = ::std::move(from);
  }

  inline Feedback& operator=(const Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline Feedback& operator=(Feedback&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Feedback& default_instance();

  static inline const Feedback* internal_default_instance() {
    return reinterpret_cast<const Feedback*>(
               &_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Feedback& a, Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(Feedback* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Feedback* New() const final {
    return CreateMaybeMessage<Feedback>(nullptr);
  }

  Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Feedback>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Feedback& from);
  void MergeFrom(const Feedback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Feedback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Feedback";
  }
  protected:
  explicit Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
    kExternalFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // optional .abb.egm.wrapper.Robot robot = 1;
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::abb::egm::wrapper::Robot& robot() const;
  ::abb::egm::wrapper::Robot* release_robot();
  ::abb::egm::wrapper::Robot* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::Robot* robot);
  private:
  const ::abb::egm::wrapper::Robot& _internal_robot() const;
  ::abb::egm::wrapper::Robot* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::abb::egm::wrapper::Robot* robot);
  ::abb::egm::wrapper::Robot* unsafe_arena_release_robot();

  // optional .abb.egm.wrapper.External external = 2;
  bool has_external() const;
  private:
  bool _internal_has_external() const;
  public:
  void clear_external();
  const ::abb::egm::wrapper::External& external() const;
  ::abb::egm::wrapper::External* release_external();
  ::abb::egm::wrapper::External* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::External* external);
  private:
  const ::abb::egm::wrapper::External& _internal_external() const;
  ::abb::egm::wrapper::External* _internal_mutable_external();
  public:
  void unsafe_arena_set_allocated_external(
      ::abb::egm::wrapper::External* external);
  ::abb::egm::wrapper::External* unsafe_arena_release_external();

  // optional .abb.egm.wrapper.Clock time = 3;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::abb::egm::wrapper::Clock& time() const;
  ::abb::egm::wrapper::Clock* release_time();
  ::abb::egm::wrapper::Clock* mutable_time();
  void set_allocated_time(::abb::egm::wrapper::Clock* time);
  private:
  const ::abb::egm::wrapper::Clock& _internal_time() const;
  ::abb::egm::wrapper::Clock* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::abb::egm::wrapper::Clock* time);
  ::abb::egm::wrapper::Clock* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::Robot* robot_;
  ::abb::egm::wrapper::External* external_;
  ::abb::egm::wrapper::Clock* time_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Planned PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Planned) */ {
 public:
  inline Planned() : Planned(nullptr) {}
  virtual ~Planned();

  Planned(const Planned& from);
  Planned(Planned&& from) noexcept
    : Planned() {
    *this = ::std::move(from);
  }

  inline Planned& operator=(const Planned& from) {
    CopyFrom(from);
    return *this;
  }
  inline Planned& operator=(Planned&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Planned& default_instance();

  static inline const Planned* internal_default_instance() {
    return reinterpret_cast<const Planned*>(
               &_Planned_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Planned& a, Planned& b) {
    a.Swap(&b);
  }
  inline void Swap(Planned* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Planned* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Planned* New() const final {
    return CreateMaybeMessage<Planned>(nullptr);
  }

  Planned* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Planned>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Planned& from);
  void MergeFrom(const Planned& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Planned* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Planned";
  }
  protected:
  explicit Planned(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
    kExternalFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // optional .abb.egm.wrapper.Robot robot = 1;
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::abb::egm::wrapper::Robot& robot() const;
  ::abb::egm::wrapper::Robot* release_robot();
  ::abb::egm::wrapper::Robot* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::Robot* robot);
  private:
  const ::abb::egm::wrapper::Robot& _internal_robot() const;
  ::abb::egm::wrapper::Robot* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::abb::egm::wrapper::Robot* robot);
  ::abb::egm::wrapper::Robot* unsafe_arena_release_robot();

  // optional .abb.egm.wrapper.External external = 2;
  bool has_external() const;
  private:
  bool _internal_has_external() const;
  public:
  void clear_external();
  const ::abb::egm::wrapper::External& external() const;
  ::abb::egm::wrapper::External* release_external();
  ::abb::egm::wrapper::External* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::External* external);
  private:
  const ::abb::egm::wrapper::External& _internal_external() const;
  ::abb::egm::wrapper::External* _internal_mutable_external();
  public:
  void unsafe_arena_set_allocated_external(
      ::abb::egm::wrapper::External* external);
  ::abb::egm::wrapper::External* unsafe_arena_release_external();

  // optional .abb.egm.wrapper.Clock time = 3;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::abb::egm::wrapper::Clock& time() const;
  ::abb::egm::wrapper::Clock* release_time();
  ::abb::egm::wrapper::Clock* mutable_time();
  void set_allocated_time(::abb::egm::wrapper::Clock* time);
  private:
  const ::abb::egm::wrapper::Clock& _internal_time() const;
  ::abb::egm::wrapper::Clock* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::abb::egm::wrapper::Clock* time);
  ::abb::egm::wrapper::Clock* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Planned)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::Robot* robot_;
  ::abb::egm::wrapper::External* external_;
  ::abb::egm::wrapper::Clock* time_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Input PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Input) */ {
 public:
  inline Input() : Input(nullptr) {}
  virtual ~Input();

  Input(const Input& from);
  Input(Input&& from) noexcept
    : Input() {
    *this = ::std::move(from);
  }

  inline Input& operator=(const Input& from) {
    CopyFrom(from);
    return *this;
  }
  inline Input& operator=(Input&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Input& default_instance();

  static inline const Input* internal_default_instance() {
    return reinterpret_cast<const Input*>(
               &_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Input& a, Input& b) {
    a.Swap(&b);
  }
  inline void Swap(Input* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Input* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Input* New() const final {
    return CreateMaybeMessage<Input>(nullptr);
  }

  Input* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Input>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Input& from);
  void MergeFrom(const Input& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Input* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Input";
  }
  protected:
  explicit Input(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFeedbackFieldNumber = 2,
    kPlannedFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // optional .abb.egm.wrapper.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::abb::egm::wrapper::Header& header() const;
  ::abb::egm::wrapper::Header* release_header();
  ::abb::egm::wrapper::Header* mutable_header();
  void set_allocated_header(::abb::egm::wrapper::Header* header);
  private:
  const ::abb::egm::wrapper::Header& _internal_header() const;
  ::abb::egm::wrapper::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::abb::egm::wrapper::Header* header);
  ::abb::egm::wrapper::Header* unsafe_arena_release_header();

  // optional .abb.egm.wrapper.Feedback feedback = 2;
  bool has_feedback() const;
  private:
  bool _internal_has_feedback() const;
  public:
  void clear_feedback();
  const ::abb::egm::wrapper::Feedback& feedback() const;
  ::abb::egm::wrapper::Feedback* release_feedback();
  ::abb::egm::wrapper::Feedback* mutable_feedback();
  void set_allocated_feedback(::abb::egm::wrapper::Feedback* feedback);
  private:
  const ::abb::egm::wrapper::Feedback& _internal_feedback() const;
  ::abb::egm::wrapper::Feedback* _internal_mutable_feedback();
  public:
  void unsafe_arena_set_allocated_feedback(
      ::abb::egm::wrapper::Feedback* feedback);
  ::abb::egm::wrapper::Feedback* unsafe_arena_release_feedback();

  // optional .abb.egm.wrapper.Planned planned = 3;
  bool has_planned() const;
  private:
  bool _internal_has_planned() const;
  public:
  void clear_planned();
  const ::abb::egm::wrapper::Planned& planned() const;
  ::abb::egm::wrapper::Planned* release_planned();
  ::abb::egm::wrapper::Planned* mutable_planned();
  void set_allocated_planned(::abb::egm::wrapper::Planned* planned);
  private:
  const ::abb::egm::wrapper::Planned& _internal_planned() const;
  ::abb::egm::wrapper::Planned* _internal_mutable_planned();
  public:
  void unsafe_arena_set_allocated_planned(
      ::abb::egm::wrapper::Planned* planned);
  ::abb::egm::wrapper::Planned* unsafe_arena_release_planned();

  // optional .abb.egm.wrapper.Status status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::abb::egm::wrapper::Status& status() const;
  ::abb::egm::wrapper::Status* release_status();
  ::abb::egm::wrapper::Status* mutable_status();
  void set_allocated_status(::abb::egm::wrapper::Status* status);
  private:
  const ::abb::egm::wrapper::Status& _internal_status() const;
  ::abb::egm::wrapper::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::abb::egm::wrapper::Status* status);
  ::abb::egm::wrapper::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Input)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::Header* header_;
  ::abb::egm::wrapper::Feedback* feedback_;
  ::abb::egm::wrapper::Planned* planned_;
  ::abb::egm::wrapper::Status* status_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// -------------------------------------------------------------------

class Output PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.wrapper.Output) */ {
 public:
  inline Output() : Output(nullptr) {}
  virtual ~Output();

  Output(const Output& from);
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  inline Output& operator=(Output&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Output& default_instance();

  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }
  inline void Swap(Output* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Output* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Output* New() const final {
    return CreateMaybeMessage<Output>(nullptr);
  }

  Output* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.wrapper.Output";
  }
  protected:
  explicit Output(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_5fwrapper_2eproto);
    return ::descriptor_table_egm_5fwrapper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
    kExternalFieldNumber = 2,
  };
  // optional .abb.egm.wrapper.Robot robot = 1;
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::abb::egm::wrapper::Robot& robot() const;
  ::abb::egm::wrapper::Robot* release_robot();
  ::abb::egm::wrapper::Robot* mutable_robot();
  void set_allocated_robot(::abb::egm::wrapper::Robot* robot);
  private:
  const ::abb::egm::wrapper::Robot& _internal_robot() const;
  ::abb::egm::wrapper::Robot* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::abb::egm::wrapper::Robot* robot);
  ::abb::egm::wrapper::Robot* unsafe_arena_release_robot();

  // optional .abb.egm.wrapper.External external = 2;
  bool has_external() const;
  private:
  bool _internal_has_external() const;
  public:
  void clear_external();
  const ::abb::egm::wrapper::External& external() const;
  ::abb::egm::wrapper::External* release_external();
  ::abb::egm::wrapper::External* mutable_external();
  void set_allocated_external(::abb::egm::wrapper::External* external);
  private:
  const ::abb::egm::wrapper::External& _internal_external() const;
  ::abb::egm::wrapper::External* _internal_mutable_external();
  public:
  void unsafe_arena_set_allocated_external(
      ::abb::egm::wrapper::External* external);
  ::abb::egm::wrapper::External* unsafe_arena_release_external();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Output)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::wrapper::Robot* robot_;
  ::abb::egm::wrapper::External* external_;
  friend struct ::TableStruct_egm_5fwrapper_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// optional uint32 sequence_number = 1;
inline bool Header::_internal_has_sequence_number() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Header::has_sequence_number() const {
  return _internal_has_sequence_number();
}
inline void Header::clear_sequence_number() {
  sequence_number_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Header::_internal_sequence_number() const {
  return sequence_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Header::sequence_number() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.sequence_number)
  return _internal_sequence_number();
}
inline void Header::_internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  sequence_number_ = value;
}
inline void Header::set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.sequence_number)
}

// optional uint32 time_stamp = 2;
inline bool Header::_internal_has_time_stamp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Header::has_time_stamp() const {
  return _internal_has_time_stamp();
}
inline void Header::clear_time_stamp() {
  time_stamp_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Header::_internal_time_stamp() const {
  return time_stamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Header::time_stamp() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.time_stamp)
  return _internal_time_stamp();
}
inline void Header::_internal_set_time_stamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  time_stamp_ = value;
}
inline void Header::set_time_stamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_time_stamp(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.time_stamp)
}

// optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
inline bool Header::_internal_has_message_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Header::has_message_type() const {
  return _internal_has_message_type();
}
inline void Header::clear_message_type() {
  message_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::abb::egm::wrapper::Header_MessageType Header::_internal_message_type() const {
  return static_cast< ::abb::egm::wrapper::Header_MessageType >(message_type_);
}
inline ::abb::egm::wrapper::Header_MessageType Header::message_type() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.message_type)
  return _internal_message_type();
}
inline void Header::_internal_set_message_type(::abb::egm::wrapper::Header_MessageType value) {
  assert(::abb::egm::wrapper::Header_MessageType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  message_type_ = value;
}
inline void Header::set_message_type(::abb::egm::wrapper::Header_MessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.message_type)
}

// optional .abb.egm.wrapper.Header.RWVersion rw_version = 4 [default = RW_UNKNOWN];
inline bool Header::_internal_has_rw_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Header::has_rw_version() const {
  return _internal_has_rw_version();
}
inline void Header::clear_rw_version() {
  rw_version_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::abb::egm::wrapper::Header_RWVersion Header::_internal_rw_version() const {
  return static_cast< ::abb::egm::wrapper::Header_RWVersion >(rw_version_);
}
inline ::abb::egm::wrapper::Header_RWVersion Header::rw_version() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.rw_version)
  return _internal_rw_version();
}
inline void Header::_internal_set_rw_version(::abb::egm::wrapper::Header_RWVersion value) {
  assert(::abb::egm::wrapper::Header_RWVersion_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  rw_version_ = value;
}
inline void Header::set_rw_version(::abb::egm::wrapper::Header_RWVersion value) {
  _internal_set_rw_version(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.rw_version)
}

// optional .abb.egm.wrapper.Header.EGMVersion egm_version = 5 [default = EGM_UNKNOWN];
inline bool Header::_internal_has_egm_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Header::has_egm_version() const {
  return _internal_has_egm_version();
}
inline void Header::clear_egm_version() {
  egm_version_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::abb::egm::wrapper::Header_EGMVersion Header::_internal_egm_version() const {
  return static_cast< ::abb::egm::wrapper::Header_EGMVersion >(egm_version_);
}
inline ::abb::egm::wrapper::Header_EGMVersion Header::egm_version() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.egm_version)
  return _internal_egm_version();
}
inline void Header::_internal_set_egm_version(::abb::egm::wrapper::Header_EGMVersion value) {
  assert(::abb::egm::wrapper::Header_EGMVersion_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  egm_version_ = value;
}
inline void Header::set_egm_version(::abb::egm::wrapper::Header_EGMVersion value) {
  _internal_set_egm_version(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.egm_version)
}

// -------------------------------------------------------------------

// Status

// optional bool egm_convergence_met = 1;
inline bool Status::_internal_has_egm_convergence_met() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Status::has_egm_convergence_met() const {
  return _internal_has_egm_convergence_met();
}
inline void Status::clear_egm_convergence_met() {
  egm_convergence_met_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool Status::_internal_egm_convergence_met() const {
  return egm_convergence_met_;
}
inline bool Status::egm_convergence_met() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.egm_convergence_met)
  return _internal_egm_convergence_met();
}
inline void Status::_internal_set_egm_convergence_met(bool value) {
  _has_bits_[0] |= 0x00000001u;
  egm_convergence_met_ = value;
}
inline void Status::set_egm_convergence_met(bool value) {
  _internal_set_egm_convergence_met(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.egm_convergence_met)
}

// optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
inline bool Status::_internal_has_egm_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Status::has_egm_state() const {
  return _internal_has_egm_state();
}
inline void Status::clear_egm_state() {
  egm_state_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::abb::egm::wrapper::Status_EGMState Status::_internal_egm_state() const {
  return static_cast< ::abb::egm::wrapper::Status_EGMState >(egm_state_);
}
inline ::abb::egm::wrapper::Status_EGMState Status::egm_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.egm_state)
  return _internal_egm_state();
}
inline void Status::_internal_set_egm_state(::abb::egm::wrapper::Status_EGMState value) {
  assert(::abb::egm::wrapper::Status_EGMState_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  egm_state_ = value;
}
inline void Status::set_egm_state(::abb::egm::wrapper::Status_EGMState value) {
  _internal_set_egm_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.egm_state)
}

// optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
inline bool Status::_internal_has_motor_state() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Status::has_motor_state() const {
  return _internal_has_motor_state();
}
inline void Status::clear_motor_state() {
  motor_state_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::abb::egm::wrapper::Status_MotorState Status::_internal_motor_state() const {
  return static_cast< ::abb::egm::wrapper::Status_MotorState >(motor_state_);
}
inline ::abb::egm::wrapper::Status_MotorState Status::motor_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.motor_state)
  return _internal_motor_state();
}
inline void Status::_internal_set_motor_state(::abb::egm::wrapper::Status_MotorState value) {
  assert(::abb::egm::wrapper::Status_MotorState_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  motor_state_ = value;
}
inline void Status::set_motor_state(::abb::egm::wrapper::Status_MotorState value) {
  _internal_set_motor_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.motor_state)
}

// optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
inline bool Status::_internal_has_rapid_execution_state() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Status::has_rapid_execution_state() const {
  return _internal_has_rapid_execution_state();
}
inline void Status::clear_rapid_execution_state() {
  rapid_execution_state_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::abb::egm::wrapper::Status_RAPIDExecutionState Status::_internal_rapid_execution_state() const {
  return static_cast< ::abb::egm::wrapper::Status_RAPIDExecutionState >(rapid_execution_state_);
}
inline ::abb::egm::wrapper::Status_RAPIDExecutionState Status::rapid_execution_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.rapid_execution_state)
  return _internal_rapid_execution_state();
}
inline void Status::_internal_set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value) {
  assert(::abb::egm::wrapper::Status_RAPIDExecutionState_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  rapid_execution_state_ = value;
}
inline void Status::set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value) {
  _internal_set_rapid_execution_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.rapid_execution_state)
}

// optional double utilization_rate = 5;
inline bool Status::_internal_has_utilization_rate() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Status::has_utilization_rate() const {
  return _internal_has_utilization_rate();
}
inline void Status::clear_utilization_rate() {
  utilization_rate_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double Status::_internal_utilization_rate() const {
  return utilization_rate_;
}
inline double Status::utilization_rate() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.utilization_rate)
  return _internal_utilization_rate();
}
inline void Status::_internal_set_utilization_rate(double value) {
  _has_bits_[0] |= 0x00000010u;
  utilization_rate_ = value;
}
inline void Status::set_utilization_rate(double value) {
  _internal_set_utilization_rate(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.utilization_rate)
}

// -------------------------------------------------------------------

// Clock

// optional uint64 sec = 1;
inline bool Clock::_internal_has_sec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Clock::has_sec() const {
  return _internal_has_sec();
}
inline void Clock::clear_sec() {
  sec_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Clock::_internal_sec() const {
  return sec_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Clock::sec() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Clock.sec)
  return _internal_sec();
}
inline void Clock::_internal_set_sec(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  sec_ = value;
}
inline void Clock::set_sec(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sec(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Clock.sec)
}

// optional uint64 usec = 2;
inline bool Clock::_internal_has_usec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Clock::has_usec() const {
  return _internal_has_usec();
}
inline void Clock::clear_usec() {
  usec_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Clock::_internal_usec() const {
  return usec_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Clock::usec() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Clock.usec)
  return _internal_usec();
}
inline void Clock::_internal_set_usec(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  usec_ = value;
}
inline void Clock::set_usec(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_usec(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Clock.usec)
}

// -------------------------------------------------------------------

// Joints

// repeated double values = 1;
inline int Joints::_internal_values_size() const {
  return values_.size();
}
inline int Joints::values_size() const {
  return _internal_values_size();
}
inline void Joints::clear_values() {
  values_.Clear();
}
inline double Joints::_internal_values(int index) const {
  return values_.Get(index);
}
inline double Joints::values(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Joints.values)
  return _internal_values(index);
}
inline void Joints::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Joints.values)
}
inline void Joints::_internal_add_values(double value) {
  values_.Add(value);
}
inline void Joints::add_values(double value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:abb.egm.wrapper.Joints.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Joints::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Joints::values() const {
  // @@protoc_insertion_point(field_list:abb.egm.wrapper.Joints.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Joints::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Joints::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.wrapper.Joints.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// JointSpace

// optional .abb.egm.wrapper.Joints position = 1;
inline bool JointSpace::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || position_ != nullptr);
  return value;
}
inline bool JointSpace::has_position() const {
  return _internal_has_position();
}
inline void JointSpace::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Joints& JointSpace::_internal_position() const {
  const ::abb::egm::wrapper::Joints* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Joints&>(
      ::abb::egm::wrapper::_Joints_default_instance_);
}
inline const ::abb::egm::wrapper::Joints& JointSpace::position() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.JointSpace.position)
  return _internal_position();
}
inline void JointSpace::unsafe_arena_set_allocated_position(
    ::abb::egm::wrapper::Joints* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.JointSpace.position)
}
inline ::abb::egm::wrapper::Joints* JointSpace::release_position() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Joints* temp = position_;
  position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointSpace::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.JointSpace.position)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Joints* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointSpace::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000001u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::abb::egm::wrapper::Joints* JointSpace::mutable_position() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.JointSpace.position)
  return _internal_mutable_position();
}
inline void JointSpace::set_allocated_position(::abb::egm::wrapper::Joints* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.JointSpace.position)
}

// optional .abb.egm.wrapper.Joints velocity = 2;
inline bool JointSpace::_internal_has_velocity() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || velocity_ != nullptr);
  return value;
}
inline bool JointSpace::has_velocity() const {
  return _internal_has_velocity();
}
inline void JointSpace::clear_velocity() {
  if (velocity_ != nullptr) velocity_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::Joints& JointSpace::_internal_velocity() const {
  const ::abb::egm::wrapper::Joints* p = velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Joints&>(
      ::abb::egm::wrapper::_Joints_default_instance_);
}
inline const ::abb::egm::wrapper::Joints& JointSpace::velocity() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.JointSpace.velocity)
  return _internal_velocity();
}
inline void JointSpace::unsafe_arena_set_allocated_velocity(
    ::abb::egm::wrapper::Joints* velocity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  velocity_ = velocity;
  if (velocity) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.JointSpace.velocity)
}
inline ::abb::egm::wrapper::Joints* JointSpace::release_velocity() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Joints* temp = velocity_;
  velocity_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointSpace::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.JointSpace.velocity)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Joints* temp = velocity_;
  velocity_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Joints* JointSpace::_internal_mutable_velocity() {
  _has_bits_[0] |= 0x00000002u;
  if (velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Joints>(GetArena());
    velocity_ = p;
  }
  return velocity_;
}
inline ::abb::egm::wrapper::Joints* JointSpace::mutable_velocity() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.JointSpace.velocity)
  return _internal_mutable_velocity();
}
inline void JointSpace::set_allocated_velocity(::abb::egm::wrapper::Joints* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.JointSpace.velocity)
}

// -------------------------------------------------------------------

// Cartesian

// optional double x = 1;
inline bool Cartesian::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Cartesian::has_x() const {
  return _internal_has_x();
}
inline void Cartesian::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Cartesian::_internal_x() const {
  return x_;
}
inline double Cartesian::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.x)
  return _internal_x();
}
inline void Cartesian::_internal_set_x(double value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Cartesian::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.x)
}

// optional double y = 2;
inline bool Cartesian::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Cartesian::has_y() const {
  return _internal_has_y();
}
inline void Cartesian::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Cartesian::_internal_y() const {
  return y_;
}
inline double Cartesian::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.y)
  return _internal_y();
}
inline void Cartesian::_internal_set_y(double value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Cartesian::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.y)
}

// optional double z = 3;
inline bool Cartesian::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Cartesian::has_z() const {
  return _internal_has_z();
}
inline void Cartesian::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Cartesian::_internal_z() const {
  return z_;
}
inline double Cartesian::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.z)
  return _internal_z();
}
inline void Cartesian::_internal_set_z(double value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void Cartesian::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.z)
}

// -------------------------------------------------------------------

// Euler

// optional double x = 1;
inline bool Euler::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Euler::has_x() const {
  return _internal_has_x();
}
inline void Euler::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Euler::_internal_x() const {
  return x_;
}
inline double Euler::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.x)
  return _internal_x();
}
inline void Euler::_internal_set_x(double value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Euler::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.x)
}

// optional double y = 2;
inline bool Euler::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Euler::has_y() const {
  return _internal_has_y();
}
inline void Euler::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Euler::_internal_y() const {
  return y_;
}
inline double Euler::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.y)
  return _internal_y();
}
inline void Euler::_internal_set_y(double value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Euler::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.y)
}

// optional double z = 3;
inline bool Euler::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Euler::has_z() const {
  return _internal_has_z();
}
inline void Euler::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Euler::_internal_z() const {
  return z_;
}
inline double Euler::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.z)
  return _internal_z();
}
inline void Euler::_internal_set_z(double value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void Euler::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.z)
}

// -------------------------------------------------------------------

// Quaternion

// optional double u0 = 1;
inline bool Quaternion::_internal_has_u0() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Quaternion::has_u0() const {
  return _internal_has_u0();
}
inline void Quaternion::clear_u0() {
  u0_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Quaternion::_internal_u0() const {
  return u0_;
}
inline double Quaternion::u0() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u0)
  return _internal_u0();
}
inline void Quaternion::_internal_set_u0(double value) {
  _has_bits_[0] |= 0x00000001u;
  u0_ = value;
}
inline void Quaternion::set_u0(double value) {
  _internal_set_u0(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u0)
}

// optional double u1 = 2;
inline bool Quaternion::_internal_has_u1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Quaternion::has_u1() const {
  return _internal_has_u1();
}
inline void Quaternion::clear_u1() {
  u1_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Quaternion::_internal_u1() const {
  return u1_;
}
inline double Quaternion::u1() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u1)
  return _internal_u1();
}
inline void Quaternion::_internal_set_u1(double value) {
  _has_bits_[0] |= 0x00000002u;
  u1_ = value;
}
inline void Quaternion::set_u1(double value) {
  _internal_set_u1(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u1)
}

// optional double u2 = 3;
inline bool Quaternion::_internal_has_u2() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Quaternion::has_u2() const {
  return _internal_has_u2();
}
inline void Quaternion::clear_u2() {
  u2_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Quaternion::_internal_u2() const {
  return u2_;
}
inline double Quaternion::u2() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u2)
  return _internal_u2();
}
inline void Quaternion::_internal_set_u2(double value) {
  _has_bits_[0] |= 0x00000004u;
  u2_ = value;
}
inline void Quaternion::set_u2(double value) {
  _internal_set_u2(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u2)
}

// optional double u3 = 4;
inline bool Quaternion::_internal_has_u3() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Quaternion::has_u3() const {
  return _internal_has_u3();
}
inline void Quaternion::clear_u3() {
  u3_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double Quaternion::_internal_u3() const {
  return u3_;
}
inline double Quaternion::u3() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u3)
  return _internal_u3();
}
inline void Quaternion::_internal_set_u3(double value) {
  _has_bits_[0] |= 0x00000008u;
  u3_ = value;
}
inline void Quaternion::set_u3(double value) {
  _internal_set_u3(value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u3)
}

// -------------------------------------------------------------------

// CartesianPose

// optional .abb.egm.wrapper.Cartesian position = 1;
inline bool CartesianPose::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || position_ != nullptr);
  return value;
}
inline bool CartesianPose::has_position() const {
  return _internal_has_position();
}
inline void CartesianPose::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Cartesian& CartesianPose::_internal_position() const {
  const ::abb::egm::wrapper::Cartesian* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Cartesian&>(
      ::abb::egm::wrapper::_Cartesian_default_instance_);
}
inline const ::abb::egm::wrapper::Cartesian& CartesianPose::position() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.position)
  return _internal_position();
}
inline void CartesianPose::unsafe_arena_set_allocated_position(
    ::abb::egm::wrapper::Cartesian* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianPose.position)
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::release_position() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Cartesian* temp = position_;
  position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianPose.position)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Cartesian* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000001u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Cartesian>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::mutable_position() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.position)
  return _internal_mutable_position();
}
inline void CartesianPose::set_allocated_position(::abb::egm::wrapper::Cartesian* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.position)
}

// optional .abb.egm.wrapper.Euler euler = 2;
inline bool CartesianPose::_internal_has_euler() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || euler_ != nullptr);
  return value;
}
inline bool CartesianPose::has_euler() const {
  return _internal_has_euler();
}
inline void CartesianPose::clear_euler() {
  if (euler_ != nullptr) euler_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::Euler& CartesianPose::_internal_euler() const {
  const ::abb::egm::wrapper::Euler* p = euler_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Euler&>(
      ::abb::egm::wrapper::_Euler_default_instance_);
}
inline const ::abb::egm::wrapper::Euler& CartesianPose::euler() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.euler)
  return _internal_euler();
}
inline void CartesianPose::unsafe_arena_set_allocated_euler(
    ::abb::egm::wrapper::Euler* euler) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(euler_);
  }
  euler_ = euler;
  if (euler) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianPose.euler)
}
inline ::abb::egm::wrapper::Euler* CartesianPose::release_euler() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Euler* temp = euler_;
  euler_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Euler* CartesianPose::unsafe_arena_release_euler() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianPose.euler)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Euler* temp = euler_;
  euler_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Euler* CartesianPose::_internal_mutable_euler() {
  _has_bits_[0] |= 0x00000002u;
  if (euler_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Euler>(GetArena());
    euler_ = p;
  }
  return euler_;
}
inline ::abb::egm::wrapper::Euler* CartesianPose::mutable_euler() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.euler)
  return _internal_mutable_euler();
}
inline void CartesianPose::set_allocated_euler(::abb::egm::wrapper::Euler* euler) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete euler_;
  }
  if (euler) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(euler);
    if (message_arena != submessage_arena) {
      euler = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, euler, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  euler_ = euler;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.euler)
}

// optional .abb.egm.wrapper.Quaternion quaternion = 3;
inline bool CartesianPose::_internal_has_quaternion() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || quaternion_ != nullptr);
  return value;
}
inline bool CartesianPose::has_quaternion() const {
  return _internal_has_quaternion();
}
inline void CartesianPose::clear_quaternion() {
  if (quaternion_ != nullptr) quaternion_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::wrapper::Quaternion& CartesianPose::_internal_quaternion() const {
  const ::abb::egm::wrapper::Quaternion* p = quaternion_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Quaternion&>(
      ::abb::egm::wrapper::_Quaternion_default_instance_);
}
inline const ::abb::egm::wrapper::Quaternion& CartesianPose::quaternion() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.quaternion)
  return _internal_quaternion();
}
inline void CartesianPose::unsafe_arena_set_allocated_quaternion(
    ::abb::egm::wrapper::Quaternion* quaternion) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(quaternion_);
  }
  quaternion_ = quaternion;
  if (quaternion) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianPose.quaternion)
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::release_quaternion() {
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Quaternion* temp = quaternion_;
  quaternion_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::unsafe_arena_release_quaternion() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianPose.quaternion)
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Quaternion* temp = quaternion_;
  quaternion_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::_internal_mutable_quaternion() {
  _has_bits_[0] |= 0x00000004u;
  if (quaternion_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Quaternion>(GetArena());
    quaternion_ = p;
  }
  return quaternion_;
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::mutable_quaternion() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.quaternion)
  return _internal_mutable_quaternion();
}
inline void CartesianPose::set_allocated_quaternion(::abb::egm::wrapper::Quaternion* quaternion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete quaternion_;
  }
  if (quaternion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(quaternion);
    if (message_arena != submessage_arena) {
      quaternion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quaternion, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  quaternion_ = quaternion;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.quaternion)
}

// -------------------------------------------------------------------

// CartesianVelocity

// optional .abb.egm.wrapper.Cartesian linear = 1;
inline bool CartesianVelocity::_internal_has_linear() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || linear_ != nullptr);
  return value;
}
inline bool CartesianVelocity::has_linear() const {
  return _internal_has_linear();
}
inline void CartesianVelocity::clear_linear() {
  if (linear_ != nullptr) linear_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Cartesian& CartesianVelocity::_internal_linear() const {
  const ::abb::egm::wrapper::Cartesian* p = linear_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Cartesian&>(
      ::abb::egm::wrapper::_Cartesian_default_instance_);
}
inline const ::abb::egm::wrapper::Cartesian& CartesianVelocity::linear() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianVelocity.linear)
  return _internal_linear();
}
inline void CartesianVelocity::unsafe_arena_set_allocated_linear(
    ::abb::egm::wrapper::Cartesian* linear) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linear_);
  }
  linear_ = linear;
  if (linear) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianVelocity.linear)
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::release_linear() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Cartesian* temp = linear_;
  linear_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianVelocity.linear)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Cartesian* temp = linear_;
  linear_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::_internal_mutable_linear() {
  _has_bits_[0] |= 0x00000001u;
  if (linear_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Cartesian>(GetArena());
    linear_ = p;
  }
  return linear_;
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::mutable_linear() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianVelocity.linear)
  return _internal_mutable_linear();
}
inline void CartesianVelocity::set_allocated_linear(::abb::egm::wrapper::Cartesian* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete linear_;
  }
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  linear_ = linear;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianVelocity.linear)
}

// optional .abb.egm.wrapper.Euler angular = 2;
inline bool CartesianVelocity::_internal_has_angular() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || angular_ != nullptr);
  return value;
}
inline bool CartesianVelocity::has_angular() const {
  return _internal_has_angular();
}
inline void CartesianVelocity::clear_angular() {
  if (angular_ != nullptr) angular_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::Euler& CartesianVelocity::_internal_angular() const {
  const ::abb::egm::wrapper::Euler* p = angular_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Euler&>(
      ::abb::egm::wrapper::_Euler_default_instance_);
}
inline const ::abb::egm::wrapper::Euler& CartesianVelocity::angular() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianVelocity.angular)
  return _internal_angular();
}
inline void CartesianVelocity::unsafe_arena_set_allocated_angular(
    ::abb::egm::wrapper::Euler* angular) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angular_);
  }
  angular_ = angular;
  if (angular) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianVelocity.angular)
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::release_angular() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Euler* temp = angular_;
  angular_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::unsafe_arena_release_angular() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianVelocity.angular)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Euler* temp = angular_;
  angular_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::_internal_mutable_angular() {
  _has_bits_[0] |= 0x00000002u;
  if (angular_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Euler>(GetArena());
    angular_ = p;
  }
  return angular_;
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::mutable_angular() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianVelocity.angular)
  return _internal_mutable_angular();
}
inline void CartesianVelocity::set_allocated_angular(::abb::egm::wrapper::Euler* angular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete angular_;
  }
  if (angular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(angular);
    if (message_arena != submessage_arena) {
      angular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  angular_ = angular;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianVelocity.angular)
}

// -------------------------------------------------------------------

// CartesianSpace

// optional .abb.egm.wrapper.CartesianPose pose = 1;
inline bool CartesianSpace::_internal_has_pose() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || pose_ != nullptr);
  return value;
}
inline bool CartesianSpace::has_pose() const {
  return _internal_has_pose();
}
inline void CartesianSpace::clear_pose() {
  if (pose_ != nullptr) pose_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::CartesianPose& CartesianSpace::_internal_pose() const {
  const ::abb::egm::wrapper::CartesianPose* p = pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::CartesianPose&>(
      ::abb::egm::wrapper::_CartesianPose_default_instance_);
}
inline const ::abb::egm::wrapper::CartesianPose& CartesianSpace::pose() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianSpace.pose)
  return _internal_pose();
}
inline void CartesianSpace::unsafe_arena_set_allocated_pose(
    ::abb::egm::wrapper::CartesianPose* pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianSpace.pose)
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::release_pose() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::CartesianPose* temp = pose_;
  pose_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianSpace.pose)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::CartesianPose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::_internal_mutable_pose() {
  _has_bits_[0] |= 0x00000001u;
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianPose>(GetArena());
    pose_ = p;
  }
  return pose_;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianSpace.pose)
  return _internal_mutable_pose();
}
inline void CartesianSpace::set_allocated_pose(::abb::egm::wrapper::CartesianPose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianSpace.pose)
}

// optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
inline bool CartesianSpace::_internal_has_velocity() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || velocity_ != nullptr);
  return value;
}
inline bool CartesianSpace::has_velocity() const {
  return _internal_has_velocity();
}
inline void CartesianSpace::clear_velocity() {
  if (velocity_ != nullptr) velocity_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::CartesianVelocity& CartesianSpace::_internal_velocity() const {
  const ::abb::egm::wrapper::CartesianVelocity* p = velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::CartesianVelocity&>(
      ::abb::egm::wrapper::_CartesianVelocity_default_instance_);
}
inline const ::abb::egm::wrapper::CartesianVelocity& CartesianSpace::velocity() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianSpace.velocity)
  return _internal_velocity();
}
inline void CartesianSpace::unsafe_arena_set_allocated_velocity(
    ::abb::egm::wrapper::CartesianVelocity* velocity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  velocity_ = velocity;
  if (velocity) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.CartesianSpace.velocity)
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::release_velocity() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianVelocity* temp = velocity_;
  velocity_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.CartesianSpace.velocity)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianVelocity* temp = velocity_;
  velocity_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::_internal_mutable_velocity() {
  _has_bits_[0] |= 0x00000002u;
  if (velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianVelocity>(GetArena());
    velocity_ = p;
  }
  return velocity_;
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::mutable_velocity() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianSpace.velocity)
  return _internal_mutable_velocity();
}
inline void CartesianSpace::set_allocated_velocity(::abb::egm::wrapper::CartesianVelocity* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianSpace.velocity)
}

// -------------------------------------------------------------------

// Robot

// optional .abb.egm.wrapper.JointSpace joints = 1;
inline bool Robot::_internal_has_joints() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || joints_ != nullptr);
  return value;
}
inline bool Robot::has_joints() const {
  return _internal_has_joints();
}
inline void Robot::clear_joints() {
  if (joints_ != nullptr) joints_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::JointSpace& Robot::_internal_joints() const {
  const ::abb::egm::wrapper::JointSpace* p = joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::JointSpace&>(
      ::abb::egm::wrapper::_JointSpace_default_instance_);
}
inline const ::abb::egm::wrapper::JointSpace& Robot::joints() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Robot.joints)
  return _internal_joints();
}
inline void Robot::unsafe_arena_set_allocated_joints(
    ::abb::egm::wrapper::JointSpace* joints) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(joints_);
  }
  joints_ = joints;
  if (joints) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Robot.joints)
}
inline ::abb::egm::wrapper::JointSpace* Robot::release_joints() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::JointSpace* temp = joints_;
  joints_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::JointSpace* Robot::unsafe_arena_release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Robot.joints)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::JointSpace* temp = joints_;
  joints_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::JointSpace* Robot::_internal_mutable_joints() {
  _has_bits_[0] |= 0x00000001u;
  if (joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::JointSpace>(GetArena());
    joints_ = p;
  }
  return joints_;
}
inline ::abb::egm::wrapper::JointSpace* Robot::mutable_joints() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Robot.joints)
  return _internal_mutable_joints();
}
inline void Robot::set_allocated_joints(::abb::egm::wrapper::JointSpace* joints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete joints_;
  }
  if (joints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(joints);
    if (message_arena != submessage_arena) {
      joints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joints, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  joints_ = joints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Robot.joints)
}

// optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
inline bool Robot::_internal_has_cartesian() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || cartesian_ != nullptr);
  return value;
}
inline bool Robot::has_cartesian() const {
  return _internal_has_cartesian();
}
inline void Robot::clear_cartesian() {
  if (cartesian_ != nullptr) cartesian_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::CartesianSpace& Robot::_internal_cartesian() const {
  const ::abb::egm::wrapper::CartesianSpace* p = cartesian_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::CartesianSpace&>(
      ::abb::egm::wrapper::_CartesianSpace_default_instance_);
}
inline const ::abb::egm::wrapper::CartesianSpace& Robot::cartesian() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Robot.cartesian)
  return _internal_cartesian();
}
inline void Robot::unsafe_arena_set_allocated_cartesian(
    ::abb::egm::wrapper::CartesianSpace* cartesian) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cartesian_);
  }
  cartesian_ = cartesian;
  if (cartesian) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Robot.cartesian)
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::release_cartesian() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianSpace* temp = cartesian_;
  cartesian_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::unsafe_arena_release_cartesian() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Robot.cartesian)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::CartesianSpace* temp = cartesian_;
  cartesian_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::_internal_mutable_cartesian() {
  _has_bits_[0] |= 0x00000002u;
  if (cartesian_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::CartesianSpace>(GetArena());
    cartesian_ = p;
  }
  return cartesian_;
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::mutable_cartesian() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Robot.cartesian)
  return _internal_mutable_cartesian();
}
inline void Robot::set_allocated_cartesian(::abb::egm::wrapper::CartesianSpace* cartesian) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cartesian_;
  }
  if (cartesian) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cartesian);
    if (message_arena != submessage_arena) {
      cartesian = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cartesian, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cartesian_ = cartesian;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Robot.cartesian)
}

// -------------------------------------------------------------------

// External

// optional .abb.egm.wrapper.JointSpace joints = 1;
inline bool External::_internal_has_joints() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || joints_ != nullptr);
  return value;
}
inline bool External::has_joints() const {
  return _internal_has_joints();
}
inline void External::clear_joints() {
  if (joints_ != nullptr) joints_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::JointSpace& External::_internal_joints() const {
  const ::abb::egm::wrapper::JointSpace* p = joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::JointSpace&>(
      ::abb::egm::wrapper::_JointSpace_default_instance_);
}
inline const ::abb::egm::wrapper::JointSpace& External::joints() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.External.joints)
  return _internal_joints();
}
inline void External::unsafe_arena_set_allocated_joints(
    ::abb::egm::wrapper::JointSpace* joints) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(joints_);
  }
  joints_ = joints;
  if (joints) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.External.joints)
}
inline ::abb::egm::wrapper::JointSpace* External::release_joints() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::JointSpace* temp = joints_;
  joints_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::JointSpace* External::unsafe_arena_release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.External.joints)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::JointSpace* temp = joints_;
  joints_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::JointSpace* External::_internal_mutable_joints() {
  _has_bits_[0] |= 0x00000001u;
  if (joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::JointSpace>(GetArena());
    joints_ = p;
  }
  return joints_;
}
inline ::abb::egm::wrapper::JointSpace* External::mutable_joints() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.External.joints)
  return _internal_mutable_joints();
}
inline void External::set_allocated_joints(::abb::egm::wrapper::JointSpace* joints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete joints_;
  }
  if (joints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(joints);
    if (message_arena != submessage_arena) {
      joints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joints, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  joints_ = joints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.External.joints)
}

// -------------------------------------------------------------------

// Feedback

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Feedback::_internal_has_robot() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || robot_ != nullptr);
  return value;
}
inline bool Feedback::has_robot() const {
  return _internal_has_robot();
}
inline void Feedback::clear_robot() {
  if (robot_ != nullptr) robot_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Robot& Feedback::_internal_robot() const {
  const ::abb::egm::wrapper::Robot* p = robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Robot&>(
      ::abb::egm::wrapper::_Robot_default_instance_);
}
inline const ::abb::egm::wrapper::Robot& Feedback::robot() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.robot)
  return _internal_robot();
}
inline void Feedback::unsafe_arena_set_allocated_robot(
    ::abb::egm::wrapper::Robot* robot) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_);
  }
  robot_ = robot;
  if (robot) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Feedback.robot)
}
inline ::abb::egm::wrapper::Robot* Feedback::release_robot() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = robot_;
  robot_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Robot* Feedback::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Feedback.robot)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = robot_;
  robot_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Robot* Feedback::_internal_mutable_robot() {
  _has_bits_[0] |= 0x00000001u;
  if (robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Robot>(GetArena());
    robot_ = p;
  }
  return robot_;
}
inline ::abb::egm::wrapper::Robot* Feedback::mutable_robot() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.robot)
  return _internal_mutable_robot();
}
inline void Feedback::set_allocated_robot(::abb::egm::wrapper::Robot* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Feedback::_internal_has_external() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || external_ != nullptr);
  return value;
}
inline bool Feedback::has_external() const {
  return _internal_has_external();
}
inline void Feedback::clear_external() {
  if (external_ != nullptr) external_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::External& Feedback::_internal_external() const {
  const ::abb::egm::wrapper::External* p = external_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::External&>(
      ::abb::egm::wrapper::_External_default_instance_);
}
inline const ::abb::egm::wrapper::External& Feedback::external() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.external)
  return _internal_external();
}
inline void Feedback::unsafe_arena_set_allocated_external(
    ::abb::egm::wrapper::External* external) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(external_);
  }
  external_ = external;
  if (external) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Feedback.external)
}
inline ::abb::egm::wrapper::External* Feedback::release_external() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = external_;
  external_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::External* Feedback::unsafe_arena_release_external() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Feedback.external)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = external_;
  external_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::External* Feedback::_internal_mutable_external() {
  _has_bits_[0] |= 0x00000002u;
  if (external_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::External>(GetArena());
    external_ = p;
  }
  return external_;
}
inline ::abb::egm::wrapper::External* Feedback::mutable_external() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.external)
  return _internal_mutable_external();
}
inline void Feedback::set_allocated_external(::abb::egm::wrapper::External* external) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete external_;
  }
  if (external) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(external);
    if (message_arena != submessage_arena) {
      external = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  external_ = external;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.external)
}

// optional .abb.egm.wrapper.Clock time = 3;
inline bool Feedback::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || time_ != nullptr);
  return value;
}
inline bool Feedback::has_time() const {
  return _internal_has_time();
}
inline void Feedback::clear_time() {
  if (time_ != nullptr) time_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::wrapper::Clock& Feedback::_internal_time() const {
  const ::abb::egm::wrapper::Clock* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Clock&>(
      ::abb::egm::wrapper::_Clock_default_instance_);
}
inline const ::abb::egm::wrapper::Clock& Feedback::time() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.time)
  return _internal_time();
}
inline void Feedback::unsafe_arena_set_allocated_time(
    ::abb::egm::wrapper::Clock* time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Feedback.time)
}
inline ::abb::egm::wrapper::Clock* Feedback::release_time() {
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Clock* temp = time_;
  time_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Clock* Feedback::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Feedback.time)
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Clock* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Clock* Feedback::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000004u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Clock>(GetArena());
    time_ = p;
  }
  return time_;
}
inline ::abb::egm::wrapper::Clock* Feedback::mutable_time() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.time)
  return _internal_mutable_time();
}
inline void Feedback::set_allocated_time(::abb::egm::wrapper::Clock* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete time_;
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(time);
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.time)
}

// -------------------------------------------------------------------

// Planned

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Planned::_internal_has_robot() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || robot_ != nullptr);
  return value;
}
inline bool Planned::has_robot() const {
  return _internal_has_robot();
}
inline void Planned::clear_robot() {
  if (robot_ != nullptr) robot_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Robot& Planned::_internal_robot() const {
  const ::abb::egm::wrapper::Robot* p = robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Robot&>(
      ::abb::egm::wrapper::_Robot_default_instance_);
}
inline const ::abb::egm::wrapper::Robot& Planned::robot() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.robot)
  return _internal_robot();
}
inline void Planned::unsafe_arena_set_allocated_robot(
    ::abb::egm::wrapper::Robot* robot) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_);
  }
  robot_ = robot;
  if (robot) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Planned.robot)
}
inline ::abb::egm::wrapper::Robot* Planned::release_robot() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = robot_;
  robot_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Robot* Planned::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Planned.robot)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = robot_;
  robot_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Robot* Planned::_internal_mutable_robot() {
  _has_bits_[0] |= 0x00000001u;
  if (robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Robot>(GetArena());
    robot_ = p;
  }
  return robot_;
}
inline ::abb::egm::wrapper::Robot* Planned::mutable_robot() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.robot)
  return _internal_mutable_robot();
}
inline void Planned::set_allocated_robot(::abb::egm::wrapper::Robot* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Planned::_internal_has_external() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || external_ != nullptr);
  return value;
}
inline bool Planned::has_external() const {
  return _internal_has_external();
}
inline void Planned::clear_external() {
  if (external_ != nullptr) external_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::External& Planned::_internal_external() const {
  const ::abb::egm::wrapper::External* p = external_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::External&>(
      ::abb::egm::wrapper::_External_default_instance_);
}
inline const ::abb::egm::wrapper::External& Planned::external() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.external)
  return _internal_external();
}
inline void Planned::unsafe_arena_set_allocated_external(
    ::abb::egm::wrapper::External* external) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(external_);
  }
  external_ = external;
  if (external) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Planned.external)
}
inline ::abb::egm::wrapper::External* Planned::release_external() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = external_;
  external_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::External* Planned::unsafe_arena_release_external() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Planned.external)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = external_;
  external_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::External* Planned::_internal_mutable_external() {
  _has_bits_[0] |= 0x00000002u;
  if (external_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::External>(GetArena());
    external_ = p;
  }
  return external_;
}
inline ::abb::egm::wrapper::External* Planned::mutable_external() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.external)
  return _internal_mutable_external();
}
inline void Planned::set_allocated_external(::abb::egm::wrapper::External* external) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete external_;
  }
  if (external) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(external);
    if (message_arena != submessage_arena) {
      external = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  external_ = external;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.external)
}

// optional .abb.egm.wrapper.Clock time = 3;
inline bool Planned::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || time_ != nullptr);
  return value;
}
inline bool Planned::has_time() const {
  return _internal_has_time();
}
inline void Planned::clear_time() {
  if (time_ != nullptr) time_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::wrapper::Clock& Planned::_internal_time() const {
  const ::abb::egm::wrapper::Clock* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Clock&>(
      ::abb::egm::wrapper::_Clock_default_instance_);
}
inline const ::abb::egm::wrapper::Clock& Planned::time() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.time)
  return _internal_time();
}
inline void Planned::unsafe_arena_set_allocated_time(
    ::abb::egm::wrapper::Clock* time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Planned.time)
}
inline ::abb::egm::wrapper::Clock* Planned::release_time() {
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Clock* temp = time_;
  time_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Clock* Planned::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Planned.time)
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Clock* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Clock* Planned::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000004u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Clock>(GetArena());
    time_ = p;
  }
  return time_;
}
inline ::abb::egm::wrapper::Clock* Planned::mutable_time() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.time)
  return _internal_mutable_time();
}
inline void Planned::set_allocated_time(::abb::egm::wrapper::Clock* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete time_;
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(time);
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.time)
}

// -------------------------------------------------------------------

// Input

// optional .abb.egm.wrapper.Header header = 1;
inline bool Input::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool Input::has_header() const {
  return _internal_has_header();
}
inline void Input::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Header& Input::_internal_header() const {
  const ::abb::egm::wrapper::Header* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Header&>(
      ::abb::egm::wrapper::_Header_default_instance_);
}
inline const ::abb::egm::wrapper::Header& Input::header() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.header)
  return _internal_header();
}
inline void Input::unsafe_arena_set_allocated_header(
    ::abb::egm::wrapper::Header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Input.header)
}
inline ::abb::egm::wrapper::Header* Input::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Header* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Header* Input::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.header)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Header* Input::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::abb::egm::wrapper::Header* Input::mutable_header() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.header)
  return _internal_mutable_header();
}
inline void Input::set_allocated_header(::abb::egm::wrapper::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.header)
}

// optional .abb.egm.wrapper.Feedback feedback = 2;
inline bool Input::_internal_has_feedback() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || feedback_ != nullptr);
  return value;
}
inline bool Input::has_feedback() const {
  return _internal_has_feedback();
}
inline void Input::clear_feedback() {
  if (feedback_ != nullptr) feedback_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::Feedback& Input::_internal_feedback() const {
  const ::abb::egm::wrapper::Feedback* p = feedback_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Feedback&>(
      ::abb::egm::wrapper::_Feedback_default_instance_);
}
inline const ::abb::egm::wrapper::Feedback& Input::feedback() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.feedback)
  return _internal_feedback();
}
inline void Input::unsafe_arena_set_allocated_feedback(
    ::abb::egm::wrapper::Feedback* feedback) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(feedback_);
  }
  feedback_ = feedback;
  if (feedback) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Input.feedback)
}
inline ::abb::egm::wrapper::Feedback* Input::release_feedback() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Feedback* temp = feedback_;
  feedback_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Feedback* Input::unsafe_arena_release_feedback() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.feedback)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::Feedback* temp = feedback_;
  feedback_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Feedback* Input::_internal_mutable_feedback() {
  _has_bits_[0] |= 0x00000002u;
  if (feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Feedback>(GetArena());
    feedback_ = p;
  }
  return feedback_;
}
inline ::abb::egm::wrapper::Feedback* Input::mutable_feedback() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.feedback)
  return _internal_mutable_feedback();
}
inline void Input::set_allocated_feedback(::abb::egm::wrapper::Feedback* feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete feedback_;
  }
  if (feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(feedback);
    if (message_arena != submessage_arena) {
      feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feedback, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  feedback_ = feedback;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.feedback)
}

// optional .abb.egm.wrapper.Planned planned = 3;
inline bool Input::_internal_has_planned() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || planned_ != nullptr);
  return value;
}
inline bool Input::has_planned() const {
  return _internal_has_planned();
}
inline void Input::clear_planned() {
  if (planned_ != nullptr) planned_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::wrapper::Planned& Input::_internal_planned() const {
  const ::abb::egm::wrapper::Planned* p = planned_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Planned&>(
      ::abb::egm::wrapper::_Planned_default_instance_);
}
inline const ::abb::egm::wrapper::Planned& Input::planned() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.planned)
  return _internal_planned();
}
inline void Input::unsafe_arena_set_allocated_planned(
    ::abb::egm::wrapper::Planned* planned) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(planned_);
  }
  planned_ = planned;
  if (planned) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Input.planned)
}
inline ::abb::egm::wrapper::Planned* Input::release_planned() {
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Planned* temp = planned_;
  planned_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Planned* Input::unsafe_arena_release_planned() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.planned)
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::wrapper::Planned* temp = planned_;
  planned_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Planned* Input::_internal_mutable_planned() {
  _has_bits_[0] |= 0x00000004u;
  if (planned_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Planned>(GetArena());
    planned_ = p;
  }
  return planned_;
}
inline ::abb::egm::wrapper::Planned* Input::mutable_planned() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.planned)
  return _internal_mutable_planned();
}
inline void Input::set_allocated_planned(::abb::egm::wrapper::Planned* planned) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete planned_;
  }
  if (planned) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(planned);
    if (message_arena != submessage_arena) {
      planned = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, planned, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  planned_ = planned;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.planned)
}

// optional .abb.egm.wrapper.Status status = 4;
inline bool Input::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool Input::has_status() const {
  return _internal_has_status();
}
inline void Input::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::egm::wrapper::Status& Input::_internal_status() const {
  const ::abb::egm::wrapper::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Status&>(
      ::abb::egm::wrapper::_Status_default_instance_);
}
inline const ::abb::egm::wrapper::Status& Input::status() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.status)
  return _internal_status();
}
inline void Input::unsafe_arena_set_allocated_status(
    ::abb::egm::wrapper::Status* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Input.status)
}
inline ::abb::egm::wrapper::Status* Input::release_status() {
  _has_bits_[0] &= ~0x00000008u;
  ::abb::egm::wrapper::Status* temp = status_;
  status_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Status* Input::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Input.status)
  _has_bits_[0] &= ~0x00000008u;
  ::abb::egm::wrapper::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Status* Input::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000008u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Status>(GetArena());
    status_ = p;
  }
  return status_;
}
inline ::abb::egm::wrapper::Status* Input::mutable_status() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.status)
  return _internal_mutable_status();
}
inline void Input::set_allocated_status(::abb::egm::wrapper::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.status)
}

// -------------------------------------------------------------------

// Output

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Output::_internal_has_robot() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || robot_ != nullptr);
  return value;
}
inline bool Output::has_robot() const {
  return _internal_has_robot();
}
inline void Output::clear_robot() {
  if (robot_ != nullptr) robot_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::wrapper::Robot& Output::_internal_robot() const {
  const ::abb::egm::wrapper::Robot* p = robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::Robot&>(
      ::abb::egm::wrapper::_Robot_default_instance_);
}
inline const ::abb::egm::wrapper::Robot& Output::robot() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Output.robot)
  return _internal_robot();
}
inline void Output::unsafe_arena_set_allocated_robot(
    ::abb::egm::wrapper::Robot* robot) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_);
  }
  robot_ = robot;
  if (robot) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Output.robot)
}
inline ::abb::egm::wrapper::Robot* Output::release_robot() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = robot_;
  robot_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::Robot* Output::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Output.robot)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::wrapper::Robot* temp = robot_;
  robot_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::Robot* Output::_internal_mutable_robot() {
  _has_bits_[0] |= 0x00000001u;
  if (robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::Robot>(GetArena());
    robot_ = p;
  }
  return robot_;
}
inline ::abb::egm::wrapper::Robot* Output::mutable_robot() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Output.robot)
  return _internal_mutable_robot();
}
inline void Output::set_allocated_robot(::abb::egm::wrapper::Robot* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Output.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Output::_internal_has_external() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || external_ != nullptr);
  return value;
}
inline bool Output::has_external() const {
  return _internal_has_external();
}
inline void Output::clear_external() {
  if (external_ != nullptr) external_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::wrapper::External& Output::_internal_external() const {
  const ::abb::egm::wrapper::External* p = external_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::wrapper::External&>(
      ::abb::egm::wrapper::_External_default_instance_);
}
inline const ::abb::egm::wrapper::External& Output::external() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Output.external)
  return _internal_external();
}
inline void Output::unsafe_arena_set_allocated_external(
    ::abb::egm::wrapper::External* external) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(external_);
  }
  external_ = external;
  if (external) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.wrapper.Output.external)
}
inline ::abb::egm::wrapper::External* Output::release_external() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = external_;
  external_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::wrapper::External* Output::unsafe_arena_release_external() {
  // @@protoc_insertion_point(field_release:abb.egm.wrapper.Output.external)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::wrapper::External* temp = external_;
  external_ = nullptr;
  return temp;
}
inline ::abb::egm::wrapper::External* Output::_internal_mutable_external() {
  _has_bits_[0] |= 0x00000002u;
  if (external_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::wrapper::External>(GetArena());
    external_ = p;
  }
  return external_;
}
inline ::abb::egm::wrapper::External* Output::mutable_external() {
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Output.external)
  return _internal_mutable_external();
}
inline void Output::set_allocated_external(::abb::egm::wrapper::External* external) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete external_;
  }
  if (external) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(external);
    if (message_arena != submessage_arena) {
      external = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  external_ = external;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Output.external)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace wrapper
}  // namespace egm
}  // namespace abb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::abb::egm::wrapper::Header_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Header_MessageType>() {
  return ::abb::egm::wrapper::Header_MessageType_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Header_RWVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Header_RWVersion>() {
  return ::abb::egm::wrapper::Header_RWVersion_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Header_EGMVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Header_EGMVersion>() {
  return ::abb::egm::wrapper::Header_EGMVersion_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Status_EGMState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Status_EGMState>() {
  return ::abb::egm::wrapper::Status_EGMState_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Status_MotorState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Status_MotorState>() {
  return ::abb::egm::wrapper::Status_MotorState_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Status_RAPIDExecutionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Status_RAPIDExecutionState>() {
  return ::abb::egm::wrapper::Status_RAPIDExecutionState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_egm_5fwrapper_2eproto
