// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_egm_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_egm_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_egm_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_egm_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_egm_2eproto;
namespace abb {
namespace egm {
class EgmCartesian;
class EgmCartesianDefaultTypeInternal;
extern EgmCartesianDefaultTypeInternal _EgmCartesian_default_instance_;
class EgmCartesianSpeed;
class EgmCartesianSpeedDefaultTypeInternal;
extern EgmCartesianSpeedDefaultTypeInternal _EgmCartesianSpeed_default_instance_;
class EgmClock;
class EgmClockDefaultTypeInternal;
extern EgmClockDefaultTypeInternal _EgmClock_default_instance_;
class EgmEuler;
class EgmEulerDefaultTypeInternal;
extern EgmEulerDefaultTypeInternal _EgmEuler_default_instance_;
class EgmExternalJoints;
class EgmExternalJointsDefaultTypeInternal;
extern EgmExternalJointsDefaultTypeInternal _EgmExternalJoints_default_instance_;
class EgmFeedBack;
class EgmFeedBackDefaultTypeInternal;
extern EgmFeedBackDefaultTypeInternal _EgmFeedBack_default_instance_;
class EgmHeader;
class EgmHeaderDefaultTypeInternal;
extern EgmHeaderDefaultTypeInternal _EgmHeader_default_instance_;
class EgmJoints;
class EgmJointsDefaultTypeInternal;
extern EgmJointsDefaultTypeInternal _EgmJoints_default_instance_;
class EgmMCIState;
class EgmMCIStateDefaultTypeInternal;
extern EgmMCIStateDefaultTypeInternal _EgmMCIState_default_instance_;
class EgmMeasuredForce;
class EgmMeasuredForceDefaultTypeInternal;
extern EgmMeasuredForceDefaultTypeInternal _EgmMeasuredForce_default_instance_;
class EgmMotorState;
class EgmMotorStateDefaultTypeInternal;
extern EgmMotorStateDefaultTypeInternal _EgmMotorState_default_instance_;
class EgmPathCorr;
class EgmPathCorrDefaultTypeInternal;
extern EgmPathCorrDefaultTypeInternal _EgmPathCorr_default_instance_;
class EgmPlanned;
class EgmPlannedDefaultTypeInternal;
extern EgmPlannedDefaultTypeInternal _EgmPlanned_default_instance_;
class EgmPose;
class EgmPoseDefaultTypeInternal;
extern EgmPoseDefaultTypeInternal _EgmPose_default_instance_;
class EgmQuaternion;
class EgmQuaternionDefaultTypeInternal;
extern EgmQuaternionDefaultTypeInternal _EgmQuaternion_default_instance_;
class EgmRapidCtrlExecState;
class EgmRapidCtrlExecStateDefaultTypeInternal;
extern EgmRapidCtrlExecStateDefaultTypeInternal _EgmRapidCtrlExecState_default_instance_;
class EgmRobot;
class EgmRobotDefaultTypeInternal;
extern EgmRobotDefaultTypeInternal _EgmRobot_default_instance_;
class EgmSensor;
class EgmSensorDefaultTypeInternal;
extern EgmSensorDefaultTypeInternal _EgmSensor_default_instance_;
class EgmSensorPathCorr;
class EgmSensorPathCorrDefaultTypeInternal;
extern EgmSensorPathCorrDefaultTypeInternal _EgmSensorPathCorr_default_instance_;
class EgmSpeedRef;
class EgmSpeedRefDefaultTypeInternal;
extern EgmSpeedRefDefaultTypeInternal _EgmSpeedRef_default_instance_;
class EgmTestSignals;
class EgmTestSignalsDefaultTypeInternal;
extern EgmTestSignalsDefaultTypeInternal _EgmTestSignals_default_instance_;
}  // namespace egm
}  // namespace abb
PROTOBUF_NAMESPACE_OPEN
template<> ::abb::egm::EgmCartesian* Arena::CreateMaybeMessage<::abb::egm::EgmCartesian>(Arena*);
template<> ::abb::egm::EgmCartesianSpeed* Arena::CreateMaybeMessage<::abb::egm::EgmCartesianSpeed>(Arena*);
template<> ::abb::egm::EgmClock* Arena::CreateMaybeMessage<::abb::egm::EgmClock>(Arena*);
template<> ::abb::egm::EgmEuler* Arena::CreateMaybeMessage<::abb::egm::EgmEuler>(Arena*);
template<> ::abb::egm::EgmExternalJoints* Arena::CreateMaybeMessage<::abb::egm::EgmExternalJoints>(Arena*);
template<> ::abb::egm::EgmFeedBack* Arena::CreateMaybeMessage<::abb::egm::EgmFeedBack>(Arena*);
template<> ::abb::egm::EgmHeader* Arena::CreateMaybeMessage<::abb::egm::EgmHeader>(Arena*);
template<> ::abb::egm::EgmJoints* Arena::CreateMaybeMessage<::abb::egm::EgmJoints>(Arena*);
template<> ::abb::egm::EgmMCIState* Arena::CreateMaybeMessage<::abb::egm::EgmMCIState>(Arena*);
template<> ::abb::egm::EgmMeasuredForce* Arena::CreateMaybeMessage<::abb::egm::EgmMeasuredForce>(Arena*);
template<> ::abb::egm::EgmMotorState* Arena::CreateMaybeMessage<::abb::egm::EgmMotorState>(Arena*);
template<> ::abb::egm::EgmPathCorr* Arena::CreateMaybeMessage<::abb::egm::EgmPathCorr>(Arena*);
template<> ::abb::egm::EgmPlanned* Arena::CreateMaybeMessage<::abb::egm::EgmPlanned>(Arena*);
template<> ::abb::egm::EgmPose* Arena::CreateMaybeMessage<::abb::egm::EgmPose>(Arena*);
template<> ::abb::egm::EgmQuaternion* Arena::CreateMaybeMessage<::abb::egm::EgmQuaternion>(Arena*);
template<> ::abb::egm::EgmRapidCtrlExecState* Arena::CreateMaybeMessage<::abb::egm::EgmRapidCtrlExecState>(Arena*);
template<> ::abb::egm::EgmRobot* Arena::CreateMaybeMessage<::abb::egm::EgmRobot>(Arena*);
template<> ::abb::egm::EgmSensor* Arena::CreateMaybeMessage<::abb::egm::EgmSensor>(Arena*);
template<> ::abb::egm::EgmSensorPathCorr* Arena::CreateMaybeMessage<::abb::egm::EgmSensorPathCorr>(Arena*);
template<> ::abb::egm::EgmSpeedRef* Arena::CreateMaybeMessage<::abb::egm::EgmSpeedRef>(Arena*);
template<> ::abb::egm::EgmTestSignals* Arena::CreateMaybeMessage<::abb::egm::EgmTestSignals>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace abb {
namespace egm {

enum EgmHeader_MessageType : int {
  EgmHeader_MessageType_MSGTYPE_UNDEFINED = 0,
  EgmHeader_MessageType_MSGTYPE_COMMAND = 1,
  EgmHeader_MessageType_MSGTYPE_DATA = 2,
  EgmHeader_MessageType_MSGTYPE_CORRECTION = 3,
  EgmHeader_MessageType_MSGTYPE_PATH_CORRECTION = 4
};
bool EgmHeader_MessageType_IsValid(int value);
constexpr EgmHeader_MessageType EgmHeader_MessageType_MessageType_MIN = EgmHeader_MessageType_MSGTYPE_UNDEFINED;
constexpr EgmHeader_MessageType EgmHeader_MessageType_MessageType_MAX = EgmHeader_MessageType_MSGTYPE_PATH_CORRECTION;
constexpr int EgmHeader_MessageType_MessageType_ARRAYSIZE = EgmHeader_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmHeader_MessageType_descriptor();
template<typename T>
inline const std::string& EgmHeader_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EgmHeader_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EgmHeader_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EgmHeader_MessageType_descriptor(), enum_t_value);
}
inline bool EgmHeader_MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EgmHeader_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EgmHeader_MessageType>(
    EgmHeader_MessageType_descriptor(), name, value);
}
enum EgmMotorState_MotorStateType : int {
  EgmMotorState_MotorStateType_MOTORS_UNDEFINED = 0,
  EgmMotorState_MotorStateType_MOTORS_ON = 1,
  EgmMotorState_MotorStateType_MOTORS_OFF = 2
};
bool EgmMotorState_MotorStateType_IsValid(int value);
constexpr EgmMotorState_MotorStateType EgmMotorState_MotorStateType_MotorStateType_MIN = EgmMotorState_MotorStateType_MOTORS_UNDEFINED;
constexpr EgmMotorState_MotorStateType EgmMotorState_MotorStateType_MotorStateType_MAX = EgmMotorState_MotorStateType_MOTORS_OFF;
constexpr int EgmMotorState_MotorStateType_MotorStateType_ARRAYSIZE = EgmMotorState_MotorStateType_MotorStateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmMotorState_MotorStateType_descriptor();
template<typename T>
inline const std::string& EgmMotorState_MotorStateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EgmMotorState_MotorStateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EgmMotorState_MotorStateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EgmMotorState_MotorStateType_descriptor(), enum_t_value);
}
inline bool EgmMotorState_MotorStateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EgmMotorState_MotorStateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EgmMotorState_MotorStateType>(
    EgmMotorState_MotorStateType_descriptor(), name, value);
}
enum EgmMCIState_MCIStateType : int {
  EgmMCIState_MCIStateType_MCI_UNDEFINED = 0,
  EgmMCIState_MCIStateType_MCI_ERROR = 1,
  EgmMCIState_MCIStateType_MCI_STOPPED = 2,
  EgmMCIState_MCIStateType_MCI_RUNNING = 3
};
bool EgmMCIState_MCIStateType_IsValid(int value);
constexpr EgmMCIState_MCIStateType EgmMCIState_MCIStateType_MCIStateType_MIN = EgmMCIState_MCIStateType_MCI_UNDEFINED;
constexpr EgmMCIState_MCIStateType EgmMCIState_MCIStateType_MCIStateType_MAX = EgmMCIState_MCIStateType_MCI_RUNNING;
constexpr int EgmMCIState_MCIStateType_MCIStateType_ARRAYSIZE = EgmMCIState_MCIStateType_MCIStateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmMCIState_MCIStateType_descriptor();
template<typename T>
inline const std::string& EgmMCIState_MCIStateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EgmMCIState_MCIStateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EgmMCIState_MCIStateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EgmMCIState_MCIStateType_descriptor(), enum_t_value);
}
inline bool EgmMCIState_MCIStateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EgmMCIState_MCIStateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EgmMCIState_MCIStateType>(
    EgmMCIState_MCIStateType_descriptor(), name, value);
}
enum EgmRapidCtrlExecState_RapidCtrlExecStateType : int {
  EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_UNDEFINED = 0,
  EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_STOPPED = 1,
  EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_RUNNING = 2
};
bool EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(int value);
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MIN = EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_UNDEFINED;
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MAX = EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_RUNNING;
constexpr int EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_ARRAYSIZE = EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor();
template<typename T>
inline const std::string& EgmRapidCtrlExecState_RapidCtrlExecStateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EgmRapidCtrlExecState_RapidCtrlExecStateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EgmRapidCtrlExecState_RapidCtrlExecStateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor(), enum_t_value);
}
inline bool EgmRapidCtrlExecState_RapidCtrlExecStateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EgmRapidCtrlExecState_RapidCtrlExecStateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EgmRapidCtrlExecState_RapidCtrlExecStateType>(
    EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor(), name, value);
}
// ===================================================================

class EgmHeader PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmHeader) */ {
 public:
  inline EgmHeader() : EgmHeader(nullptr) {}
  virtual ~EgmHeader();

  EgmHeader(const EgmHeader& from);
  EgmHeader(EgmHeader&& from) noexcept
    : EgmHeader() {
    *this = ::std::move(from);
  }

  inline EgmHeader& operator=(const EgmHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmHeader& operator=(EgmHeader&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmHeader& default_instance();

  static inline const EgmHeader* internal_default_instance() {
    return reinterpret_cast<const EgmHeader*>(
               &_EgmHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EgmHeader& a, EgmHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmHeader* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmHeader* New() const final {
    return CreateMaybeMessage<EgmHeader>(nullptr);
  }

  EgmHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmHeader& from);
  void MergeFrom(const EgmHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmHeader";
  }
  protected:
  explicit EgmHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef EgmHeader_MessageType MessageType;
  static constexpr MessageType MSGTYPE_UNDEFINED =
    EgmHeader_MessageType_MSGTYPE_UNDEFINED;
  static constexpr MessageType MSGTYPE_COMMAND =
    EgmHeader_MessageType_MSGTYPE_COMMAND;
  static constexpr MessageType MSGTYPE_DATA =
    EgmHeader_MessageType_MSGTYPE_DATA;
  static constexpr MessageType MSGTYPE_CORRECTION =
    EgmHeader_MessageType_MSGTYPE_CORRECTION;
  static constexpr MessageType MSGTYPE_PATH_CORRECTION =
    EgmHeader_MessageType_MSGTYPE_PATH_CORRECTION;
  static inline bool MessageType_IsValid(int value) {
    return EgmHeader_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    EgmHeader_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    EgmHeader_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    EgmHeader_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return EgmHeader_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return EgmHeader_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MessageType* value) {
    return EgmHeader_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSeqnoFieldNumber = 1,
    kTmFieldNumber = 2,
    kMtypeFieldNumber = 3,
  };
  // optional uint32 seqno = 1;
  bool has_seqno() const;
  private:
  bool _internal_has_seqno() const;
  public:
  void clear_seqno();
  ::PROTOBUF_NAMESPACE_ID::uint32 seqno() const;
  void set_seqno(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_seqno() const;
  void _internal_set_seqno(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 tm = 2;
  bool has_tm() const;
  private:
  bool _internal_has_tm() const;
  public:
  void clear_tm();
  ::PROTOBUF_NAMESPACE_ID::uint32 tm() const;
  void set_tm(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tm() const;
  void _internal_set_tm(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
  bool has_mtype() const;
  private:
  bool _internal_has_mtype() const;
  public:
  void clear_mtype();
  ::abb::egm::EgmHeader_MessageType mtype() const;
  void set_mtype(::abb::egm::EgmHeader_MessageType value);
  private:
  ::abb::egm::EgmHeader_MessageType _internal_mtype() const;
  void _internal_set_mtype(::abb::egm::EgmHeader_MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 seqno_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tm_;
  int mtype_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmCartesian PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmCartesian) */ {
 public:
  inline EgmCartesian() : EgmCartesian(nullptr) {}
  virtual ~EgmCartesian();

  EgmCartesian(const EgmCartesian& from);
  EgmCartesian(EgmCartesian&& from) noexcept
    : EgmCartesian() {
    *this = ::std::move(from);
  }

  inline EgmCartesian& operator=(const EgmCartesian& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmCartesian& operator=(EgmCartesian&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmCartesian& default_instance();

  static inline const EgmCartesian* internal_default_instance() {
    return reinterpret_cast<const EgmCartesian*>(
               &_EgmCartesian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EgmCartesian& a, EgmCartesian& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmCartesian* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmCartesian* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmCartesian* New() const final {
    return CreateMaybeMessage<EgmCartesian>(nullptr);
  }

  EgmCartesian* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmCartesian>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmCartesian& from);
  void MergeFrom(const EgmCartesian& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmCartesian* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmCartesian";
  }
  protected:
  explicit EgmCartesian(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // required double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // required double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmCartesian)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmQuaternion PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmQuaternion) */ {
 public:
  inline EgmQuaternion() : EgmQuaternion(nullptr) {}
  virtual ~EgmQuaternion();

  EgmQuaternion(const EgmQuaternion& from);
  EgmQuaternion(EgmQuaternion&& from) noexcept
    : EgmQuaternion() {
    *this = ::std::move(from);
  }

  inline EgmQuaternion& operator=(const EgmQuaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmQuaternion& operator=(EgmQuaternion&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmQuaternion& default_instance();

  static inline const EgmQuaternion* internal_default_instance() {
    return reinterpret_cast<const EgmQuaternion*>(
               &_EgmQuaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EgmQuaternion& a, EgmQuaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmQuaternion* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmQuaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmQuaternion* New() const final {
    return CreateMaybeMessage<EgmQuaternion>(nullptr);
  }

  EgmQuaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmQuaternion>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmQuaternion& from);
  void MergeFrom(const EgmQuaternion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmQuaternion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmQuaternion";
  }
  protected:
  explicit EgmQuaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kU0FieldNumber = 1,
    kU1FieldNumber = 2,
    kU2FieldNumber = 3,
    kU3FieldNumber = 4,
  };
  // required double u0 = 1;
  bool has_u0() const;
  private:
  bool _internal_has_u0() const;
  public:
  void clear_u0();
  double u0() const;
  void set_u0(double value);
  private:
  double _internal_u0() const;
  void _internal_set_u0(double value);
  public:

  // required double u1 = 2;
  bool has_u1() const;
  private:
  bool _internal_has_u1() const;
  public:
  void clear_u1();
  double u1() const;
  void set_u1(double value);
  private:
  double _internal_u1() const;
  void _internal_set_u1(double value);
  public:

  // required double u2 = 3;
  bool has_u2() const;
  private:
  bool _internal_has_u2() const;
  public:
  void clear_u2();
  double u2() const;
  void set_u2(double value);
  private:
  double _internal_u2() const;
  void _internal_set_u2(double value);
  public:

  // required double u3 = 4;
  bool has_u3() const;
  private:
  bool _internal_has_u3() const;
  public:
  void clear_u3();
  double u3() const;
  void set_u3(double value);
  private:
  double _internal_u3() const;
  void _internal_set_u3(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmQuaternion)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double u0_;
  double u1_;
  double u2_;
  double u3_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmEuler PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmEuler) */ {
 public:
  inline EgmEuler() : EgmEuler(nullptr) {}
  virtual ~EgmEuler();

  EgmEuler(const EgmEuler& from);
  EgmEuler(EgmEuler&& from) noexcept
    : EgmEuler() {
    *this = ::std::move(from);
  }

  inline EgmEuler& operator=(const EgmEuler& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmEuler& operator=(EgmEuler&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmEuler& default_instance();

  static inline const EgmEuler* internal_default_instance() {
    return reinterpret_cast<const EgmEuler*>(
               &_EgmEuler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EgmEuler& a, EgmEuler& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmEuler* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmEuler* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmEuler* New() const final {
    return CreateMaybeMessage<EgmEuler>(nullptr);
  }

  EgmEuler* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmEuler>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmEuler& from);
  void MergeFrom(const EgmEuler& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmEuler* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmEuler";
  }
  protected:
  explicit EgmEuler(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // required double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // required double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmEuler)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmClock PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmClock) */ {
 public:
  inline EgmClock() : EgmClock(nullptr) {}
  virtual ~EgmClock();

  EgmClock(const EgmClock& from);
  EgmClock(EgmClock&& from) noexcept
    : EgmClock() {
    *this = ::std::move(from);
  }

  inline EgmClock& operator=(const EgmClock& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmClock& operator=(EgmClock&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmClock& default_instance();

  static inline const EgmClock* internal_default_instance() {
    return reinterpret_cast<const EgmClock*>(
               &_EgmClock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EgmClock& a, EgmClock& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmClock* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmClock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmClock* New() const final {
    return CreateMaybeMessage<EgmClock>(nullptr);
  }

  EgmClock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmClock>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmClock& from);
  void MergeFrom(const EgmClock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmClock* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmClock";
  }
  protected:
  explicit EgmClock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecFieldNumber = 1,
    kUsecFieldNumber = 2,
  };
  // required uint64 sec = 1;
  bool has_sec() const;
  private:
  bool _internal_has_sec() const;
  public:
  void clear_sec();
  ::PROTOBUF_NAMESPACE_ID::uint64 sec() const;
  void set_sec(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sec() const;
  void _internal_set_sec(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 usec = 2;
  bool has_usec() const;
  private:
  bool _internal_has_usec() const;
  public:
  void clear_usec();
  ::PROTOBUF_NAMESPACE_ID::uint64 usec() const;
  void set_usec(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_usec() const;
  void _internal_set_usec(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmClock)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sec_;
  ::PROTOBUF_NAMESPACE_ID::uint64 usec_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmPose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmPose) */ {
 public:
  inline EgmPose() : EgmPose(nullptr) {}
  virtual ~EgmPose();

  EgmPose(const EgmPose& from);
  EgmPose(EgmPose&& from) noexcept
    : EgmPose() {
    *this = ::std::move(from);
  }

  inline EgmPose& operator=(const EgmPose& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmPose& operator=(EgmPose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmPose& default_instance();

  static inline const EgmPose* internal_default_instance() {
    return reinterpret_cast<const EgmPose*>(
               &_EgmPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EgmPose& a, EgmPose& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmPose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmPose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmPose* New() const final {
    return CreateMaybeMessage<EgmPose>(nullptr);
  }

  EgmPose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmPose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmPose& from);
  void MergeFrom(const EgmPose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmPose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmPose";
  }
  protected:
  explicit EgmPose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kOrientFieldNumber = 2,
    kEulerFieldNumber = 3,
  };
  // optional .abb.egm.EgmCartesian pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::abb::egm::EgmCartesian& pos() const;
  ::abb::egm::EgmCartesian* release_pos();
  ::abb::egm::EgmCartesian* mutable_pos();
  void set_allocated_pos(::abb::egm::EgmCartesian* pos);
  private:
  const ::abb::egm::EgmCartesian& _internal_pos() const;
  ::abb::egm::EgmCartesian* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::abb::egm::EgmCartesian* pos);
  ::abb::egm::EgmCartesian* unsafe_arena_release_pos();

  // optional .abb.egm.EgmQuaternion orient = 2;
  bool has_orient() const;
  private:
  bool _internal_has_orient() const;
  public:
  void clear_orient();
  const ::abb::egm::EgmQuaternion& orient() const;
  ::abb::egm::EgmQuaternion* release_orient();
  ::abb::egm::EgmQuaternion* mutable_orient();
  void set_allocated_orient(::abb::egm::EgmQuaternion* orient);
  private:
  const ::abb::egm::EgmQuaternion& _internal_orient() const;
  ::abb::egm::EgmQuaternion* _internal_mutable_orient();
  public:
  void unsafe_arena_set_allocated_orient(
      ::abb::egm::EgmQuaternion* orient);
  ::abb::egm::EgmQuaternion* unsafe_arena_release_orient();

  // optional .abb.egm.EgmEuler euler = 3;
  bool has_euler() const;
  private:
  bool _internal_has_euler() const;
  public:
  void clear_euler();
  const ::abb::egm::EgmEuler& euler() const;
  ::abb::egm::EgmEuler* release_euler();
  ::abb::egm::EgmEuler* mutable_euler();
  void set_allocated_euler(::abb::egm::EgmEuler* euler);
  private:
  const ::abb::egm::EgmEuler& _internal_euler() const;
  ::abb::egm::EgmEuler* _internal_mutable_euler();
  public:
  void unsafe_arena_set_allocated_euler(
      ::abb::egm::EgmEuler* euler);
  ::abb::egm::EgmEuler* unsafe_arena_release_euler();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmPose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::EgmCartesian* pos_;
  ::abb::egm::EgmQuaternion* orient_;
  ::abb::egm::EgmEuler* euler_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmCartesianSpeed PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmCartesianSpeed) */ {
 public:
  inline EgmCartesianSpeed() : EgmCartesianSpeed(nullptr) {}
  virtual ~EgmCartesianSpeed();

  EgmCartesianSpeed(const EgmCartesianSpeed& from);
  EgmCartesianSpeed(EgmCartesianSpeed&& from) noexcept
    : EgmCartesianSpeed() {
    *this = ::std::move(from);
  }

  inline EgmCartesianSpeed& operator=(const EgmCartesianSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmCartesianSpeed& operator=(EgmCartesianSpeed&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmCartesianSpeed& default_instance();

  static inline const EgmCartesianSpeed* internal_default_instance() {
    return reinterpret_cast<const EgmCartesianSpeed*>(
               &_EgmCartesianSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EgmCartesianSpeed& a, EgmCartesianSpeed& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmCartesianSpeed* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmCartesianSpeed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmCartesianSpeed* New() const final {
    return CreateMaybeMessage<EgmCartesianSpeed>(nullptr);
  }

  EgmCartesianSpeed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmCartesianSpeed>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmCartesianSpeed& from);
  void MergeFrom(const EgmCartesianSpeed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmCartesianSpeed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmCartesianSpeed";
  }
  protected:
  explicit EgmCartesianSpeed(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated double value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  private:
  double _internal_value(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_value() const;
  void _internal_add_value(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_value();
  public:
  double value(int index) const;
  void set_value(int index, double value);
  void add_value(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmCartesianSpeed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmJoints PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmJoints) */ {
 public:
  inline EgmJoints() : EgmJoints(nullptr) {}
  virtual ~EgmJoints();

  EgmJoints(const EgmJoints& from);
  EgmJoints(EgmJoints&& from) noexcept
    : EgmJoints() {
    *this = ::std::move(from);
  }

  inline EgmJoints& operator=(const EgmJoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmJoints& operator=(EgmJoints&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmJoints& default_instance();

  static inline const EgmJoints* internal_default_instance() {
    return reinterpret_cast<const EgmJoints*>(
               &_EgmJoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EgmJoints& a, EgmJoints& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmJoints* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmJoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmJoints* New() const final {
    return CreateMaybeMessage<EgmJoints>(nullptr);
  }

  EgmJoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmJoints>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmJoints& from);
  void MergeFrom(const EgmJoints& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmJoints* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmJoints";
  }
  protected:
  explicit EgmJoints(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
  };
  // repeated double joints = 1;
  int joints_size() const;
  private:
  int _internal_joints_size() const;
  public:
  void clear_joints();
  private:
  double _internal_joints(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_joints() const;
  void _internal_add_joints(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_joints();
  public:
  double joints(int index) const;
  void set_joints(int index, double value);
  void add_joints(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      joints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_joints();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmJoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > joints_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmExternalJoints PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmExternalJoints) */ {
 public:
  inline EgmExternalJoints() : EgmExternalJoints(nullptr) {}
  virtual ~EgmExternalJoints();

  EgmExternalJoints(const EgmExternalJoints& from);
  EgmExternalJoints(EgmExternalJoints&& from) noexcept
    : EgmExternalJoints() {
    *this = ::std::move(from);
  }

  inline EgmExternalJoints& operator=(const EgmExternalJoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmExternalJoints& operator=(EgmExternalJoints&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmExternalJoints& default_instance();

  static inline const EgmExternalJoints* internal_default_instance() {
    return reinterpret_cast<const EgmExternalJoints*>(
               &_EgmExternalJoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EgmExternalJoints& a, EgmExternalJoints& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmExternalJoints* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmExternalJoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmExternalJoints* New() const final {
    return CreateMaybeMessage<EgmExternalJoints>(nullptr);
  }

  EgmExternalJoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmExternalJoints>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmExternalJoints& from);
  void MergeFrom(const EgmExternalJoints& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmExternalJoints* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmExternalJoints";
  }
  protected:
  explicit EgmExternalJoints(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
  };
  // repeated double joints = 1;
  int joints_size() const;
  private:
  int _internal_joints_size() const;
  public:
  void clear_joints();
  private:
  double _internal_joints(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_joints() const;
  void _internal_add_joints(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_joints();
  public:
  double joints(int index) const;
  void set_joints(int index, double value);
  void add_joints(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      joints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_joints();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmExternalJoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > joints_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmPlanned PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmPlanned) */ {
 public:
  inline EgmPlanned() : EgmPlanned(nullptr) {}
  virtual ~EgmPlanned();

  EgmPlanned(const EgmPlanned& from);
  EgmPlanned(EgmPlanned&& from) noexcept
    : EgmPlanned() {
    *this = ::std::move(from);
  }

  inline EgmPlanned& operator=(const EgmPlanned& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmPlanned& operator=(EgmPlanned&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmPlanned& default_instance();

  static inline const EgmPlanned* internal_default_instance() {
    return reinterpret_cast<const EgmPlanned*>(
               &_EgmPlanned_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EgmPlanned& a, EgmPlanned& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmPlanned* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmPlanned* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmPlanned* New() const final {
    return CreateMaybeMessage<EgmPlanned>(nullptr);
  }

  EgmPlanned* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmPlanned>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmPlanned& from);
  void MergeFrom(const EgmPlanned& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmPlanned* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmPlanned";
  }
  protected:
  explicit EgmPlanned(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesianFieldNumber = 2,
    kExternalJointsFieldNumber = 3,
    kTimeFieldNumber = 4,
  };
  // optional .abb.egm.EgmJoints joints = 1;
  bool has_joints() const;
  private:
  bool _internal_has_joints() const;
  public:
  void clear_joints();
  const ::abb::egm::EgmJoints& joints() const;
  ::abb::egm::EgmJoints* release_joints();
  ::abb::egm::EgmJoints* mutable_joints();
  void set_allocated_joints(::abb::egm::EgmJoints* joints);
  private:
  const ::abb::egm::EgmJoints& _internal_joints() const;
  ::abb::egm::EgmJoints* _internal_mutable_joints();
  public:
  void unsafe_arena_set_allocated_joints(
      ::abb::egm::EgmJoints* joints);
  ::abb::egm::EgmJoints* unsafe_arena_release_joints();

  // optional .abb.egm.EgmPose cartesian = 2;
  bool has_cartesian() const;
  private:
  bool _internal_has_cartesian() const;
  public:
  void clear_cartesian();
  const ::abb::egm::EgmPose& cartesian() const;
  ::abb::egm::EgmPose* release_cartesian();
  ::abb::egm::EgmPose* mutable_cartesian();
  void set_allocated_cartesian(::abb::egm::EgmPose* cartesian);
  private:
  const ::abb::egm::EgmPose& _internal_cartesian() const;
  ::abb::egm::EgmPose* _internal_mutable_cartesian();
  public:
  void unsafe_arena_set_allocated_cartesian(
      ::abb::egm::EgmPose* cartesian);
  ::abb::egm::EgmPose* unsafe_arena_release_cartesian();

  // optional .abb.egm.EgmJoints externalJoints = 3;
  bool has_externaljoints() const;
  private:
  bool _internal_has_externaljoints() const;
  public:
  void clear_externaljoints();
  const ::abb::egm::EgmJoints& externaljoints() const;
  ::abb::egm::EgmJoints* release_externaljoints();
  ::abb::egm::EgmJoints* mutable_externaljoints();
  void set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints);
  private:
  const ::abb::egm::EgmJoints& _internal_externaljoints() const;
  ::abb::egm::EgmJoints* _internal_mutable_externaljoints();
  public:
  void unsafe_arena_set_allocated_externaljoints(
      ::abb::egm::EgmJoints* externaljoints);
  ::abb::egm::EgmJoints* unsafe_arena_release_externaljoints();

  // optional .abb.egm.EgmClock time = 4;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::abb::egm::EgmClock& time() const;
  ::abb::egm::EgmClock* release_time();
  ::abb::egm::EgmClock* mutable_time();
  void set_allocated_time(::abb::egm::EgmClock* time);
  private:
  const ::abb::egm::EgmClock& _internal_time() const;
  ::abb::egm::EgmClock* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::abb::egm::EgmClock* time);
  ::abb::egm::EgmClock* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmPlanned)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::EgmJoints* joints_;
  ::abb::egm::EgmPose* cartesian_;
  ::abb::egm::EgmJoints* externaljoints_;
  ::abb::egm::EgmClock* time_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmSpeedRef PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmSpeedRef) */ {
 public:
  inline EgmSpeedRef() : EgmSpeedRef(nullptr) {}
  virtual ~EgmSpeedRef();

  EgmSpeedRef(const EgmSpeedRef& from);
  EgmSpeedRef(EgmSpeedRef&& from) noexcept
    : EgmSpeedRef() {
    *this = ::std::move(from);
  }

  inline EgmSpeedRef& operator=(const EgmSpeedRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmSpeedRef& operator=(EgmSpeedRef&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmSpeedRef& default_instance();

  static inline const EgmSpeedRef* internal_default_instance() {
    return reinterpret_cast<const EgmSpeedRef*>(
               &_EgmSpeedRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EgmSpeedRef& a, EgmSpeedRef& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmSpeedRef* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmSpeedRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmSpeedRef* New() const final {
    return CreateMaybeMessage<EgmSpeedRef>(nullptr);
  }

  EgmSpeedRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmSpeedRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmSpeedRef& from);
  void MergeFrom(const EgmSpeedRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmSpeedRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmSpeedRef";
  }
  protected:
  explicit EgmSpeedRef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesiansFieldNumber = 2,
    kExternalJointsFieldNumber = 3,
  };
  // optional .abb.egm.EgmJoints joints = 1;
  bool has_joints() const;
  private:
  bool _internal_has_joints() const;
  public:
  void clear_joints();
  const ::abb::egm::EgmJoints& joints() const;
  ::abb::egm::EgmJoints* release_joints();
  ::abb::egm::EgmJoints* mutable_joints();
  void set_allocated_joints(::abb::egm::EgmJoints* joints);
  private:
  const ::abb::egm::EgmJoints& _internal_joints() const;
  ::abb::egm::EgmJoints* _internal_mutable_joints();
  public:
  void unsafe_arena_set_allocated_joints(
      ::abb::egm::EgmJoints* joints);
  ::abb::egm::EgmJoints* unsafe_arena_release_joints();

  // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
  bool has_cartesians() const;
  private:
  bool _internal_has_cartesians() const;
  public:
  void clear_cartesians();
  const ::abb::egm::EgmCartesianSpeed& cartesians() const;
  ::abb::egm::EgmCartesianSpeed* release_cartesians();
  ::abb::egm::EgmCartesianSpeed* mutable_cartesians();
  void set_allocated_cartesians(::abb::egm::EgmCartesianSpeed* cartesians);
  private:
  const ::abb::egm::EgmCartesianSpeed& _internal_cartesians() const;
  ::abb::egm::EgmCartesianSpeed* _internal_mutable_cartesians();
  public:
  void unsafe_arena_set_allocated_cartesians(
      ::abb::egm::EgmCartesianSpeed* cartesians);
  ::abb::egm::EgmCartesianSpeed* unsafe_arena_release_cartesians();

  // optional .abb.egm.EgmJoints externalJoints = 3;
  bool has_externaljoints() const;
  private:
  bool _internal_has_externaljoints() const;
  public:
  void clear_externaljoints();
  const ::abb::egm::EgmJoints& externaljoints() const;
  ::abb::egm::EgmJoints* release_externaljoints();
  ::abb::egm::EgmJoints* mutable_externaljoints();
  void set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints);
  private:
  const ::abb::egm::EgmJoints& _internal_externaljoints() const;
  ::abb::egm::EgmJoints* _internal_mutable_externaljoints();
  public:
  void unsafe_arena_set_allocated_externaljoints(
      ::abb::egm::EgmJoints* externaljoints);
  ::abb::egm::EgmJoints* unsafe_arena_release_externaljoints();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmSpeedRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::EgmJoints* joints_;
  ::abb::egm::EgmCartesianSpeed* cartesians_;
  ::abb::egm::EgmJoints* externaljoints_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmPathCorr PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmPathCorr) */ {
 public:
  inline EgmPathCorr() : EgmPathCorr(nullptr) {}
  virtual ~EgmPathCorr();

  EgmPathCorr(const EgmPathCorr& from);
  EgmPathCorr(EgmPathCorr&& from) noexcept
    : EgmPathCorr() {
    *this = ::std::move(from);
  }

  inline EgmPathCorr& operator=(const EgmPathCorr& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmPathCorr& operator=(EgmPathCorr&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmPathCorr& default_instance();

  static inline const EgmPathCorr* internal_default_instance() {
    return reinterpret_cast<const EgmPathCorr*>(
               &_EgmPathCorr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EgmPathCorr& a, EgmPathCorr& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmPathCorr* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmPathCorr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmPathCorr* New() const final {
    return CreateMaybeMessage<EgmPathCorr>(nullptr);
  }

  EgmPathCorr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmPathCorr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmPathCorr& from);
  void MergeFrom(const EgmPathCorr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmPathCorr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmPathCorr";
  }
  protected:
  explicit EgmPathCorr(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kAgeFieldNumber = 2,
  };
  // required .abb.egm.EgmCartesian pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::abb::egm::EgmCartesian& pos() const;
  ::abb::egm::EgmCartesian* release_pos();
  ::abb::egm::EgmCartesian* mutable_pos();
  void set_allocated_pos(::abb::egm::EgmCartesian* pos);
  private:
  const ::abb::egm::EgmCartesian& _internal_pos() const;
  ::abb::egm::EgmCartesian* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::abb::egm::EgmCartesian* pos);
  ::abb::egm::EgmCartesian* unsafe_arena_release_pos();

  // required uint32 age = 2;
  bool has_age() const;
  private:
  bool _internal_has_age() const;
  public:
  void clear_age();
  ::PROTOBUF_NAMESPACE_ID::uint32 age() const;
  void set_age(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_age() const;
  void _internal_set_age(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmPathCorr)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::EgmCartesian* pos_;
  ::PROTOBUF_NAMESPACE_ID::uint32 age_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmFeedBack PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmFeedBack) */ {
 public:
  inline EgmFeedBack() : EgmFeedBack(nullptr) {}
  virtual ~EgmFeedBack();

  EgmFeedBack(const EgmFeedBack& from);
  EgmFeedBack(EgmFeedBack&& from) noexcept
    : EgmFeedBack() {
    *this = ::std::move(from);
  }

  inline EgmFeedBack& operator=(const EgmFeedBack& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmFeedBack& operator=(EgmFeedBack&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmFeedBack& default_instance();

  static inline const EgmFeedBack* internal_default_instance() {
    return reinterpret_cast<const EgmFeedBack*>(
               &_EgmFeedBack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EgmFeedBack& a, EgmFeedBack& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmFeedBack* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmFeedBack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmFeedBack* New() const final {
    return CreateMaybeMessage<EgmFeedBack>(nullptr);
  }

  EgmFeedBack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmFeedBack>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmFeedBack& from);
  void MergeFrom(const EgmFeedBack& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmFeedBack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmFeedBack";
  }
  protected:
  explicit EgmFeedBack(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesianFieldNumber = 2,
    kExternalJointsFieldNumber = 3,
    kTimeFieldNumber = 4,
  };
  // optional .abb.egm.EgmJoints joints = 1;
  bool has_joints() const;
  private:
  bool _internal_has_joints() const;
  public:
  void clear_joints();
  const ::abb::egm::EgmJoints& joints() const;
  ::abb::egm::EgmJoints* release_joints();
  ::abb::egm::EgmJoints* mutable_joints();
  void set_allocated_joints(::abb::egm::EgmJoints* joints);
  private:
  const ::abb::egm::EgmJoints& _internal_joints() const;
  ::abb::egm::EgmJoints* _internal_mutable_joints();
  public:
  void unsafe_arena_set_allocated_joints(
      ::abb::egm::EgmJoints* joints);
  ::abb::egm::EgmJoints* unsafe_arena_release_joints();

  // optional .abb.egm.EgmPose cartesian = 2;
  bool has_cartesian() const;
  private:
  bool _internal_has_cartesian() const;
  public:
  void clear_cartesian();
  const ::abb::egm::EgmPose& cartesian() const;
  ::abb::egm::EgmPose* release_cartesian();
  ::abb::egm::EgmPose* mutable_cartesian();
  void set_allocated_cartesian(::abb::egm::EgmPose* cartesian);
  private:
  const ::abb::egm::EgmPose& _internal_cartesian() const;
  ::abb::egm::EgmPose* _internal_mutable_cartesian();
  public:
  void unsafe_arena_set_allocated_cartesian(
      ::abb::egm::EgmPose* cartesian);
  ::abb::egm::EgmPose* unsafe_arena_release_cartesian();

  // optional .abb.egm.EgmJoints externalJoints = 3;
  bool has_externaljoints() const;
  private:
  bool _internal_has_externaljoints() const;
  public:
  void clear_externaljoints();
  const ::abb::egm::EgmJoints& externaljoints() const;
  ::abb::egm::EgmJoints* release_externaljoints();
  ::abb::egm::EgmJoints* mutable_externaljoints();
  void set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints);
  private:
  const ::abb::egm::EgmJoints& _internal_externaljoints() const;
  ::abb::egm::EgmJoints* _internal_mutable_externaljoints();
  public:
  void unsafe_arena_set_allocated_externaljoints(
      ::abb::egm::EgmJoints* externaljoints);
  ::abb::egm::EgmJoints* unsafe_arena_release_externaljoints();

  // optional .abb.egm.EgmClock time = 4;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::abb::egm::EgmClock& time() const;
  ::abb::egm::EgmClock* release_time();
  ::abb::egm::EgmClock* mutable_time();
  void set_allocated_time(::abb::egm::EgmClock* time);
  private:
  const ::abb::egm::EgmClock& _internal_time() const;
  ::abb::egm::EgmClock* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::abb::egm::EgmClock* time);
  ::abb::egm::EgmClock* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmFeedBack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::EgmJoints* joints_;
  ::abb::egm::EgmPose* cartesian_;
  ::abb::egm::EgmJoints* externaljoints_;
  ::abb::egm::EgmClock* time_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmMotorState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmMotorState) */ {
 public:
  inline EgmMotorState() : EgmMotorState(nullptr) {}
  virtual ~EgmMotorState();

  EgmMotorState(const EgmMotorState& from);
  EgmMotorState(EgmMotorState&& from) noexcept
    : EgmMotorState() {
    *this = ::std::move(from);
  }

  inline EgmMotorState& operator=(const EgmMotorState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmMotorState& operator=(EgmMotorState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmMotorState& default_instance();

  static inline const EgmMotorState* internal_default_instance() {
    return reinterpret_cast<const EgmMotorState*>(
               &_EgmMotorState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EgmMotorState& a, EgmMotorState& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmMotorState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmMotorState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmMotorState* New() const final {
    return CreateMaybeMessage<EgmMotorState>(nullptr);
  }

  EgmMotorState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmMotorState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmMotorState& from);
  void MergeFrom(const EgmMotorState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmMotorState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmMotorState";
  }
  protected:
  explicit EgmMotorState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef EgmMotorState_MotorStateType MotorStateType;
  static constexpr MotorStateType MOTORS_UNDEFINED =
    EgmMotorState_MotorStateType_MOTORS_UNDEFINED;
  static constexpr MotorStateType MOTORS_ON =
    EgmMotorState_MotorStateType_MOTORS_ON;
  static constexpr MotorStateType MOTORS_OFF =
    EgmMotorState_MotorStateType_MOTORS_OFF;
  static inline bool MotorStateType_IsValid(int value) {
    return EgmMotorState_MotorStateType_IsValid(value);
  }
  static constexpr MotorStateType MotorStateType_MIN =
    EgmMotorState_MotorStateType_MotorStateType_MIN;
  static constexpr MotorStateType MotorStateType_MAX =
    EgmMotorState_MotorStateType_MotorStateType_MAX;
  static constexpr int MotorStateType_ARRAYSIZE =
    EgmMotorState_MotorStateType_MotorStateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MotorStateType_descriptor() {
    return EgmMotorState_MotorStateType_descriptor();
  }
  template<typename T>
  static inline const std::string& MotorStateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MotorStateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MotorStateType_Name.");
    return EgmMotorState_MotorStateType_Name(enum_t_value);
  }
  static inline bool MotorStateType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MotorStateType* value) {
    return EgmMotorState_MotorStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .abb.egm.EgmMotorState.MotorStateType state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::abb::egm::EgmMotorState_MotorStateType state() const;
  void set_state(::abb::egm::EgmMotorState_MotorStateType value);
  private:
  ::abb::egm::EgmMotorState_MotorStateType _internal_state() const;
  void _internal_set_state(::abb::egm::EgmMotorState_MotorStateType value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmMotorState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int state_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmMCIState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmMCIState) */ {
 public:
  inline EgmMCIState() : EgmMCIState(nullptr) {}
  virtual ~EgmMCIState();

  EgmMCIState(const EgmMCIState& from);
  EgmMCIState(EgmMCIState&& from) noexcept
    : EgmMCIState() {
    *this = ::std::move(from);
  }

  inline EgmMCIState& operator=(const EgmMCIState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmMCIState& operator=(EgmMCIState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmMCIState& default_instance();

  static inline const EgmMCIState* internal_default_instance() {
    return reinterpret_cast<const EgmMCIState*>(
               &_EgmMCIState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(EgmMCIState& a, EgmMCIState& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmMCIState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmMCIState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmMCIState* New() const final {
    return CreateMaybeMessage<EgmMCIState>(nullptr);
  }

  EgmMCIState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmMCIState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmMCIState& from);
  void MergeFrom(const EgmMCIState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmMCIState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmMCIState";
  }
  protected:
  explicit EgmMCIState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef EgmMCIState_MCIStateType MCIStateType;
  static constexpr MCIStateType MCI_UNDEFINED =
    EgmMCIState_MCIStateType_MCI_UNDEFINED;
  static constexpr MCIStateType MCI_ERROR =
    EgmMCIState_MCIStateType_MCI_ERROR;
  static constexpr MCIStateType MCI_STOPPED =
    EgmMCIState_MCIStateType_MCI_STOPPED;
  static constexpr MCIStateType MCI_RUNNING =
    EgmMCIState_MCIStateType_MCI_RUNNING;
  static inline bool MCIStateType_IsValid(int value) {
    return EgmMCIState_MCIStateType_IsValid(value);
  }
  static constexpr MCIStateType MCIStateType_MIN =
    EgmMCIState_MCIStateType_MCIStateType_MIN;
  static constexpr MCIStateType MCIStateType_MAX =
    EgmMCIState_MCIStateType_MCIStateType_MAX;
  static constexpr int MCIStateType_ARRAYSIZE =
    EgmMCIState_MCIStateType_MCIStateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MCIStateType_descriptor() {
    return EgmMCIState_MCIStateType_descriptor();
  }
  template<typename T>
  static inline const std::string& MCIStateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MCIStateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MCIStateType_Name.");
    return EgmMCIState_MCIStateType_Name(enum_t_value);
  }
  static inline bool MCIStateType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MCIStateType* value) {
    return EgmMCIState_MCIStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::abb::egm::EgmMCIState_MCIStateType state() const;
  void set_state(::abb::egm::EgmMCIState_MCIStateType value);
  private:
  ::abb::egm::EgmMCIState_MCIStateType _internal_state() const;
  void _internal_set_state(::abb::egm::EgmMCIState_MCIStateType value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmMCIState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int state_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmRapidCtrlExecState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmRapidCtrlExecState) */ {
 public:
  inline EgmRapidCtrlExecState() : EgmRapidCtrlExecState(nullptr) {}
  virtual ~EgmRapidCtrlExecState();

  EgmRapidCtrlExecState(const EgmRapidCtrlExecState& from);
  EgmRapidCtrlExecState(EgmRapidCtrlExecState&& from) noexcept
    : EgmRapidCtrlExecState() {
    *this = ::std::move(from);
  }

  inline EgmRapidCtrlExecState& operator=(const EgmRapidCtrlExecState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmRapidCtrlExecState& operator=(EgmRapidCtrlExecState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmRapidCtrlExecState& default_instance();

  static inline const EgmRapidCtrlExecState* internal_default_instance() {
    return reinterpret_cast<const EgmRapidCtrlExecState*>(
               &_EgmRapidCtrlExecState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(EgmRapidCtrlExecState& a, EgmRapidCtrlExecState& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmRapidCtrlExecState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmRapidCtrlExecState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmRapidCtrlExecState* New() const final {
    return CreateMaybeMessage<EgmRapidCtrlExecState>(nullptr);
  }

  EgmRapidCtrlExecState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmRapidCtrlExecState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmRapidCtrlExecState& from);
  void MergeFrom(const EgmRapidCtrlExecState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmRapidCtrlExecState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmRapidCtrlExecState";
  }
  protected:
  explicit EgmRapidCtrlExecState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef EgmRapidCtrlExecState_RapidCtrlExecStateType RapidCtrlExecStateType;
  static constexpr RapidCtrlExecStateType RAPID_UNDEFINED =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_UNDEFINED;
  static constexpr RapidCtrlExecStateType RAPID_STOPPED =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_STOPPED;
  static constexpr RapidCtrlExecStateType RAPID_RUNNING =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_RUNNING;
  static inline bool RapidCtrlExecStateType_IsValid(int value) {
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(value);
  }
  static constexpr RapidCtrlExecStateType RapidCtrlExecStateType_MIN =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MIN;
  static constexpr RapidCtrlExecStateType RapidCtrlExecStateType_MAX =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MAX;
  static constexpr int RapidCtrlExecStateType_ARRAYSIZE =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RapidCtrlExecStateType_descriptor() {
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor();
  }
  template<typename T>
  static inline const std::string& RapidCtrlExecStateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RapidCtrlExecStateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RapidCtrlExecStateType_Name.");
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_Name(enum_t_value);
  }
  static inline bool RapidCtrlExecStateType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RapidCtrlExecStateType* value) {
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType state() const;
  void set_state(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType value);
  private:
  ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType _internal_state() const;
  void _internal_set_state(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmRapidCtrlExecState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int state_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmTestSignals PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmTestSignals) */ {
 public:
  inline EgmTestSignals() : EgmTestSignals(nullptr) {}
  virtual ~EgmTestSignals();

  EgmTestSignals(const EgmTestSignals& from);
  EgmTestSignals(EgmTestSignals&& from) noexcept
    : EgmTestSignals() {
    *this = ::std::move(from);
  }

  inline EgmTestSignals& operator=(const EgmTestSignals& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmTestSignals& operator=(EgmTestSignals&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmTestSignals& default_instance();

  static inline const EgmTestSignals* internal_default_instance() {
    return reinterpret_cast<const EgmTestSignals*>(
               &_EgmTestSignals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EgmTestSignals& a, EgmTestSignals& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmTestSignals* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmTestSignals* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmTestSignals* New() const final {
    return CreateMaybeMessage<EgmTestSignals>(nullptr);
  }

  EgmTestSignals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmTestSignals>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmTestSignals& from);
  void MergeFrom(const EgmTestSignals& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmTestSignals* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmTestSignals";
  }
  protected:
  explicit EgmTestSignals(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalsFieldNumber = 1,
  };
  // repeated double signals = 1;
  int signals_size() const;
  private:
  int _internal_signals_size() const;
  public:
  void clear_signals();
  private:
  double _internal_signals(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_signals() const;
  void _internal_add_signals(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_signals();
  public:
  double signals(int index) const;
  void set_signals(int index, double value);
  void add_signals(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      signals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_signals();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmTestSignals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > signals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmMeasuredForce PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmMeasuredForce) */ {
 public:
  inline EgmMeasuredForce() : EgmMeasuredForce(nullptr) {}
  virtual ~EgmMeasuredForce();

  EgmMeasuredForce(const EgmMeasuredForce& from);
  EgmMeasuredForce(EgmMeasuredForce&& from) noexcept
    : EgmMeasuredForce() {
    *this = ::std::move(from);
  }

  inline EgmMeasuredForce& operator=(const EgmMeasuredForce& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmMeasuredForce& operator=(EgmMeasuredForce&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmMeasuredForce& default_instance();

  static inline const EgmMeasuredForce* internal_default_instance() {
    return reinterpret_cast<const EgmMeasuredForce*>(
               &_EgmMeasuredForce_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(EgmMeasuredForce& a, EgmMeasuredForce& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmMeasuredForce* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmMeasuredForce* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmMeasuredForce* New() const final {
    return CreateMaybeMessage<EgmMeasuredForce>(nullptr);
  }

  EgmMeasuredForce* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmMeasuredForce>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmMeasuredForce& from);
  void MergeFrom(const EgmMeasuredForce& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmMeasuredForce* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmMeasuredForce";
  }
  protected:
  explicit EgmMeasuredForce(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForceFieldNumber = 1,
  };
  // repeated double force = 1;
  int force_size() const;
  private:
  int _internal_force_size() const;
  public:
  void clear_force();
  private:
  double _internal_force(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_force() const;
  void _internal_add_force(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_force();
  public:
  double force(int index) const;
  void set_force(int index, double value);
  void add_force(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      force() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_force();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmMeasuredForce)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > force_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmRobot PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmRobot) */ {
 public:
  inline EgmRobot() : EgmRobot(nullptr) {}
  virtual ~EgmRobot();

  EgmRobot(const EgmRobot& from);
  EgmRobot(EgmRobot&& from) noexcept
    : EgmRobot() {
    *this = ::std::move(from);
  }

  inline EgmRobot& operator=(const EgmRobot& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmRobot& operator=(EgmRobot&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmRobot& default_instance();

  static inline const EgmRobot* internal_default_instance() {
    return reinterpret_cast<const EgmRobot*>(
               &_EgmRobot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EgmRobot& a, EgmRobot& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmRobot* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmRobot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmRobot* New() const final {
    return CreateMaybeMessage<EgmRobot>(nullptr);
  }

  EgmRobot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmRobot>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmRobot& from);
  void MergeFrom(const EgmRobot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmRobot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmRobot";
  }
  protected:
  explicit EgmRobot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFeedBackFieldNumber = 2,
    kPlannedFieldNumber = 3,
    kMotorStateFieldNumber = 4,
    kMciStateFieldNumber = 5,
    kTestSignalsFieldNumber = 7,
    kRapidExecStateFieldNumber = 8,
    kMeasuredForceFieldNumber = 9,
    kUtilizationRateFieldNumber = 10,
    kMciConvergenceMetFieldNumber = 6,
  };
  // optional .abb.egm.EgmHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::abb::egm::EgmHeader& header() const;
  ::abb::egm::EgmHeader* release_header();
  ::abb::egm::EgmHeader* mutable_header();
  void set_allocated_header(::abb::egm::EgmHeader* header);
  private:
  const ::abb::egm::EgmHeader& _internal_header() const;
  ::abb::egm::EgmHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::abb::egm::EgmHeader* header);
  ::abb::egm::EgmHeader* unsafe_arena_release_header();

  // optional .abb.egm.EgmFeedBack feedBack = 2;
  bool has_feedback() const;
  private:
  bool _internal_has_feedback() const;
  public:
  void clear_feedback();
  const ::abb::egm::EgmFeedBack& feedback() const;
  ::abb::egm::EgmFeedBack* release_feedback();
  ::abb::egm::EgmFeedBack* mutable_feedback();
  void set_allocated_feedback(::abb::egm::EgmFeedBack* feedback);
  private:
  const ::abb::egm::EgmFeedBack& _internal_feedback() const;
  ::abb::egm::EgmFeedBack* _internal_mutable_feedback();
  public:
  void unsafe_arena_set_allocated_feedback(
      ::abb::egm::EgmFeedBack* feedback);
  ::abb::egm::EgmFeedBack* unsafe_arena_release_feedback();

  // optional .abb.egm.EgmPlanned planned = 3;
  bool has_planned() const;
  private:
  bool _internal_has_planned() const;
  public:
  void clear_planned();
  const ::abb::egm::EgmPlanned& planned() const;
  ::abb::egm::EgmPlanned* release_planned();
  ::abb::egm::EgmPlanned* mutable_planned();
  void set_allocated_planned(::abb::egm::EgmPlanned* planned);
  private:
  const ::abb::egm::EgmPlanned& _internal_planned() const;
  ::abb::egm::EgmPlanned* _internal_mutable_planned();
  public:
  void unsafe_arena_set_allocated_planned(
      ::abb::egm::EgmPlanned* planned);
  ::abb::egm::EgmPlanned* unsafe_arena_release_planned();

  // optional .abb.egm.EgmMotorState motorState = 4;
  bool has_motorstate() const;
  private:
  bool _internal_has_motorstate() const;
  public:
  void clear_motorstate();
  const ::abb::egm::EgmMotorState& motorstate() const;
  ::abb::egm::EgmMotorState* release_motorstate();
  ::abb::egm::EgmMotorState* mutable_motorstate();
  void set_allocated_motorstate(::abb::egm::EgmMotorState* motorstate);
  private:
  const ::abb::egm::EgmMotorState& _internal_motorstate() const;
  ::abb::egm::EgmMotorState* _internal_mutable_motorstate();
  public:
  void unsafe_arena_set_allocated_motorstate(
      ::abb::egm::EgmMotorState* motorstate);
  ::abb::egm::EgmMotorState* unsafe_arena_release_motorstate();

  // optional .abb.egm.EgmMCIState mciState = 5;
  bool has_mcistate() const;
  private:
  bool _internal_has_mcistate() const;
  public:
  void clear_mcistate();
  const ::abb::egm::EgmMCIState& mcistate() const;
  ::abb::egm::EgmMCIState* release_mcistate();
  ::abb::egm::EgmMCIState* mutable_mcistate();
  void set_allocated_mcistate(::abb::egm::EgmMCIState* mcistate);
  private:
  const ::abb::egm::EgmMCIState& _internal_mcistate() const;
  ::abb::egm::EgmMCIState* _internal_mutable_mcistate();
  public:
  void unsafe_arena_set_allocated_mcistate(
      ::abb::egm::EgmMCIState* mcistate);
  ::abb::egm::EgmMCIState* unsafe_arena_release_mcistate();

  // optional .abb.egm.EgmTestSignals testSignals = 7;
  bool has_testsignals() const;
  private:
  bool _internal_has_testsignals() const;
  public:
  void clear_testsignals();
  const ::abb::egm::EgmTestSignals& testsignals() const;
  ::abb::egm::EgmTestSignals* release_testsignals();
  ::abb::egm::EgmTestSignals* mutable_testsignals();
  void set_allocated_testsignals(::abb::egm::EgmTestSignals* testsignals);
  private:
  const ::abb::egm::EgmTestSignals& _internal_testsignals() const;
  ::abb::egm::EgmTestSignals* _internal_mutable_testsignals();
  public:
  void unsafe_arena_set_allocated_testsignals(
      ::abb::egm::EgmTestSignals* testsignals);
  ::abb::egm::EgmTestSignals* unsafe_arena_release_testsignals();

  // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
  bool has_rapidexecstate() const;
  private:
  bool _internal_has_rapidexecstate() const;
  public:
  void clear_rapidexecstate();
  const ::abb::egm::EgmRapidCtrlExecState& rapidexecstate() const;
  ::abb::egm::EgmRapidCtrlExecState* release_rapidexecstate();
  ::abb::egm::EgmRapidCtrlExecState* mutable_rapidexecstate();
  void set_allocated_rapidexecstate(::abb::egm::EgmRapidCtrlExecState* rapidexecstate);
  private:
  const ::abb::egm::EgmRapidCtrlExecState& _internal_rapidexecstate() const;
  ::abb::egm::EgmRapidCtrlExecState* _internal_mutable_rapidexecstate();
  public:
  void unsafe_arena_set_allocated_rapidexecstate(
      ::abb::egm::EgmRapidCtrlExecState* rapidexecstate);
  ::abb::egm::EgmRapidCtrlExecState* unsafe_arena_release_rapidexecstate();

  // optional .abb.egm.EgmMeasuredForce measuredForce = 9;
  bool has_measuredforce() const;
  private:
  bool _internal_has_measuredforce() const;
  public:
  void clear_measuredforce();
  const ::abb::egm::EgmMeasuredForce& measuredforce() const;
  ::abb::egm::EgmMeasuredForce* release_measuredforce();
  ::abb::egm::EgmMeasuredForce* mutable_measuredforce();
  void set_allocated_measuredforce(::abb::egm::EgmMeasuredForce* measuredforce);
  private:
  const ::abb::egm::EgmMeasuredForce& _internal_measuredforce() const;
  ::abb::egm::EgmMeasuredForce* _internal_mutable_measuredforce();
  public:
  void unsafe_arena_set_allocated_measuredforce(
      ::abb::egm::EgmMeasuredForce* measuredforce);
  ::abb::egm::EgmMeasuredForce* unsafe_arena_release_measuredforce();

  // optional double utilizationRate = 10;
  bool has_utilizationrate() const;
  private:
  bool _internal_has_utilizationrate() const;
  public:
  void clear_utilizationrate();
  double utilizationrate() const;
  void set_utilizationrate(double value);
  private:
  double _internal_utilizationrate() const;
  void _internal_set_utilizationrate(double value);
  public:

  // optional bool mciConvergenceMet = 6;
  bool has_mciconvergencemet() const;
  private:
  bool _internal_has_mciconvergencemet() const;
  public:
  void clear_mciconvergencemet();
  bool mciconvergencemet() const;
  void set_mciconvergencemet(bool value);
  private:
  bool _internal_mciconvergencemet() const;
  void _internal_set_mciconvergencemet(bool value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmRobot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::EgmHeader* header_;
  ::abb::egm::EgmFeedBack* feedback_;
  ::abb::egm::EgmPlanned* planned_;
  ::abb::egm::EgmMotorState* motorstate_;
  ::abb::egm::EgmMCIState* mcistate_;
  ::abb::egm::EgmTestSignals* testsignals_;
  ::abb::egm::EgmRapidCtrlExecState* rapidexecstate_;
  ::abb::egm::EgmMeasuredForce* measuredforce_;
  double utilizationrate_;
  bool mciconvergencemet_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmSensor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmSensor) */ {
 public:
  inline EgmSensor() : EgmSensor(nullptr) {}
  virtual ~EgmSensor();

  EgmSensor(const EgmSensor& from);
  EgmSensor(EgmSensor&& from) noexcept
    : EgmSensor() {
    *this = ::std::move(from);
  }

  inline EgmSensor& operator=(const EgmSensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmSensor& operator=(EgmSensor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmSensor& default_instance();

  static inline const EgmSensor* internal_default_instance() {
    return reinterpret_cast<const EgmSensor*>(
               &_EgmSensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(EgmSensor& a, EgmSensor& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmSensor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmSensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmSensor* New() const final {
    return CreateMaybeMessage<EgmSensor>(nullptr);
  }

  EgmSensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmSensor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmSensor& from);
  void MergeFrom(const EgmSensor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmSensor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmSensor";
  }
  protected:
  explicit EgmSensor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPlannedFieldNumber = 2,
    kSpeedRefFieldNumber = 3,
  };
  // optional .abb.egm.EgmHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::abb::egm::EgmHeader& header() const;
  ::abb::egm::EgmHeader* release_header();
  ::abb::egm::EgmHeader* mutable_header();
  void set_allocated_header(::abb::egm::EgmHeader* header);
  private:
  const ::abb::egm::EgmHeader& _internal_header() const;
  ::abb::egm::EgmHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::abb::egm::EgmHeader* header);
  ::abb::egm::EgmHeader* unsafe_arena_release_header();

  // optional .abb.egm.EgmPlanned planned = 2;
  bool has_planned() const;
  private:
  bool _internal_has_planned() const;
  public:
  void clear_planned();
  const ::abb::egm::EgmPlanned& planned() const;
  ::abb::egm::EgmPlanned* release_planned();
  ::abb::egm::EgmPlanned* mutable_planned();
  void set_allocated_planned(::abb::egm::EgmPlanned* planned);
  private:
  const ::abb::egm::EgmPlanned& _internal_planned() const;
  ::abb::egm::EgmPlanned* _internal_mutable_planned();
  public:
  void unsafe_arena_set_allocated_planned(
      ::abb::egm::EgmPlanned* planned);
  ::abb::egm::EgmPlanned* unsafe_arena_release_planned();

  // optional .abb.egm.EgmSpeedRef speedRef = 3;
  bool has_speedref() const;
  private:
  bool _internal_has_speedref() const;
  public:
  void clear_speedref();
  const ::abb::egm::EgmSpeedRef& speedref() const;
  ::abb::egm::EgmSpeedRef* release_speedref();
  ::abb::egm::EgmSpeedRef* mutable_speedref();
  void set_allocated_speedref(::abb::egm::EgmSpeedRef* speedref);
  private:
  const ::abb::egm::EgmSpeedRef& _internal_speedref() const;
  ::abb::egm::EgmSpeedRef* _internal_mutable_speedref();
  public:
  void unsafe_arena_set_allocated_speedref(
      ::abb::egm::EgmSpeedRef* speedref);
  ::abb::egm::EgmSpeedRef* unsafe_arena_release_speedref();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmSensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::EgmHeader* header_;
  ::abb::egm::EgmPlanned* planned_;
  ::abb::egm::EgmSpeedRef* speedref_;
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmSensorPathCorr PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmSensorPathCorr) */ {
 public:
  inline EgmSensorPathCorr() : EgmSensorPathCorr(nullptr) {}
  virtual ~EgmSensorPathCorr();

  EgmSensorPathCorr(const EgmSensorPathCorr& from);
  EgmSensorPathCorr(EgmSensorPathCorr&& from) noexcept
    : EgmSensorPathCorr() {
    *this = ::std::move(from);
  }

  inline EgmSensorPathCorr& operator=(const EgmSensorPathCorr& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmSensorPathCorr& operator=(EgmSensorPathCorr&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EgmSensorPathCorr& default_instance();

  static inline const EgmSensorPathCorr* internal_default_instance() {
    return reinterpret_cast<const EgmSensorPathCorr*>(
               &_EgmSensorPathCorr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(EgmSensorPathCorr& a, EgmSensorPathCorr& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmSensorPathCorr* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmSensorPathCorr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EgmSensorPathCorr* New() const final {
    return CreateMaybeMessage<EgmSensorPathCorr>(nullptr);
  }

  EgmSensorPathCorr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EgmSensorPathCorr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EgmSensorPathCorr& from);
  void MergeFrom(const EgmSensorPathCorr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmSensorPathCorr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmSensorPathCorr";
  }
  protected:
  explicit EgmSensorPathCorr(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_egm_2eproto);
    return ::descriptor_table_egm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPathCorrFieldNumber = 2,
  };
  // optional .abb.egm.EgmHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::abb::egm::EgmHeader& header() const;
  ::abb::egm::EgmHeader* release_header();
  ::abb::egm::EgmHeader* mutable_header();
  void set_allocated_header(::abb::egm::EgmHeader* header);
  private:
  const ::abb::egm::EgmHeader& _internal_header() const;
  ::abb::egm::EgmHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::abb::egm::EgmHeader* header);
  ::abb::egm::EgmHeader* unsafe_arena_release_header();

  // optional .abb.egm.EgmPathCorr pathCorr = 2;
  bool has_pathcorr() const;
  private:
  bool _internal_has_pathcorr() const;
  public:
  void clear_pathcorr();
  const ::abb::egm::EgmPathCorr& pathcorr() const;
  ::abb::egm::EgmPathCorr* release_pathcorr();
  ::abb::egm::EgmPathCorr* mutable_pathcorr();
  void set_allocated_pathcorr(::abb::egm::EgmPathCorr* pathcorr);
  private:
  const ::abb::egm::EgmPathCorr& _internal_pathcorr() const;
  ::abb::egm::EgmPathCorr* _internal_mutable_pathcorr();
  public:
  void unsafe_arena_set_allocated_pathcorr(
      ::abb::egm::EgmPathCorr* pathcorr);
  ::abb::egm::EgmPathCorr* unsafe_arena_release_pathcorr();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmSensorPathCorr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::abb::egm::EgmHeader* header_;
  ::abb::egm::EgmPathCorr* pathcorr_;
  friend struct ::TableStruct_egm_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EgmHeader

// optional uint32 seqno = 1;
inline bool EgmHeader::_internal_has_seqno() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmHeader::has_seqno() const {
  return _internal_has_seqno();
}
inline void EgmHeader::clear_seqno() {
  seqno_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EgmHeader::_internal_seqno() const {
  return seqno_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EgmHeader::seqno() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmHeader.seqno)
  return _internal_seqno();
}
inline void EgmHeader::_internal_set_seqno(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  seqno_ = value;
}
inline void EgmHeader::set_seqno(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmHeader.seqno)
}

// optional uint32 tm = 2;
inline bool EgmHeader::_internal_has_tm() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EgmHeader::has_tm() const {
  return _internal_has_tm();
}
inline void EgmHeader::clear_tm() {
  tm_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EgmHeader::_internal_tm() const {
  return tm_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EgmHeader::tm() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmHeader.tm)
  return _internal_tm();
}
inline void EgmHeader::_internal_set_tm(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  tm_ = value;
}
inline void EgmHeader::set_tm(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tm(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmHeader.tm)
}

// optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
inline bool EgmHeader::_internal_has_mtype() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EgmHeader::has_mtype() const {
  return _internal_has_mtype();
}
inline void EgmHeader::clear_mtype() {
  mtype_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::abb::egm::EgmHeader_MessageType EgmHeader::_internal_mtype() const {
  return static_cast< ::abb::egm::EgmHeader_MessageType >(mtype_);
}
inline ::abb::egm::EgmHeader_MessageType EgmHeader::mtype() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmHeader.mtype)
  return _internal_mtype();
}
inline void EgmHeader::_internal_set_mtype(::abb::egm::EgmHeader_MessageType value) {
  assert(::abb::egm::EgmHeader_MessageType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  mtype_ = value;
}
inline void EgmHeader::set_mtype(::abb::egm::EgmHeader_MessageType value) {
  _internal_set_mtype(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmHeader.mtype)
}

// -------------------------------------------------------------------

// EgmCartesian

// required double x = 1;
inline bool EgmCartesian::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmCartesian::has_x() const {
  return _internal_has_x();
}
inline void EgmCartesian::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double EgmCartesian::_internal_x() const {
  return x_;
}
inline double EgmCartesian::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesian.x)
  return _internal_x();
}
inline void EgmCartesian::_internal_set_x(double value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void EgmCartesian::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesian.x)
}

// required double y = 2;
inline bool EgmCartesian::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EgmCartesian::has_y() const {
  return _internal_has_y();
}
inline void EgmCartesian::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double EgmCartesian::_internal_y() const {
  return y_;
}
inline double EgmCartesian::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesian.y)
  return _internal_y();
}
inline void EgmCartesian::_internal_set_y(double value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void EgmCartesian::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesian.y)
}

// required double z = 3;
inline bool EgmCartesian::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EgmCartesian::has_z() const {
  return _internal_has_z();
}
inline void EgmCartesian::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double EgmCartesian::_internal_z() const {
  return z_;
}
inline double EgmCartesian::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesian.z)
  return _internal_z();
}
inline void EgmCartesian::_internal_set_z(double value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void EgmCartesian::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesian.z)
}

// -------------------------------------------------------------------

// EgmQuaternion

// required double u0 = 1;
inline bool EgmQuaternion::_internal_has_u0() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmQuaternion::has_u0() const {
  return _internal_has_u0();
}
inline void EgmQuaternion::clear_u0() {
  u0_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double EgmQuaternion::_internal_u0() const {
  return u0_;
}
inline double EgmQuaternion::u0() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u0)
  return _internal_u0();
}
inline void EgmQuaternion::_internal_set_u0(double value) {
  _has_bits_[0] |= 0x00000001u;
  u0_ = value;
}
inline void EgmQuaternion::set_u0(double value) {
  _internal_set_u0(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u0)
}

// required double u1 = 2;
inline bool EgmQuaternion::_internal_has_u1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EgmQuaternion::has_u1() const {
  return _internal_has_u1();
}
inline void EgmQuaternion::clear_u1() {
  u1_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double EgmQuaternion::_internal_u1() const {
  return u1_;
}
inline double EgmQuaternion::u1() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u1)
  return _internal_u1();
}
inline void EgmQuaternion::_internal_set_u1(double value) {
  _has_bits_[0] |= 0x00000002u;
  u1_ = value;
}
inline void EgmQuaternion::set_u1(double value) {
  _internal_set_u1(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u1)
}

// required double u2 = 3;
inline bool EgmQuaternion::_internal_has_u2() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EgmQuaternion::has_u2() const {
  return _internal_has_u2();
}
inline void EgmQuaternion::clear_u2() {
  u2_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double EgmQuaternion::_internal_u2() const {
  return u2_;
}
inline double EgmQuaternion::u2() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u2)
  return _internal_u2();
}
inline void EgmQuaternion::_internal_set_u2(double value) {
  _has_bits_[0] |= 0x00000004u;
  u2_ = value;
}
inline void EgmQuaternion::set_u2(double value) {
  _internal_set_u2(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u2)
}

// required double u3 = 4;
inline bool EgmQuaternion::_internal_has_u3() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EgmQuaternion::has_u3() const {
  return _internal_has_u3();
}
inline void EgmQuaternion::clear_u3() {
  u3_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double EgmQuaternion::_internal_u3() const {
  return u3_;
}
inline double EgmQuaternion::u3() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u3)
  return _internal_u3();
}
inline void EgmQuaternion::_internal_set_u3(double value) {
  _has_bits_[0] |= 0x00000008u;
  u3_ = value;
}
inline void EgmQuaternion::set_u3(double value) {
  _internal_set_u3(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u3)
}

// -------------------------------------------------------------------

// EgmEuler

// required double x = 1;
inline bool EgmEuler::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmEuler::has_x() const {
  return _internal_has_x();
}
inline void EgmEuler::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double EgmEuler::_internal_x() const {
  return x_;
}
inline double EgmEuler::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmEuler.x)
  return _internal_x();
}
inline void EgmEuler::_internal_set_x(double value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void EgmEuler::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmEuler.x)
}

// required double y = 2;
inline bool EgmEuler::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EgmEuler::has_y() const {
  return _internal_has_y();
}
inline void EgmEuler::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double EgmEuler::_internal_y() const {
  return y_;
}
inline double EgmEuler::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmEuler.y)
  return _internal_y();
}
inline void EgmEuler::_internal_set_y(double value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void EgmEuler::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmEuler.y)
}

// required double z = 3;
inline bool EgmEuler::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EgmEuler::has_z() const {
  return _internal_has_z();
}
inline void EgmEuler::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double EgmEuler::_internal_z() const {
  return z_;
}
inline double EgmEuler::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmEuler.z)
  return _internal_z();
}
inline void EgmEuler::_internal_set_z(double value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void EgmEuler::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmEuler.z)
}

// -------------------------------------------------------------------

// EgmClock

// required uint64 sec = 1;
inline bool EgmClock::_internal_has_sec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmClock::has_sec() const {
  return _internal_has_sec();
}
inline void EgmClock::clear_sec() {
  sec_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EgmClock::_internal_sec() const {
  return sec_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EgmClock::sec() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmClock.sec)
  return _internal_sec();
}
inline void EgmClock::_internal_set_sec(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  sec_ = value;
}
inline void EgmClock::set_sec(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sec(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmClock.sec)
}

// required uint64 usec = 2;
inline bool EgmClock::_internal_has_usec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EgmClock::has_usec() const {
  return _internal_has_usec();
}
inline void EgmClock::clear_usec() {
  usec_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EgmClock::_internal_usec() const {
  return usec_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EgmClock::usec() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmClock.usec)
  return _internal_usec();
}
inline void EgmClock::_internal_set_usec(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  usec_ = value;
}
inline void EgmClock::set_usec(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_usec(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmClock.usec)
}

// -------------------------------------------------------------------

// EgmPose

// optional .abb.egm.EgmCartesian pos = 1;
inline bool EgmPose::_internal_has_pos() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || pos_ != nullptr);
  return value;
}
inline bool EgmPose::has_pos() const {
  return _internal_has_pos();
}
inline void EgmPose::clear_pos() {
  if (pos_ != nullptr) pos_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmCartesian& EgmPose::_internal_pos() const {
  const ::abb::egm::EgmCartesian* p = pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmCartesian&>(
      ::abb::egm::_EgmCartesian_default_instance_);
}
inline const ::abb::egm::EgmCartesian& EgmPose::pos() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPose.pos)
  return _internal_pos();
}
inline void EgmPose::unsafe_arena_set_allocated_pos(
    ::abb::egm::EgmCartesian* pos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPose.pos)
}
inline ::abb::egm::EgmCartesian* EgmPose::release_pos() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmCartesian* temp = pos_;
  pos_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmCartesian* EgmPose::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPose.pos)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmCartesian* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmCartesian* EgmPose::_internal_mutable_pos() {
  _has_bits_[0] |= 0x00000001u;
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmCartesian>(GetArena());
    pos_ = p;
  }
  return pos_;
}
inline ::abb::egm::EgmCartesian* EgmPose::mutable_pos() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPose.pos)
  return _internal_mutable_pos();
}
inline void EgmPose::set_allocated_pos(::abb::egm::EgmCartesian* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPose.pos)
}

// optional .abb.egm.EgmQuaternion orient = 2;
inline bool EgmPose::_internal_has_orient() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || orient_ != nullptr);
  return value;
}
inline bool EgmPose::has_orient() const {
  return _internal_has_orient();
}
inline void EgmPose::clear_orient() {
  if (orient_ != nullptr) orient_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmQuaternion& EgmPose::_internal_orient() const {
  const ::abb::egm::EgmQuaternion* p = orient_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmQuaternion&>(
      ::abb::egm::_EgmQuaternion_default_instance_);
}
inline const ::abb::egm::EgmQuaternion& EgmPose::orient() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPose.orient)
  return _internal_orient();
}
inline void EgmPose::unsafe_arena_set_allocated_orient(
    ::abb::egm::EgmQuaternion* orient) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orient_);
  }
  orient_ = orient;
  if (orient) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPose.orient)
}
inline ::abb::egm::EgmQuaternion* EgmPose::release_orient() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmQuaternion* temp = orient_;
  orient_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmQuaternion* EgmPose::unsafe_arena_release_orient() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPose.orient)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmQuaternion* temp = orient_;
  orient_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmQuaternion* EgmPose::_internal_mutable_orient() {
  _has_bits_[0] |= 0x00000002u;
  if (orient_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmQuaternion>(GetArena());
    orient_ = p;
  }
  return orient_;
}
inline ::abb::egm::EgmQuaternion* EgmPose::mutable_orient() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPose.orient)
  return _internal_mutable_orient();
}
inline void EgmPose::set_allocated_orient(::abb::egm::EgmQuaternion* orient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete orient_;
  }
  if (orient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(orient);
    if (message_arena != submessage_arena) {
      orient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orient, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  orient_ = orient;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPose.orient)
}

// optional .abb.egm.EgmEuler euler = 3;
inline bool EgmPose::_internal_has_euler() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || euler_ != nullptr);
  return value;
}
inline bool EgmPose::has_euler() const {
  return _internal_has_euler();
}
inline void EgmPose::clear_euler() {
  if (euler_ != nullptr) euler_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmEuler& EgmPose::_internal_euler() const {
  const ::abb::egm::EgmEuler* p = euler_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmEuler&>(
      ::abb::egm::_EgmEuler_default_instance_);
}
inline const ::abb::egm::EgmEuler& EgmPose::euler() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPose.euler)
  return _internal_euler();
}
inline void EgmPose::unsafe_arena_set_allocated_euler(
    ::abb::egm::EgmEuler* euler) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(euler_);
  }
  euler_ = euler;
  if (euler) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPose.euler)
}
inline ::abb::egm::EgmEuler* EgmPose::release_euler() {
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmEuler* temp = euler_;
  euler_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmEuler* EgmPose::unsafe_arena_release_euler() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPose.euler)
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmEuler* temp = euler_;
  euler_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmEuler* EgmPose::_internal_mutable_euler() {
  _has_bits_[0] |= 0x00000004u;
  if (euler_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmEuler>(GetArena());
    euler_ = p;
  }
  return euler_;
}
inline ::abb::egm::EgmEuler* EgmPose::mutable_euler() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPose.euler)
  return _internal_mutable_euler();
}
inline void EgmPose::set_allocated_euler(::abb::egm::EgmEuler* euler) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete euler_;
  }
  if (euler) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(euler);
    if (message_arena != submessage_arena) {
      euler = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, euler, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  euler_ = euler;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPose.euler)
}

// -------------------------------------------------------------------

// EgmCartesianSpeed

// repeated double value = 1;
inline int EgmCartesianSpeed::_internal_value_size() const {
  return value_.size();
}
inline int EgmCartesianSpeed::value_size() const {
  return _internal_value_size();
}
inline void EgmCartesianSpeed::clear_value() {
  value_.Clear();
}
inline double EgmCartesianSpeed::_internal_value(int index) const {
  return value_.Get(index);
}
inline double EgmCartesianSpeed::value(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesianSpeed.value)
  return _internal_value(index);
}
inline void EgmCartesianSpeed::set_value(int index, double value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesianSpeed.value)
}
inline void EgmCartesianSpeed::_internal_add_value(double value) {
  value_.Add(value);
}
inline void EgmCartesianSpeed::add_value(double value) {
  _internal_add_value(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmCartesianSpeed.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmCartesianSpeed::_internal_value() const {
  return value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmCartesianSpeed::value() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmCartesianSpeed.value)
  return _internal_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmCartesianSpeed::_internal_mutable_value() {
  return &value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmCartesianSpeed::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmCartesianSpeed.value)
  return _internal_mutable_value();
}

// -------------------------------------------------------------------

// EgmJoints

// repeated double joints = 1;
inline int EgmJoints::_internal_joints_size() const {
  return joints_.size();
}
inline int EgmJoints::joints_size() const {
  return _internal_joints_size();
}
inline void EgmJoints::clear_joints() {
  joints_.Clear();
}
inline double EgmJoints::_internal_joints(int index) const {
  return joints_.Get(index);
}
inline double EgmJoints::joints(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmJoints.joints)
  return _internal_joints(index);
}
inline void EgmJoints::set_joints(int index, double value) {
  joints_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmJoints.joints)
}
inline void EgmJoints::_internal_add_joints(double value) {
  joints_.Add(value);
}
inline void EgmJoints::add_joints(double value) {
  _internal_add_joints(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmJoints.joints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmJoints::_internal_joints() const {
  return joints_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmJoints::joints() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmJoints.joints)
  return _internal_joints();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmJoints::_internal_mutable_joints() {
  return &joints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmJoints::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmJoints.joints)
  return _internal_mutable_joints();
}

// -------------------------------------------------------------------

// EgmExternalJoints

// repeated double joints = 1;
inline int EgmExternalJoints::_internal_joints_size() const {
  return joints_.size();
}
inline int EgmExternalJoints::joints_size() const {
  return _internal_joints_size();
}
inline void EgmExternalJoints::clear_joints() {
  joints_.Clear();
}
inline double EgmExternalJoints::_internal_joints(int index) const {
  return joints_.Get(index);
}
inline double EgmExternalJoints::joints(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmExternalJoints.joints)
  return _internal_joints(index);
}
inline void EgmExternalJoints::set_joints(int index, double value) {
  joints_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmExternalJoints.joints)
}
inline void EgmExternalJoints::_internal_add_joints(double value) {
  joints_.Add(value);
}
inline void EgmExternalJoints::add_joints(double value) {
  _internal_add_joints(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmExternalJoints.joints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmExternalJoints::_internal_joints() const {
  return joints_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmExternalJoints::joints() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmExternalJoints.joints)
  return _internal_joints();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmExternalJoints::_internal_mutable_joints() {
  return &joints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmExternalJoints::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmExternalJoints.joints)
  return _internal_mutable_joints();
}

// -------------------------------------------------------------------

// EgmPlanned

// optional .abb.egm.EgmJoints joints = 1;
inline bool EgmPlanned::_internal_has_joints() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || joints_ != nullptr);
  return value;
}
inline bool EgmPlanned::has_joints() const {
  return _internal_has_joints();
}
inline void EgmPlanned::clear_joints() {
  if (joints_ != nullptr) joints_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmJoints& EgmPlanned::_internal_joints() const {
  const ::abb::egm::EgmJoints* p = joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(
      ::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmPlanned::joints() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.joints)
  return _internal_joints();
}
inline void EgmPlanned::unsafe_arena_set_allocated_joints(
    ::abb::egm::EgmJoints* joints) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(joints_);
  }
  joints_ = joints;
  if (joints) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPlanned.joints)
}
inline ::abb::egm::EgmJoints* EgmPlanned::release_joints() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = joints_;
  joints_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmJoints* EgmPlanned::unsafe_arena_release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.joints)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = joints_;
  joints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmPlanned::_internal_mutable_joints() {
  _has_bits_[0] |= 0x00000001u;
  if (joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArena());
    joints_ = p;
  }
  return joints_;
}
inline ::abb::egm::EgmJoints* EgmPlanned::mutable_joints() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.joints)
  return _internal_mutable_joints();
}
inline void EgmPlanned::set_allocated_joints(::abb::egm::EgmJoints* joints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete joints_;
  }
  if (joints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(joints);
    if (message_arena != submessage_arena) {
      joints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joints, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  joints_ = joints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.joints)
}

// optional .abb.egm.EgmPose cartesian = 2;
inline bool EgmPlanned::_internal_has_cartesian() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || cartesian_ != nullptr);
  return value;
}
inline bool EgmPlanned::has_cartesian() const {
  return _internal_has_cartesian();
}
inline void EgmPlanned::clear_cartesian() {
  if (cartesian_ != nullptr) cartesian_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmPose& EgmPlanned::_internal_cartesian() const {
  const ::abb::egm::EgmPose* p = cartesian_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPose&>(
      ::abb::egm::_EgmPose_default_instance_);
}
inline const ::abb::egm::EgmPose& EgmPlanned::cartesian() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.cartesian)
  return _internal_cartesian();
}
inline void EgmPlanned::unsafe_arena_set_allocated_cartesian(
    ::abb::egm::EgmPose* cartesian) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cartesian_);
  }
  cartesian_ = cartesian;
  if (cartesian) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPlanned.cartesian)
}
inline ::abb::egm::EgmPose* EgmPlanned::release_cartesian() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPose* temp = cartesian_;
  cartesian_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmPose* EgmPlanned::unsafe_arena_release_cartesian() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.cartesian)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPose* temp = cartesian_;
  cartesian_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPose* EgmPlanned::_internal_mutable_cartesian() {
  _has_bits_[0] |= 0x00000002u;
  if (cartesian_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPose>(GetArena());
    cartesian_ = p;
  }
  return cartesian_;
}
inline ::abb::egm::EgmPose* EgmPlanned::mutable_cartesian() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.cartesian)
  return _internal_mutable_cartesian();
}
inline void EgmPlanned::set_allocated_cartesian(::abb::egm::EgmPose* cartesian) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cartesian_;
  }
  if (cartesian) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cartesian);
    if (message_arena != submessage_arena) {
      cartesian = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cartesian, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cartesian_ = cartesian;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.cartesian)
}

// optional .abb.egm.EgmJoints externalJoints = 3;
inline bool EgmPlanned::_internal_has_externaljoints() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || externaljoints_ != nullptr);
  return value;
}
inline bool EgmPlanned::has_externaljoints() const {
  return _internal_has_externaljoints();
}
inline void EgmPlanned::clear_externaljoints() {
  if (externaljoints_ != nullptr) externaljoints_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmJoints& EgmPlanned::_internal_externaljoints() const {
  const ::abb::egm::EgmJoints* p = externaljoints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(
      ::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmPlanned::externaljoints() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.externalJoints)
  return _internal_externaljoints();
}
inline void EgmPlanned::unsafe_arena_set_allocated_externaljoints(
    ::abb::egm::EgmJoints* externaljoints) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(externaljoints_);
  }
  externaljoints_ = externaljoints;
  if (externaljoints) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPlanned.externalJoints)
}
inline ::abb::egm::EgmJoints* EgmPlanned::release_externaljoints() {
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = externaljoints_;
  externaljoints_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmJoints* EgmPlanned::unsafe_arena_release_externaljoints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.externalJoints)
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = externaljoints_;
  externaljoints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmPlanned::_internal_mutable_externaljoints() {
  _has_bits_[0] |= 0x00000004u;
  if (externaljoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArena());
    externaljoints_ = p;
  }
  return externaljoints_;
}
inline ::abb::egm::EgmJoints* EgmPlanned::mutable_externaljoints() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.externalJoints)
  return _internal_mutable_externaljoints();
}
inline void EgmPlanned::set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete externaljoints_;
  }
  if (externaljoints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(externaljoints);
    if (message_arena != submessage_arena) {
      externaljoints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, externaljoints, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  externaljoints_ = externaljoints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.externalJoints)
}

// optional .abb.egm.EgmClock time = 4;
inline bool EgmPlanned::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || time_ != nullptr);
  return value;
}
inline bool EgmPlanned::has_time() const {
  return _internal_has_time();
}
inline void EgmPlanned::clear_time() {
  if (time_ != nullptr) time_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::egm::EgmClock& EgmPlanned::_internal_time() const {
  const ::abb::egm::EgmClock* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmClock&>(
      ::abb::egm::_EgmClock_default_instance_);
}
inline const ::abb::egm::EgmClock& EgmPlanned::time() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.time)
  return _internal_time();
}
inline void EgmPlanned::unsafe_arena_set_allocated_time(
    ::abb::egm::EgmClock* time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPlanned.time)
}
inline ::abb::egm::EgmClock* EgmPlanned::release_time() {
  _has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmClock* temp = time_;
  time_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmClock* EgmPlanned::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.time)
  _has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmClock* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmClock* EgmPlanned::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000008u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmClock>(GetArena());
    time_ = p;
  }
  return time_;
}
inline ::abb::egm::EgmClock* EgmPlanned::mutable_time() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.time)
  return _internal_mutable_time();
}
inline void EgmPlanned::set_allocated_time(::abb::egm::EgmClock* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete time_;
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(time);
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.time)
}

// -------------------------------------------------------------------

// EgmSpeedRef

// optional .abb.egm.EgmJoints joints = 1;
inline bool EgmSpeedRef::_internal_has_joints() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || joints_ != nullptr);
  return value;
}
inline bool EgmSpeedRef::has_joints() const {
  return _internal_has_joints();
}
inline void EgmSpeedRef::clear_joints() {
  if (joints_ != nullptr) joints_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmJoints& EgmSpeedRef::_internal_joints() const {
  const ::abb::egm::EgmJoints* p = joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(
      ::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmSpeedRef::joints() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSpeedRef.joints)
  return _internal_joints();
}
inline void EgmSpeedRef::unsafe_arena_set_allocated_joints(
    ::abb::egm::EgmJoints* joints) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(joints_);
  }
  joints_ = joints;
  if (joints) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSpeedRef.joints)
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::release_joints() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = joints_;
  joints_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::unsafe_arena_release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSpeedRef.joints)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = joints_;
  joints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::_internal_mutable_joints() {
  _has_bits_[0] |= 0x00000001u;
  if (joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArena());
    joints_ = p;
  }
  return joints_;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::mutable_joints() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSpeedRef.joints)
  return _internal_mutable_joints();
}
inline void EgmSpeedRef::set_allocated_joints(::abb::egm::EgmJoints* joints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete joints_;
  }
  if (joints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(joints);
    if (message_arena != submessage_arena) {
      joints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joints, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  joints_ = joints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSpeedRef.joints)
}

// optional .abb.egm.EgmCartesianSpeed cartesians = 2;
inline bool EgmSpeedRef::_internal_has_cartesians() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || cartesians_ != nullptr);
  return value;
}
inline bool EgmSpeedRef::has_cartesians() const {
  return _internal_has_cartesians();
}
inline void EgmSpeedRef::clear_cartesians() {
  if (cartesians_ != nullptr) cartesians_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmCartesianSpeed& EgmSpeedRef::_internal_cartesians() const {
  const ::abb::egm::EgmCartesianSpeed* p = cartesians_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmCartesianSpeed&>(
      ::abb::egm::_EgmCartesianSpeed_default_instance_);
}
inline const ::abb::egm::EgmCartesianSpeed& EgmSpeedRef::cartesians() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSpeedRef.cartesians)
  return _internal_cartesians();
}
inline void EgmSpeedRef::unsafe_arena_set_allocated_cartesians(
    ::abb::egm::EgmCartesianSpeed* cartesians) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cartesians_);
  }
  cartesians_ = cartesians;
  if (cartesians) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSpeedRef.cartesians)
}
inline ::abb::egm::EgmCartesianSpeed* EgmSpeedRef::release_cartesians() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmCartesianSpeed* temp = cartesians_;
  cartesians_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmCartesianSpeed* EgmSpeedRef::unsafe_arena_release_cartesians() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSpeedRef.cartesians)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmCartesianSpeed* temp = cartesians_;
  cartesians_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmCartesianSpeed* EgmSpeedRef::_internal_mutable_cartesians() {
  _has_bits_[0] |= 0x00000002u;
  if (cartesians_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmCartesianSpeed>(GetArena());
    cartesians_ = p;
  }
  return cartesians_;
}
inline ::abb::egm::EgmCartesianSpeed* EgmSpeedRef::mutable_cartesians() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSpeedRef.cartesians)
  return _internal_mutable_cartesians();
}
inline void EgmSpeedRef::set_allocated_cartesians(::abb::egm::EgmCartesianSpeed* cartesians) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cartesians_;
  }
  if (cartesians) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cartesians);
    if (message_arena != submessage_arena) {
      cartesians = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cartesians, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cartesians_ = cartesians;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSpeedRef.cartesians)
}

// optional .abb.egm.EgmJoints externalJoints = 3;
inline bool EgmSpeedRef::_internal_has_externaljoints() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || externaljoints_ != nullptr);
  return value;
}
inline bool EgmSpeedRef::has_externaljoints() const {
  return _internal_has_externaljoints();
}
inline void EgmSpeedRef::clear_externaljoints() {
  if (externaljoints_ != nullptr) externaljoints_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmJoints& EgmSpeedRef::_internal_externaljoints() const {
  const ::abb::egm::EgmJoints* p = externaljoints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(
      ::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmSpeedRef::externaljoints() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSpeedRef.externalJoints)
  return _internal_externaljoints();
}
inline void EgmSpeedRef::unsafe_arena_set_allocated_externaljoints(
    ::abb::egm::EgmJoints* externaljoints) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(externaljoints_);
  }
  externaljoints_ = externaljoints;
  if (externaljoints) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSpeedRef.externalJoints)
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::release_externaljoints() {
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = externaljoints_;
  externaljoints_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::unsafe_arena_release_externaljoints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSpeedRef.externalJoints)
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = externaljoints_;
  externaljoints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::_internal_mutable_externaljoints() {
  _has_bits_[0] |= 0x00000004u;
  if (externaljoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArena());
    externaljoints_ = p;
  }
  return externaljoints_;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::mutable_externaljoints() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSpeedRef.externalJoints)
  return _internal_mutable_externaljoints();
}
inline void EgmSpeedRef::set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete externaljoints_;
  }
  if (externaljoints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(externaljoints);
    if (message_arena != submessage_arena) {
      externaljoints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, externaljoints, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  externaljoints_ = externaljoints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSpeedRef.externalJoints)
}

// -------------------------------------------------------------------

// EgmPathCorr

// required .abb.egm.EgmCartesian pos = 1;
inline bool EgmPathCorr::_internal_has_pos() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || pos_ != nullptr);
  return value;
}
inline bool EgmPathCorr::has_pos() const {
  return _internal_has_pos();
}
inline void EgmPathCorr::clear_pos() {
  if (pos_ != nullptr) pos_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmCartesian& EgmPathCorr::_internal_pos() const {
  const ::abb::egm::EgmCartesian* p = pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmCartesian&>(
      ::abb::egm::_EgmCartesian_default_instance_);
}
inline const ::abb::egm::EgmCartesian& EgmPathCorr::pos() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPathCorr.pos)
  return _internal_pos();
}
inline void EgmPathCorr::unsafe_arena_set_allocated_pos(
    ::abb::egm::EgmCartesian* pos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPathCorr.pos)
}
inline ::abb::egm::EgmCartesian* EgmPathCorr::release_pos() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmCartesian* temp = pos_;
  pos_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmCartesian* EgmPathCorr::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPathCorr.pos)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmCartesian* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmCartesian* EgmPathCorr::_internal_mutable_pos() {
  _has_bits_[0] |= 0x00000001u;
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmCartesian>(GetArena());
    pos_ = p;
  }
  return pos_;
}
inline ::abb::egm::EgmCartesian* EgmPathCorr::mutable_pos() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPathCorr.pos)
  return _internal_mutable_pos();
}
inline void EgmPathCorr::set_allocated_pos(::abb::egm::EgmCartesian* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPathCorr.pos)
}

// required uint32 age = 2;
inline bool EgmPathCorr::_internal_has_age() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EgmPathCorr::has_age() const {
  return _internal_has_age();
}
inline void EgmPathCorr::clear_age() {
  age_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EgmPathCorr::_internal_age() const {
  return age_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EgmPathCorr::age() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPathCorr.age)
  return _internal_age();
}
inline void EgmPathCorr::_internal_set_age(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  age_ = value;
}
inline void EgmPathCorr::set_age(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_age(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmPathCorr.age)
}

// -------------------------------------------------------------------

// EgmFeedBack

// optional .abb.egm.EgmJoints joints = 1;
inline bool EgmFeedBack::_internal_has_joints() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || joints_ != nullptr);
  return value;
}
inline bool EgmFeedBack::has_joints() const {
  return _internal_has_joints();
}
inline void EgmFeedBack::clear_joints() {
  if (joints_ != nullptr) joints_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmJoints& EgmFeedBack::_internal_joints() const {
  const ::abb::egm::EgmJoints* p = joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(
      ::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmFeedBack::joints() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.joints)
  return _internal_joints();
}
inline void EgmFeedBack::unsafe_arena_set_allocated_joints(
    ::abb::egm::EgmJoints* joints) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(joints_);
  }
  joints_ = joints;
  if (joints) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmFeedBack.joints)
}
inline ::abb::egm::EgmJoints* EgmFeedBack::release_joints() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = joints_;
  joints_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::unsafe_arena_release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.joints)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = joints_;
  joints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::_internal_mutable_joints() {
  _has_bits_[0] |= 0x00000001u;
  if (joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArena());
    joints_ = p;
  }
  return joints_;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::mutable_joints() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.joints)
  return _internal_mutable_joints();
}
inline void EgmFeedBack::set_allocated_joints(::abb::egm::EgmJoints* joints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete joints_;
  }
  if (joints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(joints);
    if (message_arena != submessage_arena) {
      joints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joints, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  joints_ = joints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.joints)
}

// optional .abb.egm.EgmPose cartesian = 2;
inline bool EgmFeedBack::_internal_has_cartesian() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || cartesian_ != nullptr);
  return value;
}
inline bool EgmFeedBack::has_cartesian() const {
  return _internal_has_cartesian();
}
inline void EgmFeedBack::clear_cartesian() {
  if (cartesian_ != nullptr) cartesian_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmPose& EgmFeedBack::_internal_cartesian() const {
  const ::abb::egm::EgmPose* p = cartesian_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPose&>(
      ::abb::egm::_EgmPose_default_instance_);
}
inline const ::abb::egm::EgmPose& EgmFeedBack::cartesian() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.cartesian)
  return _internal_cartesian();
}
inline void EgmFeedBack::unsafe_arena_set_allocated_cartesian(
    ::abb::egm::EgmPose* cartesian) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cartesian_);
  }
  cartesian_ = cartesian;
  if (cartesian) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmFeedBack.cartesian)
}
inline ::abb::egm::EgmPose* EgmFeedBack::release_cartesian() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPose* temp = cartesian_;
  cartesian_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmPose* EgmFeedBack::unsafe_arena_release_cartesian() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.cartesian)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPose* temp = cartesian_;
  cartesian_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPose* EgmFeedBack::_internal_mutable_cartesian() {
  _has_bits_[0] |= 0x00000002u;
  if (cartesian_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPose>(GetArena());
    cartesian_ = p;
  }
  return cartesian_;
}
inline ::abb::egm::EgmPose* EgmFeedBack::mutable_cartesian() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.cartesian)
  return _internal_mutable_cartesian();
}
inline void EgmFeedBack::set_allocated_cartesian(::abb::egm::EgmPose* cartesian) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cartesian_;
  }
  if (cartesian) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cartesian);
    if (message_arena != submessage_arena) {
      cartesian = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cartesian, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cartesian_ = cartesian;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.cartesian)
}

// optional .abb.egm.EgmJoints externalJoints = 3;
inline bool EgmFeedBack::_internal_has_externaljoints() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || externaljoints_ != nullptr);
  return value;
}
inline bool EgmFeedBack::has_externaljoints() const {
  return _internal_has_externaljoints();
}
inline void EgmFeedBack::clear_externaljoints() {
  if (externaljoints_ != nullptr) externaljoints_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmJoints& EgmFeedBack::_internal_externaljoints() const {
  const ::abb::egm::EgmJoints* p = externaljoints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(
      ::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmFeedBack::externaljoints() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.externalJoints)
  return _internal_externaljoints();
}
inline void EgmFeedBack::unsafe_arena_set_allocated_externaljoints(
    ::abb::egm::EgmJoints* externaljoints) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(externaljoints_);
  }
  externaljoints_ = externaljoints;
  if (externaljoints) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmFeedBack.externalJoints)
}
inline ::abb::egm::EgmJoints* EgmFeedBack::release_externaljoints() {
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = externaljoints_;
  externaljoints_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::unsafe_arena_release_externaljoints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.externalJoints)
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = externaljoints_;
  externaljoints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::_internal_mutable_externaljoints() {
  _has_bits_[0] |= 0x00000004u;
  if (externaljoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArena());
    externaljoints_ = p;
  }
  return externaljoints_;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::mutable_externaljoints() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.externalJoints)
  return _internal_mutable_externaljoints();
}
inline void EgmFeedBack::set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete externaljoints_;
  }
  if (externaljoints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(externaljoints);
    if (message_arena != submessage_arena) {
      externaljoints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, externaljoints, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  externaljoints_ = externaljoints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.externalJoints)
}

// optional .abb.egm.EgmClock time = 4;
inline bool EgmFeedBack::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || time_ != nullptr);
  return value;
}
inline bool EgmFeedBack::has_time() const {
  return _internal_has_time();
}
inline void EgmFeedBack::clear_time() {
  if (time_ != nullptr) time_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::egm::EgmClock& EgmFeedBack::_internal_time() const {
  const ::abb::egm::EgmClock* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmClock&>(
      ::abb::egm::_EgmClock_default_instance_);
}
inline const ::abb::egm::EgmClock& EgmFeedBack::time() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.time)
  return _internal_time();
}
inline void EgmFeedBack::unsafe_arena_set_allocated_time(
    ::abb::egm::EgmClock* time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmFeedBack.time)
}
inline ::abb::egm::EgmClock* EgmFeedBack::release_time() {
  _has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmClock* temp = time_;
  time_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmClock* EgmFeedBack::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.time)
  _has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmClock* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmClock* EgmFeedBack::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000008u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmClock>(GetArena());
    time_ = p;
  }
  return time_;
}
inline ::abb::egm::EgmClock* EgmFeedBack::mutable_time() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.time)
  return _internal_mutable_time();
}
inline void EgmFeedBack::set_allocated_time(::abb::egm::EgmClock* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete time_;
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(time);
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.time)
}

// -------------------------------------------------------------------

// EgmMotorState

// required .abb.egm.EgmMotorState.MotorStateType state = 1;
inline bool EgmMotorState::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmMotorState::has_state() const {
  return _internal_has_state();
}
inline void EgmMotorState::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::abb::egm::EgmMotorState_MotorStateType EgmMotorState::_internal_state() const {
  return static_cast< ::abb::egm::EgmMotorState_MotorStateType >(state_);
}
inline ::abb::egm::EgmMotorState_MotorStateType EgmMotorState::state() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmMotorState.state)
  return _internal_state();
}
inline void EgmMotorState::_internal_set_state(::abb::egm::EgmMotorState_MotorStateType value) {
  assert(::abb::egm::EgmMotorState_MotorStateType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  state_ = value;
}
inline void EgmMotorState::set_state(::abb::egm::EgmMotorState_MotorStateType value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmMotorState.state)
}

// -------------------------------------------------------------------

// EgmMCIState

// required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
inline bool EgmMCIState::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmMCIState::has_state() const {
  return _internal_has_state();
}
inline void EgmMCIState::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::abb::egm::EgmMCIState_MCIStateType EgmMCIState::_internal_state() const {
  return static_cast< ::abb::egm::EgmMCIState_MCIStateType >(state_);
}
inline ::abb::egm::EgmMCIState_MCIStateType EgmMCIState::state() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmMCIState.state)
  return _internal_state();
}
inline void EgmMCIState::_internal_set_state(::abb::egm::EgmMCIState_MCIStateType value) {
  assert(::abb::egm::EgmMCIState_MCIStateType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  state_ = value;
}
inline void EgmMCIState::set_state(::abb::egm::EgmMCIState_MCIStateType value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmMCIState.state)
}

// -------------------------------------------------------------------

// EgmRapidCtrlExecState

// required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
inline bool EgmRapidCtrlExecState::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmRapidCtrlExecState::has_state() const {
  return _internal_has_state();
}
inline void EgmRapidCtrlExecState::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::_internal_state() const {
  return static_cast< ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType >(state_);
}
inline ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::state() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRapidCtrlExecState.state)
  return _internal_state();
}
inline void EgmRapidCtrlExecState::_internal_set_state(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType value) {
  assert(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  state_ = value;
}
inline void EgmRapidCtrlExecState::set_state(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmRapidCtrlExecState.state)
}

// -------------------------------------------------------------------

// EgmTestSignals

// repeated double signals = 1;
inline int EgmTestSignals::_internal_signals_size() const {
  return signals_.size();
}
inline int EgmTestSignals::signals_size() const {
  return _internal_signals_size();
}
inline void EgmTestSignals::clear_signals() {
  signals_.Clear();
}
inline double EgmTestSignals::_internal_signals(int index) const {
  return signals_.Get(index);
}
inline double EgmTestSignals::signals(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmTestSignals.signals)
  return _internal_signals(index);
}
inline void EgmTestSignals::set_signals(int index, double value) {
  signals_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmTestSignals.signals)
}
inline void EgmTestSignals::_internal_add_signals(double value) {
  signals_.Add(value);
}
inline void EgmTestSignals::add_signals(double value) {
  _internal_add_signals(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmTestSignals.signals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmTestSignals::_internal_signals() const {
  return signals_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmTestSignals::signals() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmTestSignals.signals)
  return _internal_signals();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmTestSignals::_internal_mutable_signals() {
  return &signals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmTestSignals::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmTestSignals.signals)
  return _internal_mutable_signals();
}

// -------------------------------------------------------------------

// EgmMeasuredForce

// repeated double force = 1;
inline int EgmMeasuredForce::_internal_force_size() const {
  return force_.size();
}
inline int EgmMeasuredForce::force_size() const {
  return _internal_force_size();
}
inline void EgmMeasuredForce::clear_force() {
  force_.Clear();
}
inline double EgmMeasuredForce::_internal_force(int index) const {
  return force_.Get(index);
}
inline double EgmMeasuredForce::force(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmMeasuredForce.force)
  return _internal_force(index);
}
inline void EgmMeasuredForce::set_force(int index, double value) {
  force_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmMeasuredForce.force)
}
inline void EgmMeasuredForce::_internal_add_force(double value) {
  force_.Add(value);
}
inline void EgmMeasuredForce::add_force(double value) {
  _internal_add_force(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmMeasuredForce.force)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmMeasuredForce::_internal_force() const {
  return force_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmMeasuredForce::force() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmMeasuredForce.force)
  return _internal_force();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmMeasuredForce::_internal_mutable_force() {
  return &force_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmMeasuredForce::mutable_force() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmMeasuredForce.force)
  return _internal_mutable_force();
}

// -------------------------------------------------------------------

// EgmRobot

// optional .abb.egm.EgmHeader header = 1;
inline bool EgmRobot::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool EgmRobot::has_header() const {
  return _internal_has_header();
}
inline void EgmRobot::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmHeader& EgmRobot::_internal_header() const {
  const ::abb::egm::EgmHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmHeader&>(
      ::abb::egm::_EgmHeader_default_instance_);
}
inline const ::abb::egm::EgmHeader& EgmRobot::header() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.header)
  return _internal_header();
}
inline void EgmRobot::unsafe_arena_set_allocated_header(
    ::abb::egm::EgmHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.header)
}
inline ::abb::egm::EgmHeader* EgmRobot::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmHeader* EgmRobot::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.header)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmHeader* EgmRobot::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::abb::egm::EgmHeader* EgmRobot::mutable_header() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.header)
  return _internal_mutable_header();
}
inline void EgmRobot::set_allocated_header(::abb::egm::EgmHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.header)
}

// optional .abb.egm.EgmFeedBack feedBack = 2;
inline bool EgmRobot::_internal_has_feedback() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || feedback_ != nullptr);
  return value;
}
inline bool EgmRobot::has_feedback() const {
  return _internal_has_feedback();
}
inline void EgmRobot::clear_feedback() {
  if (feedback_ != nullptr) feedback_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmFeedBack& EgmRobot::_internal_feedback() const {
  const ::abb::egm::EgmFeedBack* p = feedback_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmFeedBack&>(
      ::abb::egm::_EgmFeedBack_default_instance_);
}
inline const ::abb::egm::EgmFeedBack& EgmRobot::feedback() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.feedBack)
  return _internal_feedback();
}
inline void EgmRobot::unsafe_arena_set_allocated_feedback(
    ::abb::egm::EgmFeedBack* feedback) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(feedback_);
  }
  feedback_ = feedback;
  if (feedback) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.feedBack)
}
inline ::abb::egm::EgmFeedBack* EgmRobot::release_feedback() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmFeedBack* temp = feedback_;
  feedback_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmFeedBack* EgmRobot::unsafe_arena_release_feedback() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.feedBack)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmFeedBack* temp = feedback_;
  feedback_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmFeedBack* EgmRobot::_internal_mutable_feedback() {
  _has_bits_[0] |= 0x00000002u;
  if (feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmFeedBack>(GetArena());
    feedback_ = p;
  }
  return feedback_;
}
inline ::abb::egm::EgmFeedBack* EgmRobot::mutable_feedback() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.feedBack)
  return _internal_mutable_feedback();
}
inline void EgmRobot::set_allocated_feedback(::abb::egm::EgmFeedBack* feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete feedback_;
  }
  if (feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(feedback);
    if (message_arena != submessage_arena) {
      feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feedback, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  feedback_ = feedback;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.feedBack)
}

// optional .abb.egm.EgmPlanned planned = 3;
inline bool EgmRobot::_internal_has_planned() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || planned_ != nullptr);
  return value;
}
inline bool EgmRobot::has_planned() const {
  return _internal_has_planned();
}
inline void EgmRobot::clear_planned() {
  if (planned_ != nullptr) planned_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmPlanned& EgmRobot::_internal_planned() const {
  const ::abb::egm::EgmPlanned* p = planned_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPlanned&>(
      ::abb::egm::_EgmPlanned_default_instance_);
}
inline const ::abb::egm::EgmPlanned& EgmRobot::planned() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.planned)
  return _internal_planned();
}
inline void EgmRobot::unsafe_arena_set_allocated_planned(
    ::abb::egm::EgmPlanned* planned) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(planned_);
  }
  planned_ = planned;
  if (planned) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.planned)
}
inline ::abb::egm::EgmPlanned* EgmRobot::release_planned() {
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmPlanned* temp = planned_;
  planned_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmPlanned* EgmRobot::unsafe_arena_release_planned() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.planned)
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmPlanned* temp = planned_;
  planned_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPlanned* EgmRobot::_internal_mutable_planned() {
  _has_bits_[0] |= 0x00000004u;
  if (planned_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPlanned>(GetArena());
    planned_ = p;
  }
  return planned_;
}
inline ::abb::egm::EgmPlanned* EgmRobot::mutable_planned() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.planned)
  return _internal_mutable_planned();
}
inline void EgmRobot::set_allocated_planned(::abb::egm::EgmPlanned* planned) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete planned_;
  }
  if (planned) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(planned);
    if (message_arena != submessage_arena) {
      planned = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, planned, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  planned_ = planned;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.planned)
}

// optional .abb.egm.EgmMotorState motorState = 4;
inline bool EgmRobot::_internal_has_motorstate() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || motorstate_ != nullptr);
  return value;
}
inline bool EgmRobot::has_motorstate() const {
  return _internal_has_motorstate();
}
inline void EgmRobot::clear_motorstate() {
  if (motorstate_ != nullptr) motorstate_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::egm::EgmMotorState& EgmRobot::_internal_motorstate() const {
  const ::abb::egm::EgmMotorState* p = motorstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmMotorState&>(
      ::abb::egm::_EgmMotorState_default_instance_);
}
inline const ::abb::egm::EgmMotorState& EgmRobot::motorstate() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.motorState)
  return _internal_motorstate();
}
inline void EgmRobot::unsafe_arena_set_allocated_motorstate(
    ::abb::egm::EgmMotorState* motorstate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(motorstate_);
  }
  motorstate_ = motorstate;
  if (motorstate) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.motorState)
}
inline ::abb::egm::EgmMotorState* EgmRobot::release_motorstate() {
  _has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmMotorState* temp = motorstate_;
  motorstate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmMotorState* EgmRobot::unsafe_arena_release_motorstate() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.motorState)
  _has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmMotorState* temp = motorstate_;
  motorstate_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmMotorState* EgmRobot::_internal_mutable_motorstate() {
  _has_bits_[0] |= 0x00000008u;
  if (motorstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmMotorState>(GetArena());
    motorstate_ = p;
  }
  return motorstate_;
}
inline ::abb::egm::EgmMotorState* EgmRobot::mutable_motorstate() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.motorState)
  return _internal_mutable_motorstate();
}
inline void EgmRobot::set_allocated_motorstate(::abb::egm::EgmMotorState* motorstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete motorstate_;
  }
  if (motorstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(motorstate);
    if (message_arena != submessage_arena) {
      motorstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motorstate, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  motorstate_ = motorstate;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.motorState)
}

// optional .abb.egm.EgmMCIState mciState = 5;
inline bool EgmRobot::_internal_has_mcistate() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || mcistate_ != nullptr);
  return value;
}
inline bool EgmRobot::has_mcistate() const {
  return _internal_has_mcistate();
}
inline void EgmRobot::clear_mcistate() {
  if (mcistate_ != nullptr) mcistate_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::abb::egm::EgmMCIState& EgmRobot::_internal_mcistate() const {
  const ::abb::egm::EgmMCIState* p = mcistate_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmMCIState&>(
      ::abb::egm::_EgmMCIState_default_instance_);
}
inline const ::abb::egm::EgmMCIState& EgmRobot::mcistate() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.mciState)
  return _internal_mcistate();
}
inline void EgmRobot::unsafe_arena_set_allocated_mcistate(
    ::abb::egm::EgmMCIState* mcistate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mcistate_);
  }
  mcistate_ = mcistate;
  if (mcistate) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.mciState)
}
inline ::abb::egm::EgmMCIState* EgmRobot::release_mcistate() {
  _has_bits_[0] &= ~0x00000010u;
  ::abb::egm::EgmMCIState* temp = mcistate_;
  mcistate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmMCIState* EgmRobot::unsafe_arena_release_mcistate() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.mciState)
  _has_bits_[0] &= ~0x00000010u;
  ::abb::egm::EgmMCIState* temp = mcistate_;
  mcistate_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmMCIState* EgmRobot::_internal_mutable_mcistate() {
  _has_bits_[0] |= 0x00000010u;
  if (mcistate_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmMCIState>(GetArena());
    mcistate_ = p;
  }
  return mcistate_;
}
inline ::abb::egm::EgmMCIState* EgmRobot::mutable_mcistate() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.mciState)
  return _internal_mutable_mcistate();
}
inline void EgmRobot::set_allocated_mcistate(::abb::egm::EgmMCIState* mcistate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete mcistate_;
  }
  if (mcistate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(mcistate);
    if (message_arena != submessage_arena) {
      mcistate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mcistate, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  mcistate_ = mcistate;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.mciState)
}

// optional bool mciConvergenceMet = 6;
inline bool EgmRobot::_internal_has_mciconvergencemet() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool EgmRobot::has_mciconvergencemet() const {
  return _internal_has_mciconvergencemet();
}
inline void EgmRobot::clear_mciconvergencemet() {
  mciconvergencemet_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool EgmRobot::_internal_mciconvergencemet() const {
  return mciconvergencemet_;
}
inline bool EgmRobot::mciconvergencemet() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.mciConvergenceMet)
  return _internal_mciconvergencemet();
}
inline void EgmRobot::_internal_set_mciconvergencemet(bool value) {
  _has_bits_[0] |= 0x00000200u;
  mciconvergencemet_ = value;
}
inline void EgmRobot::set_mciconvergencemet(bool value) {
  _internal_set_mciconvergencemet(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmRobot.mciConvergenceMet)
}

// optional .abb.egm.EgmTestSignals testSignals = 7;
inline bool EgmRobot::_internal_has_testsignals() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || testsignals_ != nullptr);
  return value;
}
inline bool EgmRobot::has_testsignals() const {
  return _internal_has_testsignals();
}
inline void EgmRobot::clear_testsignals() {
  if (testsignals_ != nullptr) testsignals_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::abb::egm::EgmTestSignals& EgmRobot::_internal_testsignals() const {
  const ::abb::egm::EgmTestSignals* p = testsignals_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmTestSignals&>(
      ::abb::egm::_EgmTestSignals_default_instance_);
}
inline const ::abb::egm::EgmTestSignals& EgmRobot::testsignals() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.testSignals)
  return _internal_testsignals();
}
inline void EgmRobot::unsafe_arena_set_allocated_testsignals(
    ::abb::egm::EgmTestSignals* testsignals) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(testsignals_);
  }
  testsignals_ = testsignals;
  if (testsignals) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.testSignals)
}
inline ::abb::egm::EgmTestSignals* EgmRobot::release_testsignals() {
  _has_bits_[0] &= ~0x00000020u;
  ::abb::egm::EgmTestSignals* temp = testsignals_;
  testsignals_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmTestSignals* EgmRobot::unsafe_arena_release_testsignals() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.testSignals)
  _has_bits_[0] &= ~0x00000020u;
  ::abb::egm::EgmTestSignals* temp = testsignals_;
  testsignals_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmTestSignals* EgmRobot::_internal_mutable_testsignals() {
  _has_bits_[0] |= 0x00000020u;
  if (testsignals_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmTestSignals>(GetArena());
    testsignals_ = p;
  }
  return testsignals_;
}
inline ::abb::egm::EgmTestSignals* EgmRobot::mutable_testsignals() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.testSignals)
  return _internal_mutable_testsignals();
}
inline void EgmRobot::set_allocated_testsignals(::abb::egm::EgmTestSignals* testsignals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete testsignals_;
  }
  if (testsignals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(testsignals);
    if (message_arena != submessage_arena) {
      testsignals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, testsignals, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  testsignals_ = testsignals;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.testSignals)
}

// optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
inline bool EgmRobot::_internal_has_rapidexecstate() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || rapidexecstate_ != nullptr);
  return value;
}
inline bool EgmRobot::has_rapidexecstate() const {
  return _internal_has_rapidexecstate();
}
inline void EgmRobot::clear_rapidexecstate() {
  if (rapidexecstate_ != nullptr) rapidexecstate_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::abb::egm::EgmRapidCtrlExecState& EgmRobot::_internal_rapidexecstate() const {
  const ::abb::egm::EgmRapidCtrlExecState* p = rapidexecstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmRapidCtrlExecState&>(
      ::abb::egm::_EgmRapidCtrlExecState_default_instance_);
}
inline const ::abb::egm::EgmRapidCtrlExecState& EgmRobot::rapidexecstate() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.rapidExecState)
  return _internal_rapidexecstate();
}
inline void EgmRobot::unsafe_arena_set_allocated_rapidexecstate(
    ::abb::egm::EgmRapidCtrlExecState* rapidexecstate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rapidexecstate_);
  }
  rapidexecstate_ = rapidexecstate;
  if (rapidexecstate) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.rapidExecState)
}
inline ::abb::egm::EgmRapidCtrlExecState* EgmRobot::release_rapidexecstate() {
  _has_bits_[0] &= ~0x00000040u;
  ::abb::egm::EgmRapidCtrlExecState* temp = rapidexecstate_;
  rapidexecstate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmRapidCtrlExecState* EgmRobot::unsafe_arena_release_rapidexecstate() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.rapidExecState)
  _has_bits_[0] &= ~0x00000040u;
  ::abb::egm::EgmRapidCtrlExecState* temp = rapidexecstate_;
  rapidexecstate_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmRapidCtrlExecState* EgmRobot::_internal_mutable_rapidexecstate() {
  _has_bits_[0] |= 0x00000040u;
  if (rapidexecstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmRapidCtrlExecState>(GetArena());
    rapidexecstate_ = p;
  }
  return rapidexecstate_;
}
inline ::abb::egm::EgmRapidCtrlExecState* EgmRobot::mutable_rapidexecstate() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.rapidExecState)
  return _internal_mutable_rapidexecstate();
}
inline void EgmRobot::set_allocated_rapidexecstate(::abb::egm::EgmRapidCtrlExecState* rapidexecstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete rapidexecstate_;
  }
  if (rapidexecstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rapidexecstate);
    if (message_arena != submessage_arena) {
      rapidexecstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rapidexecstate, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  rapidexecstate_ = rapidexecstate;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.rapidExecState)
}

// optional .abb.egm.EgmMeasuredForce measuredForce = 9;
inline bool EgmRobot::_internal_has_measuredforce() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || measuredforce_ != nullptr);
  return value;
}
inline bool EgmRobot::has_measuredforce() const {
  return _internal_has_measuredforce();
}
inline void EgmRobot::clear_measuredforce() {
  if (measuredforce_ != nullptr) measuredforce_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::abb::egm::EgmMeasuredForce& EgmRobot::_internal_measuredforce() const {
  const ::abb::egm::EgmMeasuredForce* p = measuredforce_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmMeasuredForce&>(
      ::abb::egm::_EgmMeasuredForce_default_instance_);
}
inline const ::abb::egm::EgmMeasuredForce& EgmRobot::measuredforce() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.measuredForce)
  return _internal_measuredforce();
}
inline void EgmRobot::unsafe_arena_set_allocated_measuredforce(
    ::abb::egm::EgmMeasuredForce* measuredforce) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(measuredforce_);
  }
  measuredforce_ = measuredforce;
  if (measuredforce) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.measuredForce)
}
inline ::abb::egm::EgmMeasuredForce* EgmRobot::release_measuredforce() {
  _has_bits_[0] &= ~0x00000080u;
  ::abb::egm::EgmMeasuredForce* temp = measuredforce_;
  measuredforce_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmMeasuredForce* EgmRobot::unsafe_arena_release_measuredforce() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.measuredForce)
  _has_bits_[0] &= ~0x00000080u;
  ::abb::egm::EgmMeasuredForce* temp = measuredforce_;
  measuredforce_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmMeasuredForce* EgmRobot::_internal_mutable_measuredforce() {
  _has_bits_[0] |= 0x00000080u;
  if (measuredforce_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmMeasuredForce>(GetArena());
    measuredforce_ = p;
  }
  return measuredforce_;
}
inline ::abb::egm::EgmMeasuredForce* EgmRobot::mutable_measuredforce() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.measuredForce)
  return _internal_mutable_measuredforce();
}
inline void EgmRobot::set_allocated_measuredforce(::abb::egm::EgmMeasuredForce* measuredforce) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete measuredforce_;
  }
  if (measuredforce) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(measuredforce);
    if (message_arena != submessage_arena) {
      measuredforce = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, measuredforce, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  measuredforce_ = measuredforce;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.measuredForce)
}

// optional double utilizationRate = 10;
inline bool EgmRobot::_internal_has_utilizationrate() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool EgmRobot::has_utilizationrate() const {
  return _internal_has_utilizationrate();
}
inline void EgmRobot::clear_utilizationrate() {
  utilizationrate_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double EgmRobot::_internal_utilizationrate() const {
  return utilizationrate_;
}
inline double EgmRobot::utilizationrate() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.utilizationRate)
  return _internal_utilizationrate();
}
inline void EgmRobot::_internal_set_utilizationrate(double value) {
  _has_bits_[0] |= 0x00000100u;
  utilizationrate_ = value;
}
inline void EgmRobot::set_utilizationrate(double value) {
  _internal_set_utilizationrate(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmRobot.utilizationRate)
}

// -------------------------------------------------------------------

// EgmSensor

// optional .abb.egm.EgmHeader header = 1;
inline bool EgmSensor::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool EgmSensor::has_header() const {
  return _internal_has_header();
}
inline void EgmSensor::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmHeader& EgmSensor::_internal_header() const {
  const ::abb::egm::EgmHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmHeader&>(
      ::abb::egm::_EgmHeader_default_instance_);
}
inline const ::abb::egm::EgmHeader& EgmSensor::header() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensor.header)
  return _internal_header();
}
inline void EgmSensor::unsafe_arena_set_allocated_header(
    ::abb::egm::EgmHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensor.header)
}
inline ::abb::egm::EgmHeader* EgmSensor::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmHeader* EgmSensor::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensor.header)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmHeader* EgmSensor::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::abb::egm::EgmHeader* EgmSensor::mutable_header() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensor.header)
  return _internal_mutable_header();
}
inline void EgmSensor::set_allocated_header(::abb::egm::EgmHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensor.header)
}

// optional .abb.egm.EgmPlanned planned = 2;
inline bool EgmSensor::_internal_has_planned() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || planned_ != nullptr);
  return value;
}
inline bool EgmSensor::has_planned() const {
  return _internal_has_planned();
}
inline void EgmSensor::clear_planned() {
  if (planned_ != nullptr) planned_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmPlanned& EgmSensor::_internal_planned() const {
  const ::abb::egm::EgmPlanned* p = planned_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPlanned&>(
      ::abb::egm::_EgmPlanned_default_instance_);
}
inline const ::abb::egm::EgmPlanned& EgmSensor::planned() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensor.planned)
  return _internal_planned();
}
inline void EgmSensor::unsafe_arena_set_allocated_planned(
    ::abb::egm::EgmPlanned* planned) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(planned_);
  }
  planned_ = planned;
  if (planned) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensor.planned)
}
inline ::abb::egm::EgmPlanned* EgmSensor::release_planned() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPlanned* temp = planned_;
  planned_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmPlanned* EgmSensor::unsafe_arena_release_planned() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensor.planned)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPlanned* temp = planned_;
  planned_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPlanned* EgmSensor::_internal_mutable_planned() {
  _has_bits_[0] |= 0x00000002u;
  if (planned_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPlanned>(GetArena());
    planned_ = p;
  }
  return planned_;
}
inline ::abb::egm::EgmPlanned* EgmSensor::mutable_planned() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensor.planned)
  return _internal_mutable_planned();
}
inline void EgmSensor::set_allocated_planned(::abb::egm::EgmPlanned* planned) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete planned_;
  }
  if (planned) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(planned);
    if (message_arena != submessage_arena) {
      planned = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, planned, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  planned_ = planned;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensor.planned)
}

// optional .abb.egm.EgmSpeedRef speedRef = 3;
inline bool EgmSensor::_internal_has_speedref() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || speedref_ != nullptr);
  return value;
}
inline bool EgmSensor::has_speedref() const {
  return _internal_has_speedref();
}
inline void EgmSensor::clear_speedref() {
  if (speedref_ != nullptr) speedref_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmSpeedRef& EgmSensor::_internal_speedref() const {
  const ::abb::egm::EgmSpeedRef* p = speedref_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmSpeedRef&>(
      ::abb::egm::_EgmSpeedRef_default_instance_);
}
inline const ::abb::egm::EgmSpeedRef& EgmSensor::speedref() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensor.speedRef)
  return _internal_speedref();
}
inline void EgmSensor::unsafe_arena_set_allocated_speedref(
    ::abb::egm::EgmSpeedRef* speedref) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(speedref_);
  }
  speedref_ = speedref;
  if (speedref) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensor.speedRef)
}
inline ::abb::egm::EgmSpeedRef* EgmSensor::release_speedref() {
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmSpeedRef* temp = speedref_;
  speedref_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmSpeedRef* EgmSensor::unsafe_arena_release_speedref() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensor.speedRef)
  _has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmSpeedRef* temp = speedref_;
  speedref_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmSpeedRef* EgmSensor::_internal_mutable_speedref() {
  _has_bits_[0] |= 0x00000004u;
  if (speedref_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmSpeedRef>(GetArena());
    speedref_ = p;
  }
  return speedref_;
}
inline ::abb::egm::EgmSpeedRef* EgmSensor::mutable_speedref() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensor.speedRef)
  return _internal_mutable_speedref();
}
inline void EgmSensor::set_allocated_speedref(::abb::egm::EgmSpeedRef* speedref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete speedref_;
  }
  if (speedref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(speedref);
    if (message_arena != submessage_arena) {
      speedref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speedref, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  speedref_ = speedref;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensor.speedRef)
}

// -------------------------------------------------------------------

// EgmSensorPathCorr

// optional .abb.egm.EgmHeader header = 1;
inline bool EgmSensorPathCorr::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool EgmSensorPathCorr::has_header() const {
  return _internal_has_header();
}
inline void EgmSensorPathCorr::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmHeader& EgmSensorPathCorr::_internal_header() const {
  const ::abb::egm::EgmHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmHeader&>(
      ::abb::egm::_EgmHeader_default_instance_);
}
inline const ::abb::egm::EgmHeader& EgmSensorPathCorr::header() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensorPathCorr.header)
  return _internal_header();
}
inline void EgmSensorPathCorr::unsafe_arena_set_allocated_header(
    ::abb::egm::EgmHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensorPathCorr.header)
}
inline ::abb::egm::EgmHeader* EgmSensorPathCorr::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmHeader* EgmSensorPathCorr::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensorPathCorr.header)
  _has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmHeader* EgmSensorPathCorr::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::abb::egm::EgmHeader* EgmSensorPathCorr::mutable_header() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensorPathCorr.header)
  return _internal_mutable_header();
}
inline void EgmSensorPathCorr::set_allocated_header(::abb::egm::EgmHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensorPathCorr.header)
}

// optional .abb.egm.EgmPathCorr pathCorr = 2;
inline bool EgmSensorPathCorr::_internal_has_pathcorr() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || pathcorr_ != nullptr);
  return value;
}
inline bool EgmSensorPathCorr::has_pathcorr() const {
  return _internal_has_pathcorr();
}
inline void EgmSensorPathCorr::clear_pathcorr() {
  if (pathcorr_ != nullptr) pathcorr_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmPathCorr& EgmSensorPathCorr::_internal_pathcorr() const {
  const ::abb::egm::EgmPathCorr* p = pathcorr_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPathCorr&>(
      ::abb::egm::_EgmPathCorr_default_instance_);
}
inline const ::abb::egm::EgmPathCorr& EgmSensorPathCorr::pathcorr() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensorPathCorr.pathCorr)
  return _internal_pathcorr();
}
inline void EgmSensorPathCorr::unsafe_arena_set_allocated_pathcorr(
    ::abb::egm::EgmPathCorr* pathcorr) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathcorr_);
  }
  pathcorr_ = pathcorr;
  if (pathcorr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensorPathCorr.pathCorr)
}
inline ::abb::egm::EgmPathCorr* EgmSensorPathCorr::release_pathcorr() {
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPathCorr* temp = pathcorr_;
  pathcorr_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::abb::egm::EgmPathCorr* EgmSensorPathCorr::unsafe_arena_release_pathcorr() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensorPathCorr.pathCorr)
  _has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPathCorr* temp = pathcorr_;
  pathcorr_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPathCorr* EgmSensorPathCorr::_internal_mutable_pathcorr() {
  _has_bits_[0] |= 0x00000002u;
  if (pathcorr_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPathCorr>(GetArena());
    pathcorr_ = p;
  }
  return pathcorr_;
}
inline ::abb::egm::EgmPathCorr* EgmSensorPathCorr::mutable_pathcorr() {
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensorPathCorr.pathCorr)
  return _internal_mutable_pathcorr();
}
inline void EgmSensorPathCorr::set_allocated_pathcorr(::abb::egm::EgmPathCorr* pathcorr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pathcorr_;
  }
  if (pathcorr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pathcorr);
    if (message_arena != submessage_arena) {
      pathcorr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathcorr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pathcorr_ = pathcorr;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensorPathCorr.pathCorr)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace egm
}  // namespace abb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::abb::egm::EgmHeader_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::EgmHeader_MessageType>() {
  return ::abb::egm::EgmHeader_MessageType_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::EgmMotorState_MotorStateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::EgmMotorState_MotorStateType>() {
  return ::abb::egm::EgmMotorState_MotorStateType_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::EgmMCIState_MCIStateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::EgmMCIState_MCIStateType>() {
  return ::abb::egm::EgmMCIState_MCIStateType_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType>() {
  return ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_egm_2eproto
