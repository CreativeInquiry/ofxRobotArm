// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm.proto

#include "egm.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmCartesian_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmCartesianSpeed_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmClock_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmEuler_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_EgmFeedBack_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmHeader_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmJoints_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmMCIState_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmMeasuredForce_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmMotorState_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_EgmPathCorr_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_EgmPlanned_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_EgmPose_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmQuaternion_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmRapidCtrlExecState_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_EgmSpeedRef_egm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmTestSignals_egm_2eproto;
namespace abb {
namespace egm {
class EgmHeaderDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmHeader> _instance;
} _EgmHeader_default_instance_;
class EgmCartesianDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmCartesian> _instance;
} _EgmCartesian_default_instance_;
class EgmQuaternionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmQuaternion> _instance;
} _EgmQuaternion_default_instance_;
class EgmEulerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmEuler> _instance;
} _EgmEuler_default_instance_;
class EgmClockDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmClock> _instance;
} _EgmClock_default_instance_;
class EgmPoseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmPose> _instance;
} _EgmPose_default_instance_;
class EgmCartesianSpeedDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmCartesianSpeed> _instance;
} _EgmCartesianSpeed_default_instance_;
class EgmJointsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmJoints> _instance;
} _EgmJoints_default_instance_;
class EgmExternalJointsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmExternalJoints> _instance;
} _EgmExternalJoints_default_instance_;
class EgmPlannedDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmPlanned> _instance;
} _EgmPlanned_default_instance_;
class EgmSpeedRefDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmSpeedRef> _instance;
} _EgmSpeedRef_default_instance_;
class EgmPathCorrDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmPathCorr> _instance;
} _EgmPathCorr_default_instance_;
class EgmFeedBackDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmFeedBack> _instance;
} _EgmFeedBack_default_instance_;
class EgmMotorStateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmMotorState> _instance;
} _EgmMotorState_default_instance_;
class EgmMCIStateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmMCIState> _instance;
} _EgmMCIState_default_instance_;
class EgmRapidCtrlExecStateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmRapidCtrlExecState> _instance;
} _EgmRapidCtrlExecState_default_instance_;
class EgmTestSignalsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmTestSignals> _instance;
} _EgmTestSignals_default_instance_;
class EgmMeasuredForceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmMeasuredForce> _instance;
} _EgmMeasuredForce_default_instance_;
class EgmRobotDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmRobot> _instance;
} _EgmRobot_default_instance_;
class EgmSensorDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmSensor> _instance;
} _EgmSensor_default_instance_;
class EgmSensorPathCorrDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EgmSensorPathCorr> _instance;
} _EgmSensorPathCorr_default_instance_;
}  // namespace egm
}  // namespace abb
static void InitDefaultsscc_info_EgmCartesian_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmCartesian_default_instance_;
    new (ptr) ::abb::egm::EgmCartesian();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmCartesian_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EgmCartesian_egm_2eproto}, {}};

static void InitDefaultsscc_info_EgmCartesianSpeed_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmCartesianSpeed_default_instance_;
    new (ptr) ::abb::egm::EgmCartesianSpeed();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmCartesianSpeed_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EgmCartesianSpeed_egm_2eproto}, {}};

static void InitDefaultsscc_info_EgmClock_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmClock_default_instance_;
    new (ptr) ::abb::egm::EgmClock();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmClock_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EgmClock_egm_2eproto}, {}};

static void InitDefaultsscc_info_EgmEuler_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmEuler_default_instance_;
    new (ptr) ::abb::egm::EgmEuler();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmEuler_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EgmEuler_egm_2eproto}, {}};

static void InitDefaultsscc_info_EgmExternalJoints_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmExternalJoints_default_instance_;
    new (ptr) ::abb::egm::EgmExternalJoints();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmExternalJoints_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EgmExternalJoints_egm_2eproto}, {}};

static void InitDefaultsscc_info_EgmFeedBack_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmFeedBack_default_instance_;
    new (ptr) ::abb::egm::EgmFeedBack();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_EgmFeedBack_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_EgmFeedBack_egm_2eproto}, {
      &scc_info_EgmJoints_egm_2eproto.base,
      &scc_info_EgmPose_egm_2eproto.base,
      &scc_info_EgmClock_egm_2eproto.base,}};

static void InitDefaultsscc_info_EgmHeader_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmHeader_default_instance_;
    new (ptr) ::abb::egm::EgmHeader();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmHeader_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EgmHeader_egm_2eproto}, {}};

static void InitDefaultsscc_info_EgmJoints_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmJoints_default_instance_;
    new (ptr) ::abb::egm::EgmJoints();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmJoints_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EgmJoints_egm_2eproto}, {}};

static void InitDefaultsscc_info_EgmMCIState_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmMCIState_default_instance_;
    new (ptr) ::abb::egm::EgmMCIState();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmMCIState_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EgmMCIState_egm_2eproto}, {}};

static void InitDefaultsscc_info_EgmMeasuredForce_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmMeasuredForce_default_instance_;
    new (ptr) ::abb::egm::EgmMeasuredForce();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmMeasuredForce_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EgmMeasuredForce_egm_2eproto}, {}};

static void InitDefaultsscc_info_EgmMotorState_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmMotorState_default_instance_;
    new (ptr) ::abb::egm::EgmMotorState();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmMotorState_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EgmMotorState_egm_2eproto}, {}};

static void InitDefaultsscc_info_EgmPathCorr_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmPathCorr_default_instance_;
    new (ptr) ::abb::egm::EgmPathCorr();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_EgmPathCorr_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_EgmPathCorr_egm_2eproto}, {
      &scc_info_EgmCartesian_egm_2eproto.base,}};

static void InitDefaultsscc_info_EgmPlanned_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmPlanned_default_instance_;
    new (ptr) ::abb::egm::EgmPlanned();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_EgmPlanned_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_EgmPlanned_egm_2eproto}, {
      &scc_info_EgmJoints_egm_2eproto.base,
      &scc_info_EgmPose_egm_2eproto.base,
      &scc_info_EgmClock_egm_2eproto.base,}};

static void InitDefaultsscc_info_EgmPose_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmPose_default_instance_;
    new (ptr) ::abb::egm::EgmPose();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_EgmPose_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_EgmPose_egm_2eproto}, {
      &scc_info_EgmCartesian_egm_2eproto.base,
      &scc_info_EgmQuaternion_egm_2eproto.base,
      &scc_info_EgmEuler_egm_2eproto.base,}};

static void InitDefaultsscc_info_EgmQuaternion_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmQuaternion_default_instance_;
    new (ptr) ::abb::egm::EgmQuaternion();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmQuaternion_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EgmQuaternion_egm_2eproto}, {}};

static void InitDefaultsscc_info_EgmRapidCtrlExecState_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmRapidCtrlExecState_default_instance_;
    new (ptr) ::abb::egm::EgmRapidCtrlExecState();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmRapidCtrlExecState_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EgmRapidCtrlExecState_egm_2eproto}, {}};

static void InitDefaultsscc_info_EgmRobot_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmRobot_default_instance_;
    new (ptr) ::abb::egm::EgmRobot();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<8> scc_info_EgmRobot_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 8, 0, InitDefaultsscc_info_EgmRobot_egm_2eproto}, {
      &scc_info_EgmHeader_egm_2eproto.base,
      &scc_info_EgmFeedBack_egm_2eproto.base,
      &scc_info_EgmPlanned_egm_2eproto.base,
      &scc_info_EgmMotorState_egm_2eproto.base,
      &scc_info_EgmMCIState_egm_2eproto.base,
      &scc_info_EgmTestSignals_egm_2eproto.base,
      &scc_info_EgmRapidCtrlExecState_egm_2eproto.base,
      &scc_info_EgmMeasuredForce_egm_2eproto.base,}};

static void InitDefaultsscc_info_EgmSensor_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmSensor_default_instance_;
    new (ptr) ::abb::egm::EgmSensor();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_EgmSensor_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_EgmSensor_egm_2eproto}, {
      &scc_info_EgmHeader_egm_2eproto.base,
      &scc_info_EgmPlanned_egm_2eproto.base,
      &scc_info_EgmSpeedRef_egm_2eproto.base,}};

static void InitDefaultsscc_info_EgmSensorPathCorr_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmSensorPathCorr_default_instance_;
    new (ptr) ::abb::egm::EgmSensorPathCorr();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_EgmSensorPathCorr_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_EgmSensorPathCorr_egm_2eproto}, {
      &scc_info_EgmHeader_egm_2eproto.base,
      &scc_info_EgmPathCorr_egm_2eproto.base,}};

static void InitDefaultsscc_info_EgmSpeedRef_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmSpeedRef_default_instance_;
    new (ptr) ::abb::egm::EgmSpeedRef();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_EgmSpeedRef_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_EgmSpeedRef_egm_2eproto}, {
      &scc_info_EgmJoints_egm_2eproto.base,
      &scc_info_EgmCartesianSpeed_egm_2eproto.base,}};

static void InitDefaultsscc_info_EgmTestSignals_egm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::_EgmTestSignals_default_instance_;
    new (ptr) ::abb::egm::EgmTestSignals();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EgmTestSignals_egm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EgmTestSignals_egm_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_egm_2eproto[21];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_egm_2eproto[4];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_egm_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_egm_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmHeader, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmHeader, seqno_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmHeader, tm_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmHeader, mtype_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCartesian, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCartesian, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCartesian, x_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCartesian, y_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCartesian, z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmQuaternion, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmQuaternion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmQuaternion, u0_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmQuaternion, u1_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmQuaternion, u2_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmQuaternion, u3_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmEuler, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmEuler, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmEuler, x_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmEuler, y_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmEuler, z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmClock, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmClock, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmClock, sec_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmClock, usec_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPose, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPose, pos_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPose, orient_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPose, euler_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCartesianSpeed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCartesianSpeed, value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmJoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmJoints, joints_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmExternalJoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmExternalJoints, joints_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPlanned, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPlanned, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPlanned, joints_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPlanned, cartesian_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPlanned, externaljoints_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPlanned, time_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSpeedRef, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSpeedRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSpeedRef, joints_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSpeedRef, cartesians_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSpeedRef, externaljoints_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPathCorr, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPathCorr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPathCorr, pos_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPathCorr, age_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmFeedBack, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmFeedBack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmFeedBack, joints_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmFeedBack, cartesian_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmFeedBack, externaljoints_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmFeedBack, time_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMotorState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMotorState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMotorState, state_),
  0,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMCIState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMCIState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMCIState, state_),
  0,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRapidCtrlExecState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRapidCtrlExecState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRapidCtrlExecState, state_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmTestSignals, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmTestSignals, signals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMeasuredForce, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMeasuredForce, force_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, header_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, feedback_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, planned_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, motorstate_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, mcistate_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, mciconvergencemet_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, testsignals_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, rapidexecstate_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, measuredforce_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, utilizationrate_),
  0,
  1,
  2,
  3,
  4,
  9,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensor, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensor, header_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensor, planned_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensor, speedref_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensorPathCorr, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensorPathCorr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensorPathCorr, header_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensorPathCorr, pathcorr_),
  0,
  1,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::abb::egm::EgmHeader)},
  { 11, 19, sizeof(::abb::egm::EgmCartesian)},
  { 22, 31, sizeof(::abb::egm::EgmQuaternion)},
  { 35, 43, sizeof(::abb::egm::EgmEuler)},
  { 46, 53, sizeof(::abb::egm::EgmClock)},
  { 55, 63, sizeof(::abb::egm::EgmPose)},
  { 66, -1, sizeof(::abb::egm::EgmCartesianSpeed)},
  { 72, -1, sizeof(::abb::egm::EgmJoints)},
  { 78, -1, sizeof(::abb::egm::EgmExternalJoints)},
  { 84, 93, sizeof(::abb::egm::EgmPlanned)},
  { 97, 105, sizeof(::abb::egm::EgmSpeedRef)},
  { 108, 115, sizeof(::abb::egm::EgmPathCorr)},
  { 117, 126, sizeof(::abb::egm::EgmFeedBack)},
  { 130, 136, sizeof(::abb::egm::EgmMotorState)},
  { 137, 143, sizeof(::abb::egm::EgmMCIState)},
  { 144, 150, sizeof(::abb::egm::EgmRapidCtrlExecState)},
  { 151, -1, sizeof(::abb::egm::EgmTestSignals)},
  { 157, -1, sizeof(::abb::egm::EgmMeasuredForce)},
  { 163, 178, sizeof(::abb::egm::EgmRobot)},
  { 188, 196, sizeof(::abb::egm::EgmSensor)},
  { 199, 206, sizeof(::abb::egm::EgmSensorPathCorr)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmHeader_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmCartesian_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmQuaternion_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmEuler_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmClock_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmPose_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmCartesianSpeed_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmJoints_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmExternalJoints_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmPlanned_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmSpeedRef_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmPathCorr_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmFeedBack_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmMotorState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmMCIState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmRapidCtrlExecState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmTestSignals_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmMeasuredForce_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmRobot_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmSensor_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::abb::egm::_EgmSensorPathCorr_default_instance_),
};

const char descriptor_table_protodef_egm_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\tegm.proto\022\007abb.egm\"\353\001\n\tEgmHeader\022\r\n\005se"
  "qno\030\001 \001(\r\022\n\n\002tm\030\002 \001(\r\022@\n\005mtype\030\003 \001(\0162\036.a"
  "bb.egm.EgmHeader.MessageType:\021MSGTYPE_UN"
  "DEFINED\"\200\001\n\013MessageType\022\025\n\021MSGTYPE_UNDEF"
  "INED\020\000\022\023\n\017MSGTYPE_COMMAND\020\001\022\020\n\014MSGTYPE_D"
  "ATA\020\002\022\026\n\022MSGTYPE_CORRECTION\020\003\022\033\n\027MSGTYPE"
  "_PATH_CORRECTION\020\004\"/\n\014EgmCartesian\022\t\n\001x\030"
  "\001 \002(\001\022\t\n\001y\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\"\?\n\rEgmQuater"
  "nion\022\n\n\002u0\030\001 \002(\001\022\n\n\002u1\030\002 \002(\001\022\n\n\002u2\030\003 \002(\001"
  "\022\n\n\002u3\030\004 \002(\001\"+\n\010EgmEuler\022\t\n\001x\030\001 \002(\001\022\t\n\001y"
  "\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\"%\n\010EgmClock\022\013\n\003sec\030\001 \002"
  "(\004\022\014\n\004usec\030\002 \002(\004\"w\n\007EgmPose\022\"\n\003pos\030\001 \001(\013"
  "2\025.abb.egm.EgmCartesian\022&\n\006orient\030\002 \001(\0132"
  "\026.abb.egm.EgmQuaternion\022 \n\005euler\030\003 \001(\0132\021"
  ".abb.egm.EgmEuler\"\"\n\021EgmCartesianSpeed\022\r"
  "\n\005value\030\001 \003(\001\"\033\n\tEgmJoints\022\016\n\006joints\030\001 \003"
  "(\001\"#\n\021EgmExternalJoints\022\016\n\006joints\030\001 \003(\001\""
  "\242\001\n\nEgmPlanned\022\"\n\006joints\030\001 \001(\0132\022.abb.egm"
  ".EgmJoints\022#\n\tcartesian\030\002 \001(\0132\020.abb.egm."
  "EgmPose\022*\n\016externalJoints\030\003 \001(\0132\022.abb.eg"
  "m.EgmJoints\022\037\n\004time\030\004 \001(\0132\021.abb.egm.EgmC"
  "lock\"\215\001\n\013EgmSpeedRef\022\"\n\006joints\030\001 \001(\0132\022.a"
  "bb.egm.EgmJoints\022.\n\ncartesians\030\002 \001(\0132\032.a"
  "bb.egm.EgmCartesianSpeed\022*\n\016externalJoin"
  "ts\030\003 \001(\0132\022.abb.egm.EgmJoints\">\n\013EgmPathC"
  "orr\022\"\n\003pos\030\001 \002(\0132\025.abb.egm.EgmCartesian\022"
  "\013\n\003age\030\002 \002(\r\"\243\001\n\013EgmFeedBack\022\"\n\006joints\030\001"
  " \001(\0132\022.abb.egm.EgmJoints\022#\n\tcartesian\030\002 "
  "\001(\0132\020.abb.egm.EgmPose\022*\n\016externalJoints\030"
  "\003 \001(\0132\022.abb.egm.EgmJoints\022\037\n\004time\030\004 \001(\0132"
  "\021.abb.egm.EgmClock\"\214\001\n\rEgmMotorState\0224\n\005"
  "state\030\001 \002(\0162%.abb.egm.EgmMotorState.Moto"
  "rStateType\"E\n\016MotorStateType\022\024\n\020MOTORS_U"
  "NDEFINED\020\000\022\r\n\tMOTORS_ON\020\001\022\016\n\nMOTORS_OFF\020"
  "\002\"\242\001\n\013EgmMCIState\022\?\n\005state\030\001 \002(\0162!.abb.e"
  "gm.EgmMCIState.MCIStateType:\rMCI_UNDEFIN"
  "ED\"R\n\014MCIStateType\022\021\n\rMCI_UNDEFINED\020\000\022\r\n"
  "\tMCI_ERROR\020\001\022\017\n\013MCI_STOPPED\020\002\022\017\n\013MCI_RUN"
  "NING\020\003\"\303\001\n\025EgmRapidCtrlExecState\022U\n\005stat"
  "e\030\001 \002(\01625.abb.egm.EgmRapidCtrlExecState."
  "RapidCtrlExecStateType:\017RAPID_UNDEFINED\""
  "S\n\026RapidCtrlExecStateType\022\023\n\017RAPID_UNDEF"
  "INED\020\000\022\021\n\rRAPID_STOPPED\020\001\022\021\n\rRAPID_RUNNI"
  "NG\020\002\"!\n\016EgmTestSignals\022\017\n\007signals\030\001 \003(\001\""
  "!\n\020EgmMeasuredForce\022\r\n\005force\030\001 \003(\001\"\234\003\n\010E"
  "gmRobot\022\"\n\006header\030\001 \001(\0132\022.abb.egm.EgmHea"
  "der\022&\n\010feedBack\030\002 \001(\0132\024.abb.egm.EgmFeedB"
  "ack\022$\n\007planned\030\003 \001(\0132\023.abb.egm.EgmPlanne"
  "d\022*\n\nmotorState\030\004 \001(\0132\026.abb.egm.EgmMotor"
  "State\022&\n\010mciState\030\005 \001(\0132\024.abb.egm.EgmMCI"
  "State\022\031\n\021mciConvergenceMet\030\006 \001(\010\022,\n\013test"
  "Signals\030\007 \001(\0132\027.abb.egm.EgmTestSignals\0226"
  "\n\016rapidExecState\030\010 \001(\0132\036.abb.egm.EgmRapi"
  "dCtrlExecState\0220\n\rmeasuredForce\030\t \001(\0132\031."
  "abb.egm.EgmMeasuredForce\022\027\n\017utilizationR"
  "ate\030\n \001(\001\"}\n\tEgmSensor\022\"\n\006header\030\001 \001(\0132\022"
  ".abb.egm.EgmHeader\022$\n\007planned\030\002 \001(\0132\023.ab"
  "b.egm.EgmPlanned\022&\n\010speedRef\030\003 \001(\0132\024.abb"
  ".egm.EgmSpeedRef\"_\n\021EgmSensorPathCorr\022\"\n"
  "\006header\030\001 \001(\0132\022.abb.egm.EgmHeader\022&\n\010pat"
  "hCorr\030\002 \001(\0132\024.abb.egm.EgmPathCorr"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_egm_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_egm_2eproto_sccs[21] = {
  &scc_info_EgmCartesian_egm_2eproto.base,
  &scc_info_EgmCartesianSpeed_egm_2eproto.base,
  &scc_info_EgmClock_egm_2eproto.base,
  &scc_info_EgmEuler_egm_2eproto.base,
  &scc_info_EgmExternalJoints_egm_2eproto.base,
  &scc_info_EgmFeedBack_egm_2eproto.base,
  &scc_info_EgmHeader_egm_2eproto.base,
  &scc_info_EgmJoints_egm_2eproto.base,
  &scc_info_EgmMCIState_egm_2eproto.base,
  &scc_info_EgmMeasuredForce_egm_2eproto.base,
  &scc_info_EgmMotorState_egm_2eproto.base,
  &scc_info_EgmPathCorr_egm_2eproto.base,
  &scc_info_EgmPlanned_egm_2eproto.base,
  &scc_info_EgmPose_egm_2eproto.base,
  &scc_info_EgmQuaternion_egm_2eproto.base,
  &scc_info_EgmRapidCtrlExecState_egm_2eproto.base,
  &scc_info_EgmRobot_egm_2eproto.base,
  &scc_info_EgmSensor_egm_2eproto.base,
  &scc_info_EgmSensorPathCorr_egm_2eproto.base,
  &scc_info_EgmSpeedRef_egm_2eproto.base,
  &scc_info_EgmTestSignals_egm_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_egm_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_egm_2eproto = {
  false, false, descriptor_table_protodef_egm_2eproto, "egm.proto", 2433,
  &descriptor_table_egm_2eproto_once, descriptor_table_egm_2eproto_sccs, descriptor_table_egm_2eproto_deps, 21, 0,
  schemas, file_default_instances, TableStruct_egm_2eproto::offsets,
  file_level_metadata_egm_2eproto, 21, file_level_enum_descriptors_egm_2eproto, file_level_service_descriptors_egm_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_egm_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_egm_2eproto)), true);
namespace abb {
namespace egm {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmHeader_MessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_egm_2eproto);
  return file_level_enum_descriptors_egm_2eproto[0];
}
bool EgmHeader_MessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr EgmHeader_MessageType EgmHeader::MSGTYPE_UNDEFINED;
constexpr EgmHeader_MessageType EgmHeader::MSGTYPE_COMMAND;
constexpr EgmHeader_MessageType EgmHeader::MSGTYPE_DATA;
constexpr EgmHeader_MessageType EgmHeader::MSGTYPE_CORRECTION;
constexpr EgmHeader_MessageType EgmHeader::MSGTYPE_PATH_CORRECTION;
constexpr EgmHeader_MessageType EgmHeader::MessageType_MIN;
constexpr EgmHeader_MessageType EgmHeader::MessageType_MAX;
constexpr int EgmHeader::MessageType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmMotorState_MotorStateType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_egm_2eproto);
  return file_level_enum_descriptors_egm_2eproto[1];
}
bool EgmMotorState_MotorStateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr EgmMotorState_MotorStateType EgmMotorState::MOTORS_UNDEFINED;
constexpr EgmMotorState_MotorStateType EgmMotorState::MOTORS_ON;
constexpr EgmMotorState_MotorStateType EgmMotorState::MOTORS_OFF;
constexpr EgmMotorState_MotorStateType EgmMotorState::MotorStateType_MIN;
constexpr EgmMotorState_MotorStateType EgmMotorState::MotorStateType_MAX;
constexpr int EgmMotorState::MotorStateType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmMCIState_MCIStateType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_egm_2eproto);
  return file_level_enum_descriptors_egm_2eproto[2];
}
bool EgmMCIState_MCIStateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr EgmMCIState_MCIStateType EgmMCIState::MCI_UNDEFINED;
constexpr EgmMCIState_MCIStateType EgmMCIState::MCI_ERROR;
constexpr EgmMCIState_MCIStateType EgmMCIState::MCI_STOPPED;
constexpr EgmMCIState_MCIStateType EgmMCIState::MCI_RUNNING;
constexpr EgmMCIState_MCIStateType EgmMCIState::MCIStateType_MIN;
constexpr EgmMCIState_MCIStateType EgmMCIState::MCIStateType_MAX;
constexpr int EgmMCIState::MCIStateType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_egm_2eproto);
  return file_level_enum_descriptors_egm_2eproto[3];
}
bool EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RAPID_UNDEFINED;
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RAPID_STOPPED;
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RAPID_RUNNING;
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RapidCtrlExecStateType_MIN;
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RapidCtrlExecStateType_MAX;
constexpr int EgmRapidCtrlExecState::RapidCtrlExecStateType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

class EgmHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmHeader>()._has_bits_);
  static void set_has_seqno(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mtype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

EgmHeader::EgmHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmHeader)
}
EgmHeader::EgmHeader(const EgmHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&seqno_, &from.seqno_,
    static_cast<size_t>(reinterpret_cast<char*>(&mtype_) -
    reinterpret_cast<char*>(&seqno_)) + sizeof(mtype_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmHeader)
}

void EgmHeader::SharedCtor() {
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&seqno_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&mtype_) -
      reinterpret_cast<char*>(&seqno_)) + sizeof(mtype_));
}

EgmHeader::~EgmHeader() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmHeader)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EgmHeader::ArenaDtor(void* object) {
  EgmHeader* _this = reinterpret_cast< EgmHeader* >(object);
  (void)_this;
}
void EgmHeader::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmHeader::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmHeader& EgmHeader::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmHeader_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&seqno_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mtype_) -
        reinterpret_cast<char*>(&seqno_)) + sizeof(mtype_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmHeader::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 seqno = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_seqno(&has_bits);
          seqno_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 tm = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_tm(&has_bits);
          tm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::abb::egm::EgmHeader_MessageType_IsValid(val))) {
            _internal_set_mtype(static_cast<::abb::egm::EgmHeader_MessageType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmHeader::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 seqno = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_seqno(), target);
  }

  // optional uint32 tm = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_tm(), target);
  }

  // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_mtype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmHeader)
  return target;
}

size_t EgmHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmHeader)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 seqno = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_seqno());
    }

    // optional uint32 tm = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_tm());
    }

    // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mtype());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmHeader::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmHeader)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmHeader* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmHeader>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmHeader)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmHeader)
    MergeFrom(*source);
  }
}

void EgmHeader::MergeFrom(const EgmHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmHeader)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      seqno_ = from.seqno_;
    }
    if (cached_has_bits & 0x00000002u) {
      tm_ = from.tm_;
    }
    if (cached_has_bits & 0x00000004u) {
      mtype_ = from.mtype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EgmHeader::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmHeader::CopyFrom(const EgmHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmHeader::IsInitialized() const {
  return true;
}

void EgmHeader::InternalSwap(EgmHeader* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmHeader, mtype_)
      + sizeof(EgmHeader::mtype_)
      - PROTOBUF_FIELD_OFFSET(EgmHeader, seqno_)>(
          reinterpret_cast<char*>(&seqno_),
          reinterpret_cast<char*>(&other->seqno_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmHeader::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmCartesian::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmCartesian>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

EgmCartesian::EgmCartesian(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmCartesian)
}
EgmCartesian::EgmCartesian(const EgmCartesian& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmCartesian)
}

void EgmCartesian::SharedCtor() {
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

EgmCartesian::~EgmCartesian() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmCartesian)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmCartesian::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EgmCartesian::ArenaDtor(void* object) {
  EgmCartesian* _this = reinterpret_cast< EgmCartesian* >(object);
  (void)_this;
}
void EgmCartesian::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmCartesian::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmCartesian& EgmCartesian::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmCartesian_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmCartesian::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmCartesian)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmCartesian::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmCartesian::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmCartesian)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // required double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // required double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmCartesian)
  return target;
}

size_t EgmCartesian::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:abb.egm.EgmCartesian)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required double x = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_y()) {
    // required double y = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_z()) {
    // required double z = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t EgmCartesian::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmCartesian)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double x = 1;
    total_size += 1 + 8;

    // required double y = 2;
    total_size += 1 + 8;

    // required double z = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmCartesian::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmCartesian)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmCartesian* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmCartesian>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmCartesian)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmCartesian)
    MergeFrom(*source);
  }
}

void EgmCartesian::MergeFrom(const EgmCartesian& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmCartesian)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EgmCartesian::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmCartesian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmCartesian::CopyFrom(const EgmCartesian& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmCartesian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmCartesian::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void EgmCartesian::InternalSwap(EgmCartesian* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmCartesian, z_)
      + sizeof(EgmCartesian::z_)
      - PROTOBUF_FIELD_OFFSET(EgmCartesian, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmCartesian::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmQuaternion::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmQuaternion>()._has_bits_);
  static void set_has_u0(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_u1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_u2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_u3(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

EgmQuaternion::EgmQuaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmQuaternion)
}
EgmQuaternion::EgmQuaternion(const EgmQuaternion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&u0_, &from.u0_,
    static_cast<size_t>(reinterpret_cast<char*>(&u3_) -
    reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmQuaternion)
}

void EgmQuaternion::SharedCtor() {
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&u0_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&u3_) -
      reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
}

EgmQuaternion::~EgmQuaternion() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmQuaternion)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmQuaternion::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EgmQuaternion::ArenaDtor(void* object) {
  EgmQuaternion* _this = reinterpret_cast< EgmQuaternion* >(object);
  (void)_this;
}
void EgmQuaternion::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmQuaternion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmQuaternion& EgmQuaternion::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmQuaternion_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmQuaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmQuaternion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&u0_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&u3_) -
        reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmQuaternion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double u0 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_u0(&has_bits);
          u0_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double u1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_u1(&has_bits);
          u1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double u2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_u2(&has_bits);
          u2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double u3 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_u3(&has_bits);
          u3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmQuaternion::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmQuaternion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double u0 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_u0(), target);
  }

  // required double u1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_u1(), target);
  }

  // required double u2 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_u2(), target);
  }

  // required double u3 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_u3(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmQuaternion)
  return target;
}

size_t EgmQuaternion::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:abb.egm.EgmQuaternion)
  size_t total_size = 0;

  if (_internal_has_u0()) {
    // required double u0 = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_u1()) {
    // required double u1 = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_u2()) {
    // required double u2 = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_u3()) {
    // required double u3 = 4;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t EgmQuaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmQuaternion)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required double u0 = 1;
    total_size += 1 + 8;

    // required double u1 = 2;
    total_size += 1 + 8;

    // required double u2 = 3;
    total_size += 1 + 8;

    // required double u3 = 4;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmQuaternion::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmQuaternion)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmQuaternion* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmQuaternion>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmQuaternion)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmQuaternion)
    MergeFrom(*source);
  }
}

void EgmQuaternion::MergeFrom(const EgmQuaternion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmQuaternion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      u0_ = from.u0_;
    }
    if (cached_has_bits & 0x00000002u) {
      u1_ = from.u1_;
    }
    if (cached_has_bits & 0x00000004u) {
      u2_ = from.u2_;
    }
    if (cached_has_bits & 0x00000008u) {
      u3_ = from.u3_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EgmQuaternion::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmQuaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmQuaternion::CopyFrom(const EgmQuaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmQuaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmQuaternion::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void EgmQuaternion::InternalSwap(EgmQuaternion* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmQuaternion, u3_)
      + sizeof(EgmQuaternion::u3_)
      - PROTOBUF_FIELD_OFFSET(EgmQuaternion, u0_)>(
          reinterpret_cast<char*>(&u0_),
          reinterpret_cast<char*>(&other->u0_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmQuaternion::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmEuler::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmEuler>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

EgmEuler::EgmEuler(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmEuler)
}
EgmEuler::EgmEuler(const EgmEuler& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmEuler)
}

void EgmEuler::SharedCtor() {
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

EgmEuler::~EgmEuler() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmEuler)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmEuler::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EgmEuler::ArenaDtor(void* object) {
  EgmEuler* _this = reinterpret_cast< EgmEuler* >(object);
  (void)_this;
}
void EgmEuler::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmEuler::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmEuler& EgmEuler::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmEuler_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmEuler::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmEuler)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmEuler::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmEuler::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmEuler)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // required double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // required double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmEuler)
  return target;
}

size_t EgmEuler::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:abb.egm.EgmEuler)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required double x = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_y()) {
    // required double y = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_z()) {
    // required double z = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t EgmEuler::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmEuler)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double x = 1;
    total_size += 1 + 8;

    // required double y = 2;
    total_size += 1 + 8;

    // required double z = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmEuler::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmEuler)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmEuler* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmEuler>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmEuler)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmEuler)
    MergeFrom(*source);
  }
}

void EgmEuler::MergeFrom(const EgmEuler& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmEuler)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EgmEuler::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmEuler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmEuler::CopyFrom(const EgmEuler& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmEuler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmEuler::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void EgmEuler::InternalSwap(EgmEuler* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmEuler, z_)
      + sizeof(EgmEuler::z_)
      - PROTOBUF_FIELD_OFFSET(EgmEuler, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmEuler::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmClock::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmClock>()._has_bits_);
  static void set_has_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

EgmClock::EgmClock(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmClock)
}
EgmClock::EgmClock(const EgmClock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sec_, &from.sec_,
    static_cast<size_t>(reinterpret_cast<char*>(&usec_) -
    reinterpret_cast<char*>(&sec_)) + sizeof(usec_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmClock)
}

void EgmClock::SharedCtor() {
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&sec_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&usec_) -
      reinterpret_cast<char*>(&sec_)) + sizeof(usec_));
}

EgmClock::~EgmClock() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmClock)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmClock::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EgmClock::ArenaDtor(void* object) {
  EgmClock* _this = reinterpret_cast< EgmClock* >(object);
  (void)_this;
}
void EgmClock::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmClock::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmClock& EgmClock::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmClock_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmClock::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmClock)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&sec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&usec_) -
        reinterpret_cast<char*>(&sec_)) + sizeof(usec_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmClock::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint64 sec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_sec(&has_bits);
          sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 usec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_usec(&has_bits);
          usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmClock::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmClock)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 sec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_sec(), target);
  }

  // required uint64 usec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_usec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmClock)
  return target;
}

size_t EgmClock::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:abb.egm.EgmClock)
  size_t total_size = 0;

  if (_internal_has_sec()) {
    // required uint64 sec = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_sec());
  }

  if (_internal_has_usec()) {
    // required uint64 usec = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_usec());
  }

  return total_size;
}
size_t EgmClock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmClock)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 sec = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_sec());

    // required uint64 usec = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_usec());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmClock::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmClock)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmClock* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmClock>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmClock)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmClock)
    MergeFrom(*source);
  }
}

void EgmClock::MergeFrom(const EgmClock& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmClock)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sec_ = from.sec_;
    }
    if (cached_has_bits & 0x00000002u) {
      usec_ = from.usec_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EgmClock::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmClock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmClock::CopyFrom(const EgmClock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmClock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmClock::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void EgmClock::InternalSwap(EgmClock* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmClock, usec_)
      + sizeof(EgmClock::usec_)
      - PROTOBUF_FIELD_OFFSET(EgmClock, sec_)>(
          reinterpret_cast<char*>(&sec_),
          reinterpret_cast<char*>(&other->sec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmClock::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmPose::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmPose>()._has_bits_);
  static const ::abb::egm::EgmCartesian& pos(const EgmPose* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::egm::EgmQuaternion& orient(const EgmPose* msg);
  static void set_has_orient(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::egm::EgmEuler& euler(const EgmPose* msg);
  static void set_has_euler(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::egm::EgmCartesian&
EgmPose::_Internal::pos(const EgmPose* msg) {
  return *msg->pos_;
}
const ::abb::egm::EgmQuaternion&
EgmPose::_Internal::orient(const EgmPose* msg) {
  return *msg->orient_;
}
const ::abb::egm::EgmEuler&
EgmPose::_Internal::euler(const EgmPose* msg) {
  return *msg->euler_;
}
EgmPose::EgmPose(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmPose)
}
EgmPose::EgmPose(const EgmPose& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    pos_ = new ::abb::egm::EgmCartesian(*from.pos_);
  } else {
    pos_ = nullptr;
  }
  if (from._internal_has_orient()) {
    orient_ = new ::abb::egm::EgmQuaternion(*from.orient_);
  } else {
    orient_ = nullptr;
  }
  if (from._internal_has_euler()) {
    euler_ = new ::abb::egm::EgmEuler(*from.euler_);
  } else {
    euler_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmPose)
}

void EgmPose::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EgmPose_egm_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&pos_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&euler_) -
      reinterpret_cast<char*>(&pos_)) + sizeof(euler_));
}

EgmPose::~EgmPose() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmPose)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmPose::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete pos_;
  if (this != internal_default_instance()) delete orient_;
  if (this != internal_default_instance()) delete euler_;
}

void EgmPose::ArenaDtor(void* object) {
  EgmPose* _this = reinterpret_cast< EgmPose* >(object);
  (void)_this;
}
void EgmPose::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmPose::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmPose& EgmPose::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmPose_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmPose::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmPose)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(pos_ != nullptr);
      pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(orient_ != nullptr);
      orient_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(euler_ != nullptr);
      euler_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmPose::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.EgmCartesian pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmQuaternion orient = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_orient(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmEuler euler = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_euler(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmPose::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmPose)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmCartesian pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::pos(this), target, stream);
  }

  // optional .abb.egm.EgmQuaternion orient = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::orient(this), target, stream);
  }

  // optional .abb.egm.EgmEuler euler = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::euler(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmPose)
  return target;
}

size_t EgmPose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmPose)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .abb.egm.EgmCartesian pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pos_);
    }

    // optional .abb.egm.EgmQuaternion orient = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *orient_);
    }

    // optional .abb.egm.EgmEuler euler = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *euler_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmPose::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmPose)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmPose* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmPose>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmPose)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmPose)
    MergeFrom(*source);
  }
}

void EgmPose::MergeFrom(const EgmPose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmPose)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_pos()->::abb::egm::EgmCartesian::MergeFrom(from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_orient()->::abb::egm::EgmQuaternion::MergeFrom(from._internal_orient());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_euler()->::abb::egm::EgmEuler::MergeFrom(from._internal_euler());
    }
  }
}

void EgmPose::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmPose::CopyFrom(const EgmPose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmPose::IsInitialized() const {
  if (_internal_has_pos()) {
    if (!pos_->IsInitialized()) return false;
  }
  if (_internal_has_orient()) {
    if (!orient_->IsInitialized()) return false;
  }
  if (_internal_has_euler()) {
    if (!euler_->IsInitialized()) return false;
  }
  return true;
}

void EgmPose::InternalSwap(EgmPose* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmPose, euler_)
      + sizeof(EgmPose::euler_)
      - PROTOBUF_FIELD_OFFSET(EgmPose, pos_)>(
          reinterpret_cast<char*>(&pos_),
          reinterpret_cast<char*>(&other->pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmPose::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmCartesianSpeed::_Internal {
 public:
};

EgmCartesianSpeed::EgmCartesianSpeed(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  value_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmCartesianSpeed)
}
EgmCartesianSpeed::EgmCartesianSpeed(const EgmCartesianSpeed& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      value_(from.value_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmCartesianSpeed)
}

void EgmCartesianSpeed::SharedCtor() {
}

EgmCartesianSpeed::~EgmCartesianSpeed() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmCartesianSpeed)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmCartesianSpeed::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EgmCartesianSpeed::ArenaDtor(void* object) {
  EgmCartesianSpeed* _this = reinterpret_cast< EgmCartesianSpeed* >(object);
  (void)_this;
}
void EgmCartesianSpeed::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmCartesianSpeed::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmCartesianSpeed& EgmCartesianSpeed::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmCartesianSpeed_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmCartesianSpeed::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmCartesianSpeed)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmCartesianSpeed::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated double value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_value(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_value(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmCartesianSpeed::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmCartesianSpeed)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double value = 1;
  for (int i = 0, n = this->_internal_value_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_value(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmCartesianSpeed)
  return target;
}

size_t EgmCartesianSpeed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmCartesianSpeed)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double value = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_value_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_value_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmCartesianSpeed::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmCartesianSpeed)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmCartesianSpeed* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmCartesianSpeed>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmCartesianSpeed)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmCartesianSpeed)
    MergeFrom(*source);
  }
}

void EgmCartesianSpeed::MergeFrom(const EgmCartesianSpeed& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmCartesianSpeed)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  value_.MergeFrom(from.value_);
}

void EgmCartesianSpeed::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmCartesianSpeed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmCartesianSpeed::CopyFrom(const EgmCartesianSpeed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmCartesianSpeed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmCartesianSpeed::IsInitialized() const {
  return true;
}

void EgmCartesianSpeed::InternalSwap(EgmCartesianSpeed* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  value_.InternalSwap(&other->value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmCartesianSpeed::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmJoints::_Internal {
 public:
};

EgmJoints::EgmJoints(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  joints_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmJoints)
}
EgmJoints::EgmJoints(const EgmJoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      joints_(from.joints_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmJoints)
}

void EgmJoints::SharedCtor() {
}

EgmJoints::~EgmJoints() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmJoints)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmJoints::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EgmJoints::ArenaDtor(void* object) {
  EgmJoints* _this = reinterpret_cast< EgmJoints* >(object);
  (void)_this;
}
void EgmJoints::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmJoints::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmJoints& EgmJoints::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmJoints_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmJoints::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmJoints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  joints_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmJoints::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated double joints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_joints(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_joints(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmJoints::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmJoints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double joints = 1;
  for (int i = 0, n = this->_internal_joints_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_joints(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmJoints)
  return target;
}

size_t EgmJoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmJoints)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double joints = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_joints_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_joints_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmJoints::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmJoints)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmJoints* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmJoints>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmJoints)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmJoints)
    MergeFrom(*source);
  }
}

void EgmJoints::MergeFrom(const EgmJoints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmJoints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  joints_.MergeFrom(from.joints_);
}

void EgmJoints::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmJoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmJoints::CopyFrom(const EgmJoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmJoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmJoints::IsInitialized() const {
  return true;
}

void EgmJoints::InternalSwap(EgmJoints* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  joints_.InternalSwap(&other->joints_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmJoints::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmExternalJoints::_Internal {
 public:
};

EgmExternalJoints::EgmExternalJoints(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  joints_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmExternalJoints)
}
EgmExternalJoints::EgmExternalJoints(const EgmExternalJoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      joints_(from.joints_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmExternalJoints)
}

void EgmExternalJoints::SharedCtor() {
}

EgmExternalJoints::~EgmExternalJoints() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmExternalJoints)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmExternalJoints::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EgmExternalJoints::ArenaDtor(void* object) {
  EgmExternalJoints* _this = reinterpret_cast< EgmExternalJoints* >(object);
  (void)_this;
}
void EgmExternalJoints::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmExternalJoints::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmExternalJoints& EgmExternalJoints::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmExternalJoints_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmExternalJoints::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmExternalJoints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  joints_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmExternalJoints::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated double joints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_joints(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_joints(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmExternalJoints::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmExternalJoints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double joints = 1;
  for (int i = 0, n = this->_internal_joints_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_joints(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmExternalJoints)
  return target;
}

size_t EgmExternalJoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmExternalJoints)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double joints = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_joints_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_joints_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmExternalJoints::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmExternalJoints)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmExternalJoints* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmExternalJoints>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmExternalJoints)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmExternalJoints)
    MergeFrom(*source);
  }
}

void EgmExternalJoints::MergeFrom(const EgmExternalJoints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmExternalJoints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  joints_.MergeFrom(from.joints_);
}

void EgmExternalJoints::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmExternalJoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmExternalJoints::CopyFrom(const EgmExternalJoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmExternalJoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmExternalJoints::IsInitialized() const {
  return true;
}

void EgmExternalJoints::InternalSwap(EgmExternalJoints* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  joints_.InternalSwap(&other->joints_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmExternalJoints::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmPlanned::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmPlanned>()._has_bits_);
  static const ::abb::egm::EgmJoints& joints(const EgmPlanned* msg);
  static void set_has_joints(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::egm::EgmPose& cartesian(const EgmPlanned* msg);
  static void set_has_cartesian(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::egm::EgmJoints& externaljoints(const EgmPlanned* msg);
  static void set_has_externaljoints(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::abb::egm::EgmClock& time(const EgmPlanned* msg);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::abb::egm::EgmJoints&
EgmPlanned::_Internal::joints(const EgmPlanned* msg) {
  return *msg->joints_;
}
const ::abb::egm::EgmPose&
EgmPlanned::_Internal::cartesian(const EgmPlanned* msg) {
  return *msg->cartesian_;
}
const ::abb::egm::EgmJoints&
EgmPlanned::_Internal::externaljoints(const EgmPlanned* msg) {
  return *msg->externaljoints_;
}
const ::abb::egm::EgmClock&
EgmPlanned::_Internal::time(const EgmPlanned* msg) {
  return *msg->time_;
}
EgmPlanned::EgmPlanned(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmPlanned)
}
EgmPlanned::EgmPlanned(const EgmPlanned& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_joints()) {
    joints_ = new ::abb::egm::EgmJoints(*from.joints_);
  } else {
    joints_ = nullptr;
  }
  if (from._internal_has_cartesian()) {
    cartesian_ = new ::abb::egm::EgmPose(*from.cartesian_);
  } else {
    cartesian_ = nullptr;
  }
  if (from._internal_has_externaljoints()) {
    externaljoints_ = new ::abb::egm::EgmJoints(*from.externaljoints_);
  } else {
    externaljoints_ = nullptr;
  }
  if (from._internal_has_time()) {
    time_ = new ::abb::egm::EgmClock(*from.time_);
  } else {
    time_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmPlanned)
}

void EgmPlanned::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EgmPlanned_egm_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&joints_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&time_) -
      reinterpret_cast<char*>(&joints_)) + sizeof(time_));
}

EgmPlanned::~EgmPlanned() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmPlanned)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmPlanned::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete joints_;
  if (this != internal_default_instance()) delete cartesian_;
  if (this != internal_default_instance()) delete externaljoints_;
  if (this != internal_default_instance()) delete time_;
}

void EgmPlanned::ArenaDtor(void* object) {
  EgmPlanned* _this = reinterpret_cast< EgmPlanned* >(object);
  (void)_this;
}
void EgmPlanned::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmPlanned::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmPlanned& EgmPlanned::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmPlanned_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmPlanned::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmPlanned)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(joints_ != nullptr);
      joints_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(cartesian_ != nullptr);
      cartesian_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(externaljoints_ != nullptr);
      externaljoints_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(time_ != nullptr);
      time_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmPlanned::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.EgmJoints joints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_joints(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmPose cartesian = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cartesian(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmJoints externalJoints = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_externaljoints(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmClock time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_time(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmPlanned::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmPlanned)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmJoints joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::joints(this), target, stream);
  }

  // optional .abb.egm.EgmPose cartesian = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::cartesian(this), target, stream);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::externaljoints(this), target, stream);
  }

  // optional .abb.egm.EgmClock time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::time(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmPlanned)
  return target;
}

size_t EgmPlanned::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmPlanned)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .abb.egm.EgmJoints joints = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *joints_);
    }

    // optional .abb.egm.EgmPose cartesian = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cartesian_);
    }

    // optional .abb.egm.EgmJoints externalJoints = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *externaljoints_);
    }

    // optional .abb.egm.EgmClock time = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *time_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmPlanned::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmPlanned)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmPlanned* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmPlanned>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmPlanned)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmPlanned)
    MergeFrom(*source);
  }
}

void EgmPlanned::MergeFrom(const EgmPlanned& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmPlanned)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_joints()->::abb::egm::EgmJoints::MergeFrom(from._internal_joints());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_cartesian()->::abb::egm::EgmPose::MergeFrom(from._internal_cartesian());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_externaljoints()->::abb::egm::EgmJoints::MergeFrom(from._internal_externaljoints());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_time()->::abb::egm::EgmClock::MergeFrom(from._internal_time());
    }
  }
}

void EgmPlanned::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmPlanned)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmPlanned::CopyFrom(const EgmPlanned& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmPlanned)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmPlanned::IsInitialized() const {
  if (_internal_has_cartesian()) {
    if (!cartesian_->IsInitialized()) return false;
  }
  if (_internal_has_time()) {
    if (!time_->IsInitialized()) return false;
  }
  return true;
}

void EgmPlanned::InternalSwap(EgmPlanned* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmPlanned, time_)
      + sizeof(EgmPlanned::time_)
      - PROTOBUF_FIELD_OFFSET(EgmPlanned, joints_)>(
          reinterpret_cast<char*>(&joints_),
          reinterpret_cast<char*>(&other->joints_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmPlanned::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmSpeedRef::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmSpeedRef>()._has_bits_);
  static const ::abb::egm::EgmJoints& joints(const EgmSpeedRef* msg);
  static void set_has_joints(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::egm::EgmCartesianSpeed& cartesians(const EgmSpeedRef* msg);
  static void set_has_cartesians(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::egm::EgmJoints& externaljoints(const EgmSpeedRef* msg);
  static void set_has_externaljoints(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::egm::EgmJoints&
EgmSpeedRef::_Internal::joints(const EgmSpeedRef* msg) {
  return *msg->joints_;
}
const ::abb::egm::EgmCartesianSpeed&
EgmSpeedRef::_Internal::cartesians(const EgmSpeedRef* msg) {
  return *msg->cartesians_;
}
const ::abb::egm::EgmJoints&
EgmSpeedRef::_Internal::externaljoints(const EgmSpeedRef* msg) {
  return *msg->externaljoints_;
}
EgmSpeedRef::EgmSpeedRef(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmSpeedRef)
}
EgmSpeedRef::EgmSpeedRef(const EgmSpeedRef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_joints()) {
    joints_ = new ::abb::egm::EgmJoints(*from.joints_);
  } else {
    joints_ = nullptr;
  }
  if (from._internal_has_cartesians()) {
    cartesians_ = new ::abb::egm::EgmCartesianSpeed(*from.cartesians_);
  } else {
    cartesians_ = nullptr;
  }
  if (from._internal_has_externaljoints()) {
    externaljoints_ = new ::abb::egm::EgmJoints(*from.externaljoints_);
  } else {
    externaljoints_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmSpeedRef)
}

void EgmSpeedRef::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EgmSpeedRef_egm_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&joints_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&externaljoints_) -
      reinterpret_cast<char*>(&joints_)) + sizeof(externaljoints_));
}

EgmSpeedRef::~EgmSpeedRef() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmSpeedRef)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmSpeedRef::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete joints_;
  if (this != internal_default_instance()) delete cartesians_;
  if (this != internal_default_instance()) delete externaljoints_;
}

void EgmSpeedRef::ArenaDtor(void* object) {
  EgmSpeedRef* _this = reinterpret_cast< EgmSpeedRef* >(object);
  (void)_this;
}
void EgmSpeedRef::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmSpeedRef::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmSpeedRef& EgmSpeedRef::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmSpeedRef_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmSpeedRef::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmSpeedRef)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(joints_ != nullptr);
      joints_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(cartesians_ != nullptr);
      cartesians_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(externaljoints_ != nullptr);
      externaljoints_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmSpeedRef::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.EgmJoints joints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_joints(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cartesians(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmJoints externalJoints = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_externaljoints(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmSpeedRef::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmSpeedRef)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmJoints joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::joints(this), target, stream);
  }

  // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::cartesians(this), target, stream);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::externaljoints(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmSpeedRef)
  return target;
}

size_t EgmSpeedRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmSpeedRef)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .abb.egm.EgmJoints joints = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *joints_);
    }

    // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cartesians_);
    }

    // optional .abb.egm.EgmJoints externalJoints = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *externaljoints_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmSpeedRef::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmSpeedRef)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmSpeedRef* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmSpeedRef>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmSpeedRef)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmSpeedRef)
    MergeFrom(*source);
  }
}

void EgmSpeedRef::MergeFrom(const EgmSpeedRef& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmSpeedRef)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_joints()->::abb::egm::EgmJoints::MergeFrom(from._internal_joints());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_cartesians()->::abb::egm::EgmCartesianSpeed::MergeFrom(from._internal_cartesians());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_externaljoints()->::abb::egm::EgmJoints::MergeFrom(from._internal_externaljoints());
    }
  }
}

void EgmSpeedRef::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmSpeedRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmSpeedRef::CopyFrom(const EgmSpeedRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmSpeedRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmSpeedRef::IsInitialized() const {
  return true;
}

void EgmSpeedRef::InternalSwap(EgmSpeedRef* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmSpeedRef, externaljoints_)
      + sizeof(EgmSpeedRef::externaljoints_)
      - PROTOBUF_FIELD_OFFSET(EgmSpeedRef, joints_)>(
          reinterpret_cast<char*>(&joints_),
          reinterpret_cast<char*>(&other->joints_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmSpeedRef::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmPathCorr::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmPathCorr>()._has_bits_);
  static const ::abb::egm::EgmCartesian& pos(const EgmPathCorr* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_age(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::abb::egm::EgmCartesian&
EgmPathCorr::_Internal::pos(const EgmPathCorr* msg) {
  return *msg->pos_;
}
EgmPathCorr::EgmPathCorr(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmPathCorr)
}
EgmPathCorr::EgmPathCorr(const EgmPathCorr& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    pos_ = new ::abb::egm::EgmCartesian(*from.pos_);
  } else {
    pos_ = nullptr;
  }
  age_ = from.age_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmPathCorr)
}

void EgmPathCorr::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EgmPathCorr_egm_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&pos_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&age_) -
      reinterpret_cast<char*>(&pos_)) + sizeof(age_));
}

EgmPathCorr::~EgmPathCorr() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmPathCorr)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmPathCorr::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete pos_;
}

void EgmPathCorr::ArenaDtor(void* object) {
  EgmPathCorr* _this = reinterpret_cast< EgmPathCorr* >(object);
  (void)_this;
}
void EgmPathCorr::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmPathCorr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmPathCorr& EgmPathCorr::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmPathCorr_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmPathCorr::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmPathCorr)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(pos_ != nullptr);
    pos_->Clear();
  }
  age_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmPathCorr::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .abb.egm.EgmCartesian pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 age = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_age(&has_bits);
          age_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmPathCorr::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmPathCorr)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .abb.egm.EgmCartesian pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::pos(this), target, stream);
  }

  // required uint32 age = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_age(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmPathCorr)
  return target;
}

size_t EgmPathCorr::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:abb.egm.EgmPathCorr)
  size_t total_size = 0;

  if (_internal_has_pos()) {
    // required .abb.egm.EgmCartesian pos = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pos_);
  }

  if (_internal_has_age()) {
    // required uint32 age = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_age());
  }

  return total_size;
}
size_t EgmPathCorr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmPathCorr)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .abb.egm.EgmCartesian pos = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pos_);

    // required uint32 age = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_age());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmPathCorr::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmPathCorr)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmPathCorr* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmPathCorr>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmPathCorr)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmPathCorr)
    MergeFrom(*source);
  }
}

void EgmPathCorr::MergeFrom(const EgmPathCorr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmPathCorr)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_pos()->::abb::egm::EgmCartesian::MergeFrom(from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      age_ = from.age_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EgmPathCorr::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmPathCorr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmPathCorr::CopyFrom(const EgmPathCorr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmPathCorr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmPathCorr::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_pos()) {
    if (!pos_->IsInitialized()) return false;
  }
  return true;
}

void EgmPathCorr::InternalSwap(EgmPathCorr* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmPathCorr, age_)
      + sizeof(EgmPathCorr::age_)
      - PROTOBUF_FIELD_OFFSET(EgmPathCorr, pos_)>(
          reinterpret_cast<char*>(&pos_),
          reinterpret_cast<char*>(&other->pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmPathCorr::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmFeedBack::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmFeedBack>()._has_bits_);
  static const ::abb::egm::EgmJoints& joints(const EgmFeedBack* msg);
  static void set_has_joints(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::egm::EgmPose& cartesian(const EgmFeedBack* msg);
  static void set_has_cartesian(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::egm::EgmJoints& externaljoints(const EgmFeedBack* msg);
  static void set_has_externaljoints(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::abb::egm::EgmClock& time(const EgmFeedBack* msg);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::abb::egm::EgmJoints&
EgmFeedBack::_Internal::joints(const EgmFeedBack* msg) {
  return *msg->joints_;
}
const ::abb::egm::EgmPose&
EgmFeedBack::_Internal::cartesian(const EgmFeedBack* msg) {
  return *msg->cartesian_;
}
const ::abb::egm::EgmJoints&
EgmFeedBack::_Internal::externaljoints(const EgmFeedBack* msg) {
  return *msg->externaljoints_;
}
const ::abb::egm::EgmClock&
EgmFeedBack::_Internal::time(const EgmFeedBack* msg) {
  return *msg->time_;
}
EgmFeedBack::EgmFeedBack(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmFeedBack)
}
EgmFeedBack::EgmFeedBack(const EgmFeedBack& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_joints()) {
    joints_ = new ::abb::egm::EgmJoints(*from.joints_);
  } else {
    joints_ = nullptr;
  }
  if (from._internal_has_cartesian()) {
    cartesian_ = new ::abb::egm::EgmPose(*from.cartesian_);
  } else {
    cartesian_ = nullptr;
  }
  if (from._internal_has_externaljoints()) {
    externaljoints_ = new ::abb::egm::EgmJoints(*from.externaljoints_);
  } else {
    externaljoints_ = nullptr;
  }
  if (from._internal_has_time()) {
    time_ = new ::abb::egm::EgmClock(*from.time_);
  } else {
    time_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmFeedBack)
}

void EgmFeedBack::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EgmFeedBack_egm_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&joints_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&time_) -
      reinterpret_cast<char*>(&joints_)) + sizeof(time_));
}

EgmFeedBack::~EgmFeedBack() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmFeedBack)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmFeedBack::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete joints_;
  if (this != internal_default_instance()) delete cartesian_;
  if (this != internal_default_instance()) delete externaljoints_;
  if (this != internal_default_instance()) delete time_;
}

void EgmFeedBack::ArenaDtor(void* object) {
  EgmFeedBack* _this = reinterpret_cast< EgmFeedBack* >(object);
  (void)_this;
}
void EgmFeedBack::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmFeedBack::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmFeedBack& EgmFeedBack::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmFeedBack_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmFeedBack::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmFeedBack)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(joints_ != nullptr);
      joints_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(cartesian_ != nullptr);
      cartesian_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(externaljoints_ != nullptr);
      externaljoints_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(time_ != nullptr);
      time_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmFeedBack::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.EgmJoints joints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_joints(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmPose cartesian = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cartesian(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmJoints externalJoints = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_externaljoints(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmClock time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_time(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmFeedBack::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmFeedBack)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmJoints joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::joints(this), target, stream);
  }

  // optional .abb.egm.EgmPose cartesian = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::cartesian(this), target, stream);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::externaljoints(this), target, stream);
  }

  // optional .abb.egm.EgmClock time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::time(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmFeedBack)
  return target;
}

size_t EgmFeedBack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmFeedBack)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .abb.egm.EgmJoints joints = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *joints_);
    }

    // optional .abb.egm.EgmPose cartesian = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cartesian_);
    }

    // optional .abb.egm.EgmJoints externalJoints = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *externaljoints_);
    }

    // optional .abb.egm.EgmClock time = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *time_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmFeedBack::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmFeedBack)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmFeedBack* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmFeedBack>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmFeedBack)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmFeedBack)
    MergeFrom(*source);
  }
}

void EgmFeedBack::MergeFrom(const EgmFeedBack& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmFeedBack)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_joints()->::abb::egm::EgmJoints::MergeFrom(from._internal_joints());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_cartesian()->::abb::egm::EgmPose::MergeFrom(from._internal_cartesian());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_externaljoints()->::abb::egm::EgmJoints::MergeFrom(from._internal_externaljoints());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_time()->::abb::egm::EgmClock::MergeFrom(from._internal_time());
    }
  }
}

void EgmFeedBack::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmFeedBack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmFeedBack::CopyFrom(const EgmFeedBack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmFeedBack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmFeedBack::IsInitialized() const {
  if (_internal_has_cartesian()) {
    if (!cartesian_->IsInitialized()) return false;
  }
  if (_internal_has_time()) {
    if (!time_->IsInitialized()) return false;
  }
  return true;
}

void EgmFeedBack::InternalSwap(EgmFeedBack* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmFeedBack, time_)
      + sizeof(EgmFeedBack::time_)
      - PROTOBUF_FIELD_OFFSET(EgmFeedBack, joints_)>(
          reinterpret_cast<char*>(&joints_),
          reinterpret_cast<char*>(&other->joints_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmFeedBack::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmMotorState::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmMotorState>()._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

EgmMotorState::EgmMotorState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmMotorState)
}
EgmMotorState::EgmMotorState(const EgmMotorState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  state_ = from.state_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmMotorState)
}

void EgmMotorState::SharedCtor() {
  state_ = 0;
}

EgmMotorState::~EgmMotorState() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmMotorState)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmMotorState::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EgmMotorState::ArenaDtor(void* object) {
  EgmMotorState* _this = reinterpret_cast< EgmMotorState* >(object);
  (void)_this;
}
void EgmMotorState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmMotorState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmMotorState& EgmMotorState::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmMotorState_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmMotorState::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmMotorState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  state_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmMotorState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .abb.egm.EgmMotorState.MotorStateType state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::abb::egm::EgmMotorState_MotorStateType_IsValid(val))) {
            _internal_set_state(static_cast<::abb::egm::EgmMotorState_MotorStateType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmMotorState::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmMotorState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .abb.egm.EgmMotorState.MotorStateType state = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmMotorState)
  return target;
}

size_t EgmMotorState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmMotorState)
  size_t total_size = 0;

  // required .abb.egm.EgmMotorState.MotorStateType state = 1;
  if (_internal_has_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_state());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmMotorState::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmMotorState)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmMotorState* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmMotorState>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmMotorState)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmMotorState)
    MergeFrom(*source);
  }
}

void EgmMotorState::MergeFrom(const EgmMotorState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmMotorState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_state()) {
    _internal_set_state(from._internal_state());
  }
}

void EgmMotorState::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmMotorState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmMotorState::CopyFrom(const EgmMotorState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmMotorState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmMotorState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void EgmMotorState::InternalSwap(EgmMotorState* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(state_, other->state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmMotorState::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmMCIState::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmMCIState>()._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

EgmMCIState::EgmMCIState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmMCIState)
}
EgmMCIState::EgmMCIState(const EgmMCIState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  state_ = from.state_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmMCIState)
}

void EgmMCIState::SharedCtor() {
  state_ = 0;
}

EgmMCIState::~EgmMCIState() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmMCIState)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmMCIState::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EgmMCIState::ArenaDtor(void* object) {
  EgmMCIState* _this = reinterpret_cast< EgmMCIState* >(object);
  (void)_this;
}
void EgmMCIState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmMCIState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmMCIState& EgmMCIState::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmMCIState_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmMCIState::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmMCIState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  state_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmMCIState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::abb::egm::EgmMCIState_MCIStateType_IsValid(val))) {
            _internal_set_state(static_cast<::abb::egm::EgmMCIState_MCIStateType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmMCIState::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmMCIState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmMCIState)
  return target;
}

size_t EgmMCIState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmMCIState)
  size_t total_size = 0;

  // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
  if (_internal_has_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_state());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmMCIState::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmMCIState)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmMCIState* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmMCIState>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmMCIState)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmMCIState)
    MergeFrom(*source);
  }
}

void EgmMCIState::MergeFrom(const EgmMCIState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmMCIState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_state()) {
    _internal_set_state(from._internal_state());
  }
}

void EgmMCIState::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmMCIState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmMCIState::CopyFrom(const EgmMCIState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmMCIState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmMCIState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void EgmMCIState::InternalSwap(EgmMCIState* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(state_, other->state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmMCIState::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmRapidCtrlExecState::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmRapidCtrlExecState>()._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

EgmRapidCtrlExecState::EgmRapidCtrlExecState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmRapidCtrlExecState)
}
EgmRapidCtrlExecState::EgmRapidCtrlExecState(const EgmRapidCtrlExecState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  state_ = from.state_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmRapidCtrlExecState)
}

void EgmRapidCtrlExecState::SharedCtor() {
  state_ = 0;
}

EgmRapidCtrlExecState::~EgmRapidCtrlExecState() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmRapidCtrlExecState)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmRapidCtrlExecState::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EgmRapidCtrlExecState::ArenaDtor(void* object) {
  EgmRapidCtrlExecState* _this = reinterpret_cast< EgmRapidCtrlExecState* >(object);
  (void)_this;
}
void EgmRapidCtrlExecState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmRapidCtrlExecState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmRapidCtrlExecState& EgmRapidCtrlExecState::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmRapidCtrlExecState_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmRapidCtrlExecState::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmRapidCtrlExecState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  state_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmRapidCtrlExecState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(val))) {
            _internal_set_state(static_cast<::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmRapidCtrlExecState::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmRapidCtrlExecState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmRapidCtrlExecState)
  return target;
}

size_t EgmRapidCtrlExecState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmRapidCtrlExecState)
  size_t total_size = 0;

  // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
  if (_internal_has_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_state());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmRapidCtrlExecState::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmRapidCtrlExecState)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmRapidCtrlExecState* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmRapidCtrlExecState>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmRapidCtrlExecState)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmRapidCtrlExecState)
    MergeFrom(*source);
  }
}

void EgmRapidCtrlExecState::MergeFrom(const EgmRapidCtrlExecState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmRapidCtrlExecState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_state()) {
    _internal_set_state(from._internal_state());
  }
}

void EgmRapidCtrlExecState::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmRapidCtrlExecState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmRapidCtrlExecState::CopyFrom(const EgmRapidCtrlExecState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmRapidCtrlExecState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmRapidCtrlExecState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void EgmRapidCtrlExecState::InternalSwap(EgmRapidCtrlExecState* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(state_, other->state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmRapidCtrlExecState::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmTestSignals::_Internal {
 public:
};

EgmTestSignals::EgmTestSignals(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  signals_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmTestSignals)
}
EgmTestSignals::EgmTestSignals(const EgmTestSignals& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      signals_(from.signals_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmTestSignals)
}

void EgmTestSignals::SharedCtor() {
}

EgmTestSignals::~EgmTestSignals() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmTestSignals)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmTestSignals::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EgmTestSignals::ArenaDtor(void* object) {
  EgmTestSignals* _this = reinterpret_cast< EgmTestSignals* >(object);
  (void)_this;
}
void EgmTestSignals::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmTestSignals::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmTestSignals& EgmTestSignals::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmTestSignals_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmTestSignals::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmTestSignals)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  signals_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmTestSignals::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated double signals = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_signals(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_signals(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmTestSignals::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmTestSignals)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double signals = 1;
  for (int i = 0, n = this->_internal_signals_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_signals(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmTestSignals)
  return target;
}

size_t EgmTestSignals::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmTestSignals)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double signals = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_signals_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_signals_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmTestSignals::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmTestSignals)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmTestSignals* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmTestSignals>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmTestSignals)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmTestSignals)
    MergeFrom(*source);
  }
}

void EgmTestSignals::MergeFrom(const EgmTestSignals& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmTestSignals)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  signals_.MergeFrom(from.signals_);
}

void EgmTestSignals::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmTestSignals)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmTestSignals::CopyFrom(const EgmTestSignals& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmTestSignals)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmTestSignals::IsInitialized() const {
  return true;
}

void EgmTestSignals::InternalSwap(EgmTestSignals* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  signals_.InternalSwap(&other->signals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmTestSignals::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmMeasuredForce::_Internal {
 public:
};

EgmMeasuredForce::EgmMeasuredForce(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  force_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmMeasuredForce)
}
EgmMeasuredForce::EgmMeasuredForce(const EgmMeasuredForce& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      force_(from.force_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmMeasuredForce)
}

void EgmMeasuredForce::SharedCtor() {
}

EgmMeasuredForce::~EgmMeasuredForce() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmMeasuredForce)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmMeasuredForce::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EgmMeasuredForce::ArenaDtor(void* object) {
  EgmMeasuredForce* _this = reinterpret_cast< EgmMeasuredForce* >(object);
  (void)_this;
}
void EgmMeasuredForce::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmMeasuredForce::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmMeasuredForce& EgmMeasuredForce::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmMeasuredForce_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmMeasuredForce::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmMeasuredForce)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  force_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmMeasuredForce::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated double force = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_force(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_force(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmMeasuredForce::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmMeasuredForce)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double force = 1;
  for (int i = 0, n = this->_internal_force_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_force(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmMeasuredForce)
  return target;
}

size_t EgmMeasuredForce::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmMeasuredForce)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double force = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_force_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_force_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmMeasuredForce::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmMeasuredForce)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmMeasuredForce* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmMeasuredForce>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmMeasuredForce)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmMeasuredForce)
    MergeFrom(*source);
  }
}

void EgmMeasuredForce::MergeFrom(const EgmMeasuredForce& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmMeasuredForce)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  force_.MergeFrom(from.force_);
}

void EgmMeasuredForce::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmMeasuredForce)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmMeasuredForce::CopyFrom(const EgmMeasuredForce& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmMeasuredForce)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmMeasuredForce::IsInitialized() const {
  return true;
}

void EgmMeasuredForce::InternalSwap(EgmMeasuredForce* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  force_.InternalSwap(&other->force_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmMeasuredForce::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmRobot::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmRobot>()._has_bits_);
  static const ::abb::egm::EgmHeader& header(const EgmRobot* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::egm::EgmFeedBack& feedback(const EgmRobot* msg);
  static void set_has_feedback(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::egm::EgmPlanned& planned(const EgmRobot* msg);
  static void set_has_planned(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::abb::egm::EgmMotorState& motorstate(const EgmRobot* msg);
  static void set_has_motorstate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::abb::egm::EgmMCIState& mcistate(const EgmRobot* msg);
  static void set_has_mcistate(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mciconvergencemet(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::abb::egm::EgmTestSignals& testsignals(const EgmRobot* msg);
  static void set_has_testsignals(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::abb::egm::EgmRapidCtrlExecState& rapidexecstate(const EgmRobot* msg);
  static void set_has_rapidexecstate(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::abb::egm::EgmMeasuredForce& measuredforce(const EgmRobot* msg);
  static void set_has_measuredforce(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_utilizationrate(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::abb::egm::EgmHeader&
EgmRobot::_Internal::header(const EgmRobot* msg) {
  return *msg->header_;
}
const ::abb::egm::EgmFeedBack&
EgmRobot::_Internal::feedback(const EgmRobot* msg) {
  return *msg->feedback_;
}
const ::abb::egm::EgmPlanned&
EgmRobot::_Internal::planned(const EgmRobot* msg) {
  return *msg->planned_;
}
const ::abb::egm::EgmMotorState&
EgmRobot::_Internal::motorstate(const EgmRobot* msg) {
  return *msg->motorstate_;
}
const ::abb::egm::EgmMCIState&
EgmRobot::_Internal::mcistate(const EgmRobot* msg) {
  return *msg->mcistate_;
}
const ::abb::egm::EgmTestSignals&
EgmRobot::_Internal::testsignals(const EgmRobot* msg) {
  return *msg->testsignals_;
}
const ::abb::egm::EgmRapidCtrlExecState&
EgmRobot::_Internal::rapidexecstate(const EgmRobot* msg) {
  return *msg->rapidexecstate_;
}
const ::abb::egm::EgmMeasuredForce&
EgmRobot::_Internal::measuredforce(const EgmRobot* msg) {
  return *msg->measuredforce_;
}
EgmRobot::EgmRobot(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmRobot)
}
EgmRobot::EgmRobot(const EgmRobot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::abb::egm::EgmHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_feedback()) {
    feedback_ = new ::abb::egm::EgmFeedBack(*from.feedback_);
  } else {
    feedback_ = nullptr;
  }
  if (from._internal_has_planned()) {
    planned_ = new ::abb::egm::EgmPlanned(*from.planned_);
  } else {
    planned_ = nullptr;
  }
  if (from._internal_has_motorstate()) {
    motorstate_ = new ::abb::egm::EgmMotorState(*from.motorstate_);
  } else {
    motorstate_ = nullptr;
  }
  if (from._internal_has_mcistate()) {
    mcistate_ = new ::abb::egm::EgmMCIState(*from.mcistate_);
  } else {
    mcistate_ = nullptr;
  }
  if (from._internal_has_testsignals()) {
    testsignals_ = new ::abb::egm::EgmTestSignals(*from.testsignals_);
  } else {
    testsignals_ = nullptr;
  }
  if (from._internal_has_rapidexecstate()) {
    rapidexecstate_ = new ::abb::egm::EgmRapidCtrlExecState(*from.rapidexecstate_);
  } else {
    rapidexecstate_ = nullptr;
  }
  if (from._internal_has_measuredforce()) {
    measuredforce_ = new ::abb::egm::EgmMeasuredForce(*from.measuredforce_);
  } else {
    measuredforce_ = nullptr;
  }
  ::memcpy(&utilizationrate_, &from.utilizationrate_,
    static_cast<size_t>(reinterpret_cast<char*>(&mciconvergencemet_) -
    reinterpret_cast<char*>(&utilizationrate_)) + sizeof(mciconvergencemet_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmRobot)
}

void EgmRobot::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EgmRobot_egm_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&header_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&mciconvergencemet_) -
      reinterpret_cast<char*>(&header_)) + sizeof(mciconvergencemet_));
}

EgmRobot::~EgmRobot() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmRobot)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmRobot::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete feedback_;
  if (this != internal_default_instance()) delete planned_;
  if (this != internal_default_instance()) delete motorstate_;
  if (this != internal_default_instance()) delete mcistate_;
  if (this != internal_default_instance()) delete testsignals_;
  if (this != internal_default_instance()) delete rapidexecstate_;
  if (this != internal_default_instance()) delete measuredforce_;
}

void EgmRobot::ArenaDtor(void* object) {
  EgmRobot* _this = reinterpret_cast< EgmRobot* >(object);
  (void)_this;
}
void EgmRobot::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmRobot::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmRobot& EgmRobot::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmRobot_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmRobot::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmRobot)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != nullptr);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(feedback_ != nullptr);
      feedback_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(planned_ != nullptr);
      planned_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(motorstate_ != nullptr);
      motorstate_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(mcistate_ != nullptr);
      mcistate_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(testsignals_ != nullptr);
      testsignals_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(rapidexecstate_ != nullptr);
      rapidexecstate_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(measuredforce_ != nullptr);
      measuredforce_->Clear();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&utilizationrate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mciconvergencemet_) -
        reinterpret_cast<char*>(&utilizationrate_)) + sizeof(mciconvergencemet_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmRobot::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.EgmHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmFeedBack feedBack = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_feedback(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmPlanned planned = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_planned(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmMotorState motorState = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_motorstate(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmMCIState mciState = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_mcistate(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool mciConvergenceMet = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_mciconvergencemet(&has_bits);
          mciconvergencemet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmTestSignals testSignals = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_testsignals(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_rapidexecstate(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmMeasuredForce measuredForce = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_measuredforce(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double utilizationRate = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 81)) {
          _Internal::set_has_utilizationrate(&has_bits);
          utilizationrate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmRobot::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmRobot)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // optional .abb.egm.EgmFeedBack feedBack = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::feedback(this), target, stream);
  }

  // optional .abb.egm.EgmPlanned planned = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::planned(this), target, stream);
  }

  // optional .abb.egm.EgmMotorState motorState = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::motorstate(this), target, stream);
  }

  // optional .abb.egm.EgmMCIState mciState = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::mcistate(this), target, stream);
  }

  // optional bool mciConvergenceMet = 6;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_mciconvergencemet(), target);
  }

  // optional .abb.egm.EgmTestSignals testSignals = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::testsignals(this), target, stream);
  }

  // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::rapidexecstate(this), target, stream);
  }

  // optional .abb.egm.EgmMeasuredForce measuredForce = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::measuredforce(this), target, stream);
  }

  // optional double utilizationRate = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(10, this->_internal_utilizationrate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmRobot)
  return target;
}

size_t EgmRobot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmRobot)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .abb.egm.EgmHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *header_);
    }

    // optional .abb.egm.EgmFeedBack feedBack = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *feedback_);
    }

    // optional .abb.egm.EgmPlanned planned = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *planned_);
    }

    // optional .abb.egm.EgmMotorState motorState = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *motorstate_);
    }

    // optional .abb.egm.EgmMCIState mciState = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *mcistate_);
    }

    // optional .abb.egm.EgmTestSignals testSignals = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *testsignals_);
    }

    // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rapidexecstate_);
    }

    // optional .abb.egm.EgmMeasuredForce measuredForce = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *measuredforce_);
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional double utilizationRate = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional bool mciConvergenceMet = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmRobot::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmRobot)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmRobot* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmRobot>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmRobot)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmRobot)
    MergeFrom(*source);
  }
}

void EgmRobot::MergeFrom(const EgmRobot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmRobot)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::abb::egm::EgmHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_feedback()->::abb::egm::EgmFeedBack::MergeFrom(from._internal_feedback());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_planned()->::abb::egm::EgmPlanned::MergeFrom(from._internal_planned());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_motorstate()->::abb::egm::EgmMotorState::MergeFrom(from._internal_motorstate());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_mcistate()->::abb::egm::EgmMCIState::MergeFrom(from._internal_mcistate());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_testsignals()->::abb::egm::EgmTestSignals::MergeFrom(from._internal_testsignals());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_rapidexecstate()->::abb::egm::EgmRapidCtrlExecState::MergeFrom(from._internal_rapidexecstate());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_measuredforce()->::abb::egm::EgmMeasuredForce::MergeFrom(from._internal_measuredforce());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      utilizationrate_ = from.utilizationrate_;
    }
    if (cached_has_bits & 0x00000200u) {
      mciconvergencemet_ = from.mciconvergencemet_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EgmRobot::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmRobot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmRobot::CopyFrom(const EgmRobot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmRobot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmRobot::IsInitialized() const {
  if (_internal_has_feedback()) {
    if (!feedback_->IsInitialized()) return false;
  }
  if (_internal_has_planned()) {
    if (!planned_->IsInitialized()) return false;
  }
  if (_internal_has_motorstate()) {
    if (!motorstate_->IsInitialized()) return false;
  }
  if (_internal_has_mcistate()) {
    if (!mcistate_->IsInitialized()) return false;
  }
  if (_internal_has_rapidexecstate()) {
    if (!rapidexecstate_->IsInitialized()) return false;
  }
  return true;
}

void EgmRobot::InternalSwap(EgmRobot* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmRobot, mciconvergencemet_)
      + sizeof(EgmRobot::mciconvergencemet_)
      - PROTOBUF_FIELD_OFFSET(EgmRobot, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmRobot::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmSensor::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmSensor>()._has_bits_);
  static const ::abb::egm::EgmHeader& header(const EgmSensor* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::egm::EgmPlanned& planned(const EgmSensor* msg);
  static void set_has_planned(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::egm::EgmSpeedRef& speedref(const EgmSensor* msg);
  static void set_has_speedref(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::egm::EgmHeader&
EgmSensor::_Internal::header(const EgmSensor* msg) {
  return *msg->header_;
}
const ::abb::egm::EgmPlanned&
EgmSensor::_Internal::planned(const EgmSensor* msg) {
  return *msg->planned_;
}
const ::abb::egm::EgmSpeedRef&
EgmSensor::_Internal::speedref(const EgmSensor* msg) {
  return *msg->speedref_;
}
EgmSensor::EgmSensor(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmSensor)
}
EgmSensor::EgmSensor(const EgmSensor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::abb::egm::EgmHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_planned()) {
    planned_ = new ::abb::egm::EgmPlanned(*from.planned_);
  } else {
    planned_ = nullptr;
  }
  if (from._internal_has_speedref()) {
    speedref_ = new ::abb::egm::EgmSpeedRef(*from.speedref_);
  } else {
    speedref_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmSensor)
}

void EgmSensor::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EgmSensor_egm_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&header_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&speedref_) -
      reinterpret_cast<char*>(&header_)) + sizeof(speedref_));
}

EgmSensor::~EgmSensor() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmSensor)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmSensor::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete planned_;
  if (this != internal_default_instance()) delete speedref_;
}

void EgmSensor::ArenaDtor(void* object) {
  EgmSensor* _this = reinterpret_cast< EgmSensor* >(object);
  (void)_this;
}
void EgmSensor::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmSensor::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmSensor& EgmSensor::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmSensor_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmSensor::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmSensor)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != nullptr);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(planned_ != nullptr);
      planned_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(speedref_ != nullptr);
      speedref_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmSensor::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.EgmHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmPlanned planned = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_planned(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmSpeedRef speedRef = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_speedref(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmSensor::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmSensor)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // optional .abb.egm.EgmPlanned planned = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::planned(this), target, stream);
  }

  // optional .abb.egm.EgmSpeedRef speedRef = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::speedref(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmSensor)
  return target;
}

size_t EgmSensor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmSensor)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .abb.egm.EgmHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *header_);
    }

    // optional .abb.egm.EgmPlanned planned = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *planned_);
    }

    // optional .abb.egm.EgmSpeedRef speedRef = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *speedref_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmSensor::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmSensor)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmSensor* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmSensor>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmSensor)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmSensor)
    MergeFrom(*source);
  }
}

void EgmSensor::MergeFrom(const EgmSensor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmSensor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::abb::egm::EgmHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_planned()->::abb::egm::EgmPlanned::MergeFrom(from._internal_planned());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_speedref()->::abb::egm::EgmSpeedRef::MergeFrom(from._internal_speedref());
    }
  }
}

void EgmSensor::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmSensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmSensor::CopyFrom(const EgmSensor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmSensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmSensor::IsInitialized() const {
  if (_internal_has_planned()) {
    if (!planned_->IsInitialized()) return false;
  }
  return true;
}

void EgmSensor::InternalSwap(EgmSensor* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmSensor, speedref_)
      + sizeof(EgmSensor::speedref_)
      - PROTOBUF_FIELD_OFFSET(EgmSensor, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmSensor::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EgmSensorPathCorr::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmSensorPathCorr>()._has_bits_);
  static const ::abb::egm::EgmHeader& header(const EgmSensorPathCorr* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::egm::EgmPathCorr& pathcorr(const EgmSensorPathCorr* msg);
  static void set_has_pathcorr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::abb::egm::EgmHeader&
EgmSensorPathCorr::_Internal::header(const EgmSensorPathCorr* msg) {
  return *msg->header_;
}
const ::abb::egm::EgmPathCorr&
EgmSensorPathCorr::_Internal::pathcorr(const EgmSensorPathCorr* msg) {
  return *msg->pathcorr_;
}
EgmSensorPathCorr::EgmSensorPathCorr(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmSensorPathCorr)
}
EgmSensorPathCorr::EgmSensorPathCorr(const EgmSensorPathCorr& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::abb::egm::EgmHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_pathcorr()) {
    pathcorr_ = new ::abb::egm::EgmPathCorr(*from.pathcorr_);
  } else {
    pathcorr_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmSensorPathCorr)
}

void EgmSensorPathCorr::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EgmSensorPathCorr_egm_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&header_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&pathcorr_) -
      reinterpret_cast<char*>(&header_)) + sizeof(pathcorr_));
}

EgmSensorPathCorr::~EgmSensorPathCorr() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmSensorPathCorr)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EgmSensorPathCorr::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete pathcorr_;
}

void EgmSensorPathCorr::ArenaDtor(void* object) {
  EgmSensorPathCorr* _this = reinterpret_cast< EgmSensorPathCorr* >(object);
  (void)_this;
}
void EgmSensorPathCorr::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EgmSensorPathCorr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EgmSensorPathCorr& EgmSensorPathCorr::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EgmSensorPathCorr_egm_2eproto.base);
  return *internal_default_instance();
}


void EgmSensorPathCorr::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmSensorPathCorr)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != nullptr);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(pathcorr_ != nullptr);
      pathcorr_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmSensorPathCorr::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.EgmHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .abb.egm.EgmPathCorr pathCorr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pathcorr(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EgmSensorPathCorr::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmSensorPathCorr)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // optional .abb.egm.EgmPathCorr pathCorr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::pathcorr(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmSensorPathCorr)
  return target;
}

size_t EgmSensorPathCorr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmSensorPathCorr)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .abb.egm.EgmHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *header_);
    }

    // optional .abb.egm.EgmPathCorr pathCorr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pathcorr_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EgmSensorPathCorr::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmSensorPathCorr)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmSensorPathCorr* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EgmSensorPathCorr>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmSensorPathCorr)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmSensorPathCorr)
    MergeFrom(*source);
  }
}

void EgmSensorPathCorr::MergeFrom(const EgmSensorPathCorr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmSensorPathCorr)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::abb::egm::EgmHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_pathcorr()->::abb::egm::EgmPathCorr::MergeFrom(from._internal_pathcorr());
    }
  }
}

void EgmSensorPathCorr::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmSensorPathCorr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmSensorPathCorr::CopyFrom(const EgmSensorPathCorr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmSensorPathCorr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmSensorPathCorr::IsInitialized() const {
  if (_internal_has_pathcorr()) {
    if (!pathcorr_->IsInitialized()) return false;
  }
  return true;
}

void EgmSensorPathCorr::InternalSwap(EgmSensorPathCorr* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmSensorPathCorr, pathcorr_)
      + sizeof(EgmSensorPathCorr::pathcorr_)
      - PROTOBUF_FIELD_OFFSET(EgmSensorPathCorr, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmSensorPathCorr::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace egm
}  // namespace abb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::abb::egm::EgmHeader* Arena::CreateMaybeMessage< ::abb::egm::EgmHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmCartesian* Arena::CreateMaybeMessage< ::abb::egm::EgmCartesian >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmCartesian >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmQuaternion* Arena::CreateMaybeMessage< ::abb::egm::EgmQuaternion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmQuaternion >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmEuler* Arena::CreateMaybeMessage< ::abb::egm::EgmEuler >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmEuler >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmClock* Arena::CreateMaybeMessage< ::abb::egm::EgmClock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmClock >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmPose* Arena::CreateMaybeMessage< ::abb::egm::EgmPose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmPose >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmCartesianSpeed* Arena::CreateMaybeMessage< ::abb::egm::EgmCartesianSpeed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmCartesianSpeed >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmJoints* Arena::CreateMaybeMessage< ::abb::egm::EgmJoints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmJoints >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmExternalJoints* Arena::CreateMaybeMessage< ::abb::egm::EgmExternalJoints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmExternalJoints >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmPlanned* Arena::CreateMaybeMessage< ::abb::egm::EgmPlanned >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmPlanned >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmSpeedRef* Arena::CreateMaybeMessage< ::abb::egm::EgmSpeedRef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmSpeedRef >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmPathCorr* Arena::CreateMaybeMessage< ::abb::egm::EgmPathCorr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmPathCorr >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmFeedBack* Arena::CreateMaybeMessage< ::abb::egm::EgmFeedBack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmFeedBack >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmMotorState* Arena::CreateMaybeMessage< ::abb::egm::EgmMotorState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmMotorState >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmMCIState* Arena::CreateMaybeMessage< ::abb::egm::EgmMCIState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmMCIState >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmRapidCtrlExecState* Arena::CreateMaybeMessage< ::abb::egm::EgmRapidCtrlExecState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmRapidCtrlExecState >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmTestSignals* Arena::CreateMaybeMessage< ::abb::egm::EgmTestSignals >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmTestSignals >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmMeasuredForce* Arena::CreateMaybeMessage< ::abb::egm::EgmMeasuredForce >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmMeasuredForce >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmRobot* Arena::CreateMaybeMessage< ::abb::egm::EgmRobot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmRobot >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmSensor* Arena::CreateMaybeMessage< ::abb::egm::EgmSensor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmSensor >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmSensorPathCorr* Arena::CreateMaybeMessage< ::abb::egm::EgmSensorPathCorr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmSensorPathCorr >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
