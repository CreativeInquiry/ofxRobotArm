// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm_wrapper.proto

#include "egm_wrapper.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)

namespace protobuf_egm_5fwrapper_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Cartesian;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Clock;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Euler;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Header;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Joints;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Quaternion;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Status;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_External;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_JointSpace;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_CartesianSpace;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_CartesianVelocity;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_Robot;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<3> scc_info_CartesianPose;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<3> scc_info_Feedback;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<3> scc_info_Planned;
}  // namespace protobuf_egm_5fwrapper_2eproto
namespace abb {
namespace egm {
namespace wrapper {
class HeaderDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Header>
      _instance;
} _Header_default_instance_;
class StatusDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Status>
      _instance;
} _Status_default_instance_;
class ClockDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Clock>
      _instance;
} _Clock_default_instance_;
class JointsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Joints>
      _instance;
} _Joints_default_instance_;
class JointSpaceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<JointSpace>
      _instance;
} _JointSpace_default_instance_;
class CartesianDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Cartesian>
      _instance;
} _Cartesian_default_instance_;
class EulerDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Euler>
      _instance;
} _Euler_default_instance_;
class QuaternionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Quaternion>
      _instance;
} _Quaternion_default_instance_;
class CartesianPoseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CartesianPose>
      _instance;
} _CartesianPose_default_instance_;
class CartesianVelocityDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CartesianVelocity>
      _instance;
} _CartesianVelocity_default_instance_;
class CartesianSpaceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CartesianSpace>
      _instance;
} _CartesianSpace_default_instance_;
class RobotDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Robot>
      _instance;
} _Robot_default_instance_;
class ExternalDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<External>
      _instance;
} _External_default_instance_;
class FeedbackDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Feedback>
      _instance;
} _Feedback_default_instance_;
class PlannedDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Planned>
      _instance;
} _Planned_default_instance_;
class InputDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Input>
      _instance;
} _Input_default_instance_;
class OutputDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Output>
      _instance;
} _Output_default_instance_;
}  // namespace wrapper
}  // namespace egm
}  // namespace abb
namespace protobuf_egm_5fwrapper_2eproto {
static void InitDefaultsHeader() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Header_default_instance_;
    new (ptr) ::abb::egm::wrapper::Header();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Header::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Header =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsHeader}, {}};

static void InitDefaultsStatus() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Status_default_instance_;
    new (ptr) ::abb::egm::wrapper::Status();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Status::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Status =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsStatus}, {}};

static void InitDefaultsClock() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Clock_default_instance_;
    new (ptr) ::abb::egm::wrapper::Clock();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Clock::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Clock =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsClock}, {}};

static void InitDefaultsJoints() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Joints_default_instance_;
    new (ptr) ::abb::egm::wrapper::Joints();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Joints::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Joints =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsJoints}, {}};

static void InitDefaultsJointSpace() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_JointSpace_default_instance_;
    new (ptr) ::abb::egm::wrapper::JointSpace();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::JointSpace::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_JointSpace =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsJointSpace}, {
      &protobuf_egm_5fwrapper_2eproto::scc_info_Joints.base,}};

static void InitDefaultsCartesian() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Cartesian_default_instance_;
    new (ptr) ::abb::egm::wrapper::Cartesian();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Cartesian::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Cartesian =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCartesian}, {}};

static void InitDefaultsEuler() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Euler_default_instance_;
    new (ptr) ::abb::egm::wrapper::Euler();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Euler::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Euler =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEuler}, {}};

static void InitDefaultsQuaternion() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Quaternion_default_instance_;
    new (ptr) ::abb::egm::wrapper::Quaternion();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Quaternion::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Quaternion =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsQuaternion}, {}};

static void InitDefaultsCartesianPose() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_CartesianPose_default_instance_;
    new (ptr) ::abb::egm::wrapper::CartesianPose();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::CartesianPose::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<3> scc_info_CartesianPose =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsCartesianPose}, {
      &protobuf_egm_5fwrapper_2eproto::scc_info_Cartesian.base,
      &protobuf_egm_5fwrapper_2eproto::scc_info_Euler.base,
      &protobuf_egm_5fwrapper_2eproto::scc_info_Quaternion.base,}};

static void InitDefaultsCartesianVelocity() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_CartesianVelocity_default_instance_;
    new (ptr) ::abb::egm::wrapper::CartesianVelocity();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::CartesianVelocity::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CartesianVelocity =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCartesianVelocity}, {
      &protobuf_egm_5fwrapper_2eproto::scc_info_Cartesian.base,
      &protobuf_egm_5fwrapper_2eproto::scc_info_Euler.base,}};

static void InitDefaultsCartesianSpace() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_CartesianSpace_default_instance_;
    new (ptr) ::abb::egm::wrapper::CartesianSpace();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::CartesianSpace::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CartesianSpace =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCartesianSpace}, {
      &protobuf_egm_5fwrapper_2eproto::scc_info_CartesianPose.base,
      &protobuf_egm_5fwrapper_2eproto::scc_info_CartesianVelocity.base,}};

static void InitDefaultsRobot() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Robot_default_instance_;
    new (ptr) ::abb::egm::wrapper::Robot();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Robot::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_Robot =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsRobot}, {
      &protobuf_egm_5fwrapper_2eproto::scc_info_JointSpace.base,
      &protobuf_egm_5fwrapper_2eproto::scc_info_CartesianSpace.base,}};

static void InitDefaultsExternal() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_External_default_instance_;
    new (ptr) ::abb::egm::wrapper::External();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::External::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_External =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsExternal}, {
      &protobuf_egm_5fwrapper_2eproto::scc_info_JointSpace.base,}};

static void InitDefaultsFeedback() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Feedback_default_instance_;
    new (ptr) ::abb::egm::wrapper::Feedback();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Feedback::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<3> scc_info_Feedback =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsFeedback}, {
      &protobuf_egm_5fwrapper_2eproto::scc_info_Robot.base,
      &protobuf_egm_5fwrapper_2eproto::scc_info_External.base,
      &protobuf_egm_5fwrapper_2eproto::scc_info_Clock.base,}};

static void InitDefaultsPlanned() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Planned_default_instance_;
    new (ptr) ::abb::egm::wrapper::Planned();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Planned::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<3> scc_info_Planned =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsPlanned}, {
      &protobuf_egm_5fwrapper_2eproto::scc_info_Robot.base,
      &protobuf_egm_5fwrapper_2eproto::scc_info_External.base,
      &protobuf_egm_5fwrapper_2eproto::scc_info_Clock.base,}};

static void InitDefaultsInput() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Input_default_instance_;
    new (ptr) ::abb::egm::wrapper::Input();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Input::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<4> scc_info_Input =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsInput}, {
      &protobuf_egm_5fwrapper_2eproto::scc_info_Header.base,
      &protobuf_egm_5fwrapper_2eproto::scc_info_Feedback.base,
      &protobuf_egm_5fwrapper_2eproto::scc_info_Planned.base,
      &protobuf_egm_5fwrapper_2eproto::scc_info_Status.base,}};

static void InitDefaultsOutput() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Output_default_instance_;
    new (ptr) ::abb::egm::wrapper::Output();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Output::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_Output =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsOutput}, {
      &protobuf_egm_5fwrapper_2eproto::scc_info_Robot.base,
      &protobuf_egm_5fwrapper_2eproto::scc_info_External.base,}};

void InitDefaults() {
  ::google::protobuf::internal::InitSCC(&scc_info_Header.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Status.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Clock.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Joints.base);
  ::google::protobuf::internal::InitSCC(&scc_info_JointSpace.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Cartesian.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Euler.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Quaternion.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CartesianPose.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CartesianVelocity.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CartesianSpace.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Robot.base);
  ::google::protobuf::internal::InitSCC(&scc_info_External.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Feedback.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Planned.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Input.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Output.base);
}

::google::protobuf::Metadata file_level_metadata[17];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[6];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Header, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Header, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Header, sequence_number_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Header, time_stamp_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Header, message_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Header, rw_version_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Header, egm_version_),
  0,
  1,
  2,
  3,
  4,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Status, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Status, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Status, egm_convergence_met_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Status, egm_state_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Status, motor_state_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Status, rapid_execution_state_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Status, utilization_rate_),
  0,
  1,
  2,
  3,
  4,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Clock, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Clock, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Clock, sec_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Clock, usec_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Joints, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Joints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Joints, values_),
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::JointSpace, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::JointSpace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::JointSpace, position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::JointSpace, velocity_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, y_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, z_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Euler, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Euler, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Euler, x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Euler, y_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Euler, z_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, u0_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, u1_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, u2_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, u3_),
  0,
  1,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, euler_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, quaternion_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianVelocity, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianVelocity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianVelocity, linear_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianVelocity, angular_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianSpace, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianSpace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianSpace, pose_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::CartesianSpace, velocity_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Robot, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Robot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Robot, joints_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Robot, cartesian_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::External, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::External, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::External, joints_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Feedback, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Feedback, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Feedback, robot_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Feedback, external_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Feedback, time_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Planned, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Planned, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Planned, robot_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Planned, external_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Planned, time_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Input, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Input, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Input, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Input, feedback_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Input, planned_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Input, status_),
  0,
  1,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Output, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Output, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Output, robot_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::wrapper::Output, external_),
  0,
  1,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, sizeof(::abb::egm::wrapper::Header)},
  { 15, 25, sizeof(::abb::egm::wrapper::Status)},
  { 30, 37, sizeof(::abb::egm::wrapper::Clock)},
  { 39, 45, sizeof(::abb::egm::wrapper::Joints)},
  { 46, 53, sizeof(::abb::egm::wrapper::JointSpace)},
  { 55, 63, sizeof(::abb::egm::wrapper::Cartesian)},
  { 66, 74, sizeof(::abb::egm::wrapper::Euler)},
  { 77, 86, sizeof(::abb::egm::wrapper::Quaternion)},
  { 90, 98, sizeof(::abb::egm::wrapper::CartesianPose)},
  { 101, 108, sizeof(::abb::egm::wrapper::CartesianVelocity)},
  { 110, 117, sizeof(::abb::egm::wrapper::CartesianSpace)},
  { 119, 126, sizeof(::abb::egm::wrapper::Robot)},
  { 128, 134, sizeof(::abb::egm::wrapper::External)},
  { 135, 143, sizeof(::abb::egm::wrapper::Feedback)},
  { 146, 154, sizeof(::abb::egm::wrapper::Planned)},
  { 157, 166, sizeof(::abb::egm::wrapper::Input)},
  { 170, 177, sizeof(::abb::egm::wrapper::Output)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Header_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Status_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Clock_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Joints_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_JointSpace_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Cartesian_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Euler_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Quaternion_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_CartesianPose_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_CartesianVelocity_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_CartesianSpace_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Robot_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_External_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Feedback_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Planned_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Input_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Output_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  AssignDescriptors(
      "egm_wrapper.proto", schemas, file_default_instances, TableStruct::offsets,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 17);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\021egm_wrapper.proto\022\017abb.egm.wrapper\"\330\003\n"
      "\006Header\022\027\n\017sequence_number\030\001 \001(\r\022\022\n\ntime"
      "_stamp\030\002 \001(\r\022D\n\014message_type\030\003 \001(\0162#.abb"
      ".egm.wrapper.Header.MessageType:\tUNDEFIN"
      "ED\022A\n\nrw_version\030\004 \001(\0162!.abb.egm.wrapper"
      ".Header.RWVersion:\nRW_UNKNOWN\022D\n\013egm_ver"
      "sion\030\005 \001(\0162\".abb.egm.wrapper.Header.EGMV"
      "ersion:\013EGM_UNKNOWN\"&\n\013MessageType\022\r\n\tUN"
      "DEFINED\020\000\022\010\n\004DATA\020\001\"q\n\tRWVersion\022\016\n\nRW_U"
      "NKNOWN\020\000\022\025\n\021RW_6_10_AND_NEWER\020\001\022\034\n\030RW_BE"
      "TWEEN_6_AND_6_06_03\020\002\022\037\n\033RW_BETWEEN_6_07"
      "_AND_6_09_02\020\003\"7\n\nEGMVersion\022\017\n\013EGM_UNKN"
      "OWN\020\000\022\013\n\007EGM_1_0\020\001\022\013\n\007EGM_1_1\020\002\"\220\004\n\006Stat"
      "us\022\033\n\023egm_convergence_met\030\001 \001(\010\022B\n\tegm_s"
      "tate\030\002 \001(\0162 .abb.egm.wrapper.Status.EGMS"
      "tate:\rEGM_UNDEFINED\022I\n\013motor_state\030\003 \001(\016"
      "2\".abb.egm.wrapper.Status.MotorState:\020MO"
      "TORS_UNDEFINED\022[\n\025rapid_execution_state\030"
      "\004 \001(\0162+.abb.egm.wrapper.Status.RAPIDExec"
      "utionState:\017RAPID_UNDEFINED\022\030\n\020utilizati"
      "on_rate\030\005 \001(\001\"N\n\010EGMState\022\021\n\rEGM_UNDEFIN"
      "ED\020\000\022\r\n\tEGM_ERROR\020\001\022\017\n\013EGM_STOPPED\020\002\022\017\n\013"
      "EGM_RUNNING\020\003\"A\n\nMotorState\022\024\n\020MOTORS_UN"
      "DEFINED\020\000\022\r\n\tMOTORS_ON\020\001\022\016\n\nMOTORS_OFF\020\002"
      "\"P\n\023RAPIDExecutionState\022\023\n\017RAPID_UNDEFIN"
      "ED\020\000\022\021\n\rRAPID_STOPPED\020\001\022\021\n\rRAPID_RUNNING"
      "\020\002\"\"\n\005Clock\022\013\n\003sec\030\001 \001(\004\022\014\n\004usec\030\002 \001(\004\"\030"
      "\n\006Joints\022\016\n\006values\030\001 \003(\001\"b\n\nJointSpace\022)"
      "\n\010position\030\001 \001(\0132\027.abb.egm.wrapper.Joint"
      "s\022)\n\010velocity\030\002 \001(\0132\027.abb.egm.wrapper.Jo"
      "ints\",\n\tCartesian\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022"
      "\t\n\001z\030\003 \001(\001\"(\n\005Euler\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001("
      "\001\022\t\n\001z\030\003 \001(\001\"<\n\nQuaternion\022\n\n\002u0\030\001 \001(\001\022\n"
      "\n\002u1\030\002 \001(\001\022\n\n\002u2\030\003 \001(\001\022\n\n\002u3\030\004 \001(\001\"\225\001\n\rC"
      "artesianPose\022,\n\010position\030\001 \001(\0132\032.abb.egm"
      ".wrapper.Cartesian\022%\n\005euler\030\002 \001(\0132\026.abb."
      "egm.wrapper.Euler\022/\n\nquaternion\030\003 \001(\0132\033."
      "abb.egm.wrapper.Quaternion\"h\n\021CartesianV"
      "elocity\022*\n\006linear\030\001 \001(\0132\032.abb.egm.wrappe"
      "r.Cartesian\022\'\n\007angular\030\002 \001(\0132\026.abb.egm.w"
      "rapper.Euler\"t\n\016CartesianSpace\022,\n\004pose\030\001"
      " \001(\0132\036.abb.egm.wrapper.CartesianPose\0224\n\010"
      "velocity\030\002 \001(\0132\".abb.egm.wrapper.Cartesi"
      "anVelocity\"h\n\005Robot\022+\n\006joints\030\001 \001(\0132\033.ab"
      "b.egm.wrapper.JointSpace\0222\n\tcartesian\030\002 "
      "\001(\0132\037.abb.egm.wrapper.CartesianSpace\"7\n\010"
      "External\022+\n\006joints\030\001 \001(\0132\033.abb.egm.wrapp"
      "er.JointSpace\"\204\001\n\010Feedback\022%\n\005robot\030\001 \001("
      "\0132\026.abb.egm.wrapper.Robot\022+\n\010external\030\002 "
      "\001(\0132\031.abb.egm.wrapper.External\022$\n\004time\030\003"
      " \001(\0132\026.abb.egm.wrapper.Clock\"\203\001\n\007Planned"
      "\022%\n\005robot\030\001 \001(\0132\026.abb.egm.wrapper.Robot\022"
      "+\n\010external\030\002 \001(\0132\031.abb.egm.wrapper.Exte"
      "rnal\022$\n\004time\030\003 \001(\0132\026.abb.egm.wrapper.Clo"
      "ck\"\261\001\n\005Input\022\'\n\006header\030\001 \001(\0132\027.abb.egm.w"
      "rapper.Header\022+\n\010feedback\030\002 \001(\0132\031.abb.eg"
      "m.wrapper.Feedback\022)\n\007planned\030\003 \001(\0132\030.ab"
      "b.egm.wrapper.Planned\022\'\n\006status\030\004 \001(\0132\027."
      "abb.egm.wrapper.Status\"\\\n\006Output\022%\n\005robo"
      "t\030\001 \001(\0132\026.abb.egm.wrapper.Robot\022+\n\010exter"
      "nal\030\002 \001(\0132\031.abb.egm.wrapper.External"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 2436);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "egm_wrapper.proto", &protobuf_RegisterTypes);
}

void AddDescriptors() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_egm_5fwrapper_2eproto
namespace abb {
namespace egm {
namespace wrapper {
const ::google::protobuf::EnumDescriptor* Header_MessageType_descriptor() {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_egm_5fwrapper_2eproto::file_level_enum_descriptors[0];
}
bool Header_MessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Header_MessageType Header::UNDEFINED;
const Header_MessageType Header::DATA;
const Header_MessageType Header::MessageType_MIN;
const Header_MessageType Header::MessageType_MAX;
const int Header::MessageType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Header_RWVersion_descriptor() {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_egm_5fwrapper_2eproto::file_level_enum_descriptors[1];
}
bool Header_RWVersion_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Header_RWVersion Header::RW_UNKNOWN;
const Header_RWVersion Header::RW_6_10_AND_NEWER;
const Header_RWVersion Header::RW_BETWEEN_6_AND_6_06_03;
const Header_RWVersion Header::RW_BETWEEN_6_07_AND_6_09_02;
const Header_RWVersion Header::RWVersion_MIN;
const Header_RWVersion Header::RWVersion_MAX;
const int Header::RWVersion_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Header_EGMVersion_descriptor() {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_egm_5fwrapper_2eproto::file_level_enum_descriptors[2];
}
bool Header_EGMVersion_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Header_EGMVersion Header::EGM_UNKNOWN;
const Header_EGMVersion Header::EGM_1_0;
const Header_EGMVersion Header::EGM_1_1;
const Header_EGMVersion Header::EGMVersion_MIN;
const Header_EGMVersion Header::EGMVersion_MAX;
const int Header::EGMVersion_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Status_EGMState_descriptor() {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_egm_5fwrapper_2eproto::file_level_enum_descriptors[3];
}
bool Status_EGMState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Status_EGMState Status::EGM_UNDEFINED;
const Status_EGMState Status::EGM_ERROR;
const Status_EGMState Status::EGM_STOPPED;
const Status_EGMState Status::EGM_RUNNING;
const Status_EGMState Status::EGMState_MIN;
const Status_EGMState Status::EGMState_MAX;
const int Status::EGMState_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Status_MotorState_descriptor() {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_egm_5fwrapper_2eproto::file_level_enum_descriptors[4];
}
bool Status_MotorState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Status_MotorState Status::MOTORS_UNDEFINED;
const Status_MotorState Status::MOTORS_ON;
const Status_MotorState Status::MOTORS_OFF;
const Status_MotorState Status::MotorState_MIN;
const Status_MotorState Status::MotorState_MAX;
const int Status::MotorState_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Status_RAPIDExecutionState_descriptor() {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_egm_5fwrapper_2eproto::file_level_enum_descriptors[5];
}
bool Status_RAPIDExecutionState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Status_RAPIDExecutionState Status::RAPID_UNDEFINED;
const Status_RAPIDExecutionState Status::RAPID_STOPPED;
const Status_RAPIDExecutionState Status::RAPID_RUNNING;
const Status_RAPIDExecutionState Status::RAPIDExecutionState_MIN;
const Status_RAPIDExecutionState Status::RAPIDExecutionState_MAX;
const int Status::RAPIDExecutionState_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

void Header::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Header::kSequenceNumberFieldNumber;
const int Header::kTimeStampFieldNumber;
const int Header::kMessageTypeFieldNumber;
const int Header::kRwVersionFieldNumber;
const int Header::kEgmVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Header::Header()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_Header.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Header)
}
Header::Header(const Header& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&sequence_number_, &from.sequence_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&egm_version_) -
    reinterpret_cast<char*>(&sequence_number_)) + sizeof(egm_version_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Header)
}

void Header::SharedCtor() {
  ::memset(&sequence_number_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&egm_version_) -
      reinterpret_cast<char*>(&sequence_number_)) + sizeof(egm_version_));
}

Header::~Header() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Header)
  SharedDtor();
}

void Header::SharedDtor() {
}

void Header::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Header::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Header& Header::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_Header.base);
  return *internal_default_instance();
}


void Header::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Header)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    ::memset(&sequence_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&egm_version_) -
        reinterpret_cast<char*>(&sequence_number_)) + sizeof(egm_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Header::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Header)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sequence_number = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_sequence_number();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequence_number_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 time_stamp = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_time_stamp();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Header_MessageType_IsValid(value)) {
            set_message_type(static_cast< ::abb::egm::wrapper::Header_MessageType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Header.RWVersion rw_version = 4 [default = RW_UNKNOWN];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Header_RWVersion_IsValid(value)) {
            set_rw_version(static_cast< ::abb::egm::wrapper::Header_RWVersion >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Header.EGMVersion egm_version = 5 [default = EGM_UNKNOWN];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Header_EGMVersion_IsValid(value)) {
            set_egm_version(static_cast< ::abb::egm::wrapper::Header_EGMVersion >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                5, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Header)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Header)
  return false;
#undef DO_
}

void Header::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Header)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sequence_number = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sequence_number(), output);
  }

  // optional uint32 time_stamp = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->message_type(), output);
  }

  // optional .abb.egm.wrapper.Header.RWVersion rw_version = 4 [default = RW_UNKNOWN];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->rw_version(), output);
  }

  // optional .abb.egm.wrapper.Header.EGMVersion egm_version = 5 [default = EGM_UNKNOWN];
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->egm_version(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Header)
}

::google::protobuf::uint8* Header::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Header)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sequence_number = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sequence_number(), target);
  }

  // optional uint32 time_stamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->message_type(), target);
  }

  // optional .abb.egm.wrapper.Header.RWVersion rw_version = 4 [default = RW_UNKNOWN];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->rw_version(), target);
  }

  // optional .abb.egm.wrapper.Header.EGMVersion egm_version = 5 [default = EGM_UNKNOWN];
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->egm_version(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Header)
  return target;
}

size_t Header::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Header)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 31u) {
    // optional uint32 sequence_number = 1;
    if (has_sequence_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequence_number());
    }

    // optional uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
    if (has_message_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->message_type());
    }

    // optional .abb.egm.wrapper.Header.RWVersion rw_version = 4 [default = RW_UNKNOWN];
    if (has_rw_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->rw_version());
    }

    // optional .abb.egm.wrapper.Header.EGMVersion egm_version = 5 [default = EGM_UNKNOWN];
    if (has_egm_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->egm_version());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Header::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Header)
  GOOGLE_DCHECK_NE(&from, this);
  const Header* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Header>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Header)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Header)
    MergeFrom(*source);
  }
}

void Header::MergeFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Header)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      sequence_number_ = from.sequence_number_;
    }
    if (cached_has_bits & 0x00000002u) {
      time_stamp_ = from.time_stamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      message_type_ = from.message_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      rw_version_ = from.rw_version_;
    }
    if (cached_has_bits & 0x00000010u) {
      egm_version_ = from.egm_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Header::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Header::CopyFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Header::IsInitialized() const {
  return true;
}

void Header::Swap(Header* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Header::InternalSwap(Header* other) {
  using std::swap;
  swap(sequence_number_, other->sequence_number_);
  swap(time_stamp_, other->time_stamp_);
  swap(message_type_, other->message_type_);
  swap(rw_version_, other->rw_version_);
  swap(egm_version_, other->egm_version_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Header::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Status::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Status::kEgmConvergenceMetFieldNumber;
const int Status::kEgmStateFieldNumber;
const int Status::kMotorStateFieldNumber;
const int Status::kRapidExecutionStateFieldNumber;
const int Status::kUtilizationRateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Status::Status()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_Status.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Status)
}
Status::Status(const Status& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&egm_convergence_met_, &from.egm_convergence_met_,
    static_cast<size_t>(reinterpret_cast<char*>(&utilization_rate_) -
    reinterpret_cast<char*>(&egm_convergence_met_)) + sizeof(utilization_rate_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Status)
}

void Status::SharedCtor() {
  ::memset(&egm_convergence_met_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&utilization_rate_) -
      reinterpret_cast<char*>(&egm_convergence_met_)) + sizeof(utilization_rate_));
}

Status::~Status() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Status)
  SharedDtor();
}

void Status::SharedDtor() {
}

void Status::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Status::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Status& Status::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_Status.base);
  return *internal_default_instance();
}


void Status::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Status)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    ::memset(&egm_convergence_met_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&utilization_rate_) -
        reinterpret_cast<char*>(&egm_convergence_met_)) + sizeof(utilization_rate_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Status::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Status)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool egm_convergence_met = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_egm_convergence_met();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &egm_convergence_met_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Status_EGMState_IsValid(value)) {
            set_egm_state(static_cast< ::abb::egm::wrapper::Status_EGMState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Status_MotorState_IsValid(value)) {
            set_motor_state(static_cast< ::abb::egm::wrapper::Status_MotorState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Status_RAPIDExecutionState_IsValid(value)) {
            set_rapid_execution_state(static_cast< ::abb::egm::wrapper::Status_RAPIDExecutionState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double utilization_rate = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(41u /* 41 & 0xFF */)) {
          set_has_utilization_rate();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &utilization_rate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Status)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Status)
  return false;
#undef DO_
}

void Status::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Status)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool egm_convergence_met = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->egm_convergence_met(), output);
  }

  // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->egm_state(), output);
  }

  // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->motor_state(), output);
  }

  // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->rapid_execution_state(), output);
  }

  // optional double utilization_rate = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->utilization_rate(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Status)
}

::google::protobuf::uint8* Status::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Status)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool egm_convergence_met = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->egm_convergence_met(), target);
  }

  // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->egm_state(), target);
  }

  // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->motor_state(), target);
  }

  // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->rapid_execution_state(), target);
  }

  // optional double utilization_rate = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->utilization_rate(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Status)
  return target;
}

size_t Status::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Status)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 31u) {
    // optional bool egm_convergence_met = 1;
    if (has_egm_convergence_met()) {
      total_size += 1 + 1;
    }

    // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
    if (has_egm_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->egm_state());
    }

    // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
    if (has_motor_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->motor_state());
    }

    // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
    if (has_rapid_execution_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->rapid_execution_state());
    }

    // optional double utilization_rate = 5;
    if (has_utilization_rate()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Status::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Status)
  GOOGLE_DCHECK_NE(&from, this);
  const Status* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Status>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Status)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Status)
    MergeFrom(*source);
  }
}

void Status::MergeFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Status)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      egm_convergence_met_ = from.egm_convergence_met_;
    }
    if (cached_has_bits & 0x00000002u) {
      egm_state_ = from.egm_state_;
    }
    if (cached_has_bits & 0x00000004u) {
      motor_state_ = from.motor_state_;
    }
    if (cached_has_bits & 0x00000008u) {
      rapid_execution_state_ = from.rapid_execution_state_;
    }
    if (cached_has_bits & 0x00000010u) {
      utilization_rate_ = from.utilization_rate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Status::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Status::CopyFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {
  return true;
}

void Status::Swap(Status* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Status::InternalSwap(Status* other) {
  using std::swap;
  swap(egm_convergence_met_, other->egm_convergence_met_);
  swap(egm_state_, other->egm_state_);
  swap(motor_state_, other->motor_state_);
  swap(rapid_execution_state_, other->rapid_execution_state_);
  swap(utilization_rate_, other->utilization_rate_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Status::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Clock::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Clock::kSecFieldNumber;
const int Clock::kUsecFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Clock::Clock()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_Clock.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Clock)
}
Clock::Clock(const Clock& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&sec_, &from.sec_,
    static_cast<size_t>(reinterpret_cast<char*>(&usec_) -
    reinterpret_cast<char*>(&sec_)) + sizeof(usec_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Clock)
}

void Clock::SharedCtor() {
  ::memset(&sec_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&usec_) -
      reinterpret_cast<char*>(&sec_)) + sizeof(usec_));
}

Clock::~Clock() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Clock)
  SharedDtor();
}

void Clock::SharedDtor() {
}

void Clock::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Clock::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Clock& Clock::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_Clock.base);
  return *internal_default_instance();
}


void Clock::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Clock)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    ::memset(&sec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&usec_) -
        reinterpret_cast<char*>(&sec_)) + sizeof(usec_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Clock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Clock)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 sec = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_sec();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 usec = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_usec();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &usec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Clock)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Clock)
  return false;
#undef DO_
}

void Clock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Clock)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sec = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sec(), output);
  }

  // optional uint64 usec = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->usec(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Clock)
}

::google::protobuf::uint8* Clock::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Clock)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->sec(), target);
  }

  // optional uint64 usec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->usec(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Clock)
  return target;
}

size_t Clock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Clock)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional uint64 sec = 1;
    if (has_sec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sec());
    }

    // optional uint64 usec = 2;
    if (has_usec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->usec());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Clock::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Clock)
  GOOGLE_DCHECK_NE(&from, this);
  const Clock* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Clock>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Clock)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Clock)
    MergeFrom(*source);
  }
}

void Clock::MergeFrom(const Clock& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Clock)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      sec_ = from.sec_;
    }
    if (cached_has_bits & 0x00000002u) {
      usec_ = from.usec_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Clock::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Clock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Clock::CopyFrom(const Clock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Clock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Clock::IsInitialized() const {
  return true;
}

void Clock::Swap(Clock* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Clock::InternalSwap(Clock* other) {
  using std::swap;
  swap(sec_, other->sec_);
  swap(usec_, other->usec_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Clock::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Joints::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Joints::kValuesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Joints::Joints()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_Joints.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Joints)
}
Joints::Joints(const Joints& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      values_(from.values_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Joints)
}

void Joints::SharedCtor() {
}

Joints::~Joints() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Joints)
  SharedDtor();
}

void Joints::SharedDtor() {
}

void Joints::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Joints::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Joints& Joints::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_Joints.base);
  return *internal_default_instance();
}


void Joints::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Joints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Joints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Joints)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double values = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9u, input, this->mutable_values())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_values())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Joints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Joints)
  return false;
#undef DO_
}

void Joints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Joints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double values = 1;
  for (int i = 0, n = this->values_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      1, this->values(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Joints)
}

::google::protobuf::uint8* Joints::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Joints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double values = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(1, this->values_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Joints)
  return target;
}

size_t Joints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Joints)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated double values = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->values_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->values_size());
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Joints::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Joints)
  GOOGLE_DCHECK_NE(&from, this);
  const Joints* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Joints>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Joints)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Joints)
    MergeFrom(*source);
  }
}

void Joints::MergeFrom(const Joints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Joints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
}

void Joints::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Joints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Joints::CopyFrom(const Joints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Joints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Joints::IsInitialized() const {
  return true;
}

void Joints::Swap(Joints* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Joints::InternalSwap(Joints* other) {
  using std::swap;
  values_.InternalSwap(&other->values_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Joints::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void JointSpace::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_JointSpace_default_instance_._instance.get_mutable()->position_ = const_cast< ::abb::egm::wrapper::Joints*>(
      ::abb::egm::wrapper::Joints::internal_default_instance());
  ::abb::egm::wrapper::_JointSpace_default_instance_._instance.get_mutable()->velocity_ = const_cast< ::abb::egm::wrapper::Joints*>(
      ::abb::egm::wrapper::Joints::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int JointSpace::kPositionFieldNumber;
const int JointSpace::kVelocityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

JointSpace::JointSpace()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_JointSpace.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.JointSpace)
}
JointSpace::JointSpace(const JointSpace& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    position_ = new ::abb::egm::wrapper::Joints(*from.position_);
  } else {
    position_ = NULL;
  }
  if (from.has_velocity()) {
    velocity_ = new ::abb::egm::wrapper::Joints(*from.velocity_);
  } else {
    velocity_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.JointSpace)
}

void JointSpace::SharedCtor() {
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&velocity_) -
      reinterpret_cast<char*>(&position_)) + sizeof(velocity_));
}

JointSpace::~JointSpace() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.JointSpace)
  SharedDtor();
}

void JointSpace::SharedDtor() {
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete velocity_;
}

void JointSpace::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* JointSpace::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const JointSpace& JointSpace::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_JointSpace.base);
  return *internal_default_instance();
}


void JointSpace::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.JointSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(position_ != NULL);
      position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(velocity_ != NULL);
      velocity_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool JointSpace::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.JointSpace)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Joints position = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Joints velocity = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.JointSpace)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.JointSpace)
  return false;
#undef DO_
}

void JointSpace::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.JointSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Joints position = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_position(), output);
  }

  // optional .abb.egm.wrapper.Joints velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_velocity(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.JointSpace)
}

::google::protobuf::uint8* JointSpace::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.JointSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Joints position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_position(), deterministic, target);
  }

  // optional .abb.egm.wrapper.Joints velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_velocity(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.JointSpace)
  return target;
}

size_t JointSpace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.JointSpace)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .abb.egm.wrapper.Joints position = 1;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *position_);
    }

    // optional .abb.egm.wrapper.Joints velocity = 2;
    if (has_velocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *velocity_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void JointSpace::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.JointSpace)
  GOOGLE_DCHECK_NE(&from, this);
  const JointSpace* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const JointSpace>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.JointSpace)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.JointSpace)
    MergeFrom(*source);
  }
}

void JointSpace::MergeFrom(const JointSpace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.JointSpace)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_position()->::abb::egm::wrapper::Joints::MergeFrom(from.position());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_velocity()->::abb::egm::wrapper::Joints::MergeFrom(from.velocity());
    }
  }
}

void JointSpace::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.JointSpace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JointSpace::CopyFrom(const JointSpace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.JointSpace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JointSpace::IsInitialized() const {
  return true;
}

void JointSpace::Swap(JointSpace* other) {
  if (other == this) return;
  InternalSwap(other);
}
void JointSpace::InternalSwap(JointSpace* other) {
  using std::swap;
  swap(position_, other->position_);
  swap(velocity_, other->velocity_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata JointSpace::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Cartesian::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Cartesian::kXFieldNumber;
const int Cartesian::kYFieldNumber;
const int Cartesian::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Cartesian::Cartesian()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_Cartesian.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Cartesian)
}
Cartesian::Cartesian(const Cartesian& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Cartesian)
}

void Cartesian::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Cartesian::~Cartesian() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Cartesian)
  SharedDtor();
}

void Cartesian::SharedDtor() {
}

void Cartesian::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Cartesian::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Cartesian& Cartesian::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_Cartesian.base);
  return *internal_default_instance();
}


void Cartesian::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Cartesian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Cartesian::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Cartesian)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          set_has_x();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u /* 17 & 0xFF */)) {
          set_has_y();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u /* 25 & 0xFF */)) {
          set_has_z();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Cartesian)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Cartesian)
  return false;
#undef DO_
}

void Cartesian::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Cartesian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Cartesian)
}

::google::protobuf::uint8* Cartesian::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Cartesian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Cartesian)
  return target;
}

size_t Cartesian::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Cartesian)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (has_y()) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (has_z()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Cartesian::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Cartesian)
  GOOGLE_DCHECK_NE(&from, this);
  const Cartesian* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Cartesian>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Cartesian)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Cartesian)
    MergeFrom(*source);
  }
}

void Cartesian::MergeFrom(const Cartesian& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Cartesian)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Cartesian::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Cartesian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Cartesian::CopyFrom(const Cartesian& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Cartesian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cartesian::IsInitialized() const {
  return true;
}

void Cartesian::Swap(Cartesian* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Cartesian::InternalSwap(Cartesian* other) {
  using std::swap;
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Cartesian::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Euler::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Euler::kXFieldNumber;
const int Euler::kYFieldNumber;
const int Euler::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Euler::Euler()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_Euler.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Euler)
}
Euler::Euler(const Euler& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Euler)
}

void Euler::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Euler::~Euler() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Euler)
  SharedDtor();
}

void Euler::SharedDtor() {
}

void Euler::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Euler::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Euler& Euler::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_Euler.base);
  return *internal_default_instance();
}


void Euler::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Euler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Euler::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Euler)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          set_has_x();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u /* 17 & 0xFF */)) {
          set_has_y();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u /* 25 & 0xFF */)) {
          set_has_z();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Euler)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Euler)
  return false;
#undef DO_
}

void Euler::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Euler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Euler)
}

::google::protobuf::uint8* Euler::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Euler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Euler)
  return target;
}

size_t Euler::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Euler)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (has_y()) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (has_z()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Euler::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Euler)
  GOOGLE_DCHECK_NE(&from, this);
  const Euler* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Euler>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Euler)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Euler)
    MergeFrom(*source);
  }
}

void Euler::MergeFrom(const Euler& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Euler)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Euler::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Euler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Euler::CopyFrom(const Euler& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Euler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Euler::IsInitialized() const {
  return true;
}

void Euler::Swap(Euler* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Euler::InternalSwap(Euler* other) {
  using std::swap;
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Euler::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Quaternion::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Quaternion::kU0FieldNumber;
const int Quaternion::kU1FieldNumber;
const int Quaternion::kU2FieldNumber;
const int Quaternion::kU3FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Quaternion::Quaternion()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_Quaternion.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Quaternion)
}
Quaternion::Quaternion(const Quaternion& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&u0_, &from.u0_,
    static_cast<size_t>(reinterpret_cast<char*>(&u3_) -
    reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Quaternion)
}

void Quaternion::SharedCtor() {
  ::memset(&u0_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&u3_) -
      reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
}

Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Quaternion)
  SharedDtor();
}

void Quaternion::SharedDtor() {
}

void Quaternion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Quaternion::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Quaternion& Quaternion::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_Quaternion.base);
  return *internal_default_instance();
}


void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Quaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    ::memset(&u0_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&u3_) -
        reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Quaternion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Quaternion)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double u0 = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          set_has_u0();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u0_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double u1 = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u /* 17 & 0xFF */)) {
          set_has_u1();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double u2 = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u /* 25 & 0xFF */)) {
          set_has_u2();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double u3 = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(33u /* 33 & 0xFF */)) {
          set_has_u3();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u3_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Quaternion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Quaternion)
  return false;
#undef DO_
}

void Quaternion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Quaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double u0 = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->u0(), output);
  }

  // optional double u1 = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->u1(), output);
  }

  // optional double u2 = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->u2(), output);
  }

  // optional double u3 = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->u3(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Quaternion)
}

::google::protobuf::uint8* Quaternion::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Quaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double u0 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->u0(), target);
  }

  // optional double u1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->u1(), target);
  }

  // optional double u2 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->u2(), target);
  }

  // optional double u3 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->u3(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Quaternion)
  return target;
}

size_t Quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Quaternion)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional double u0 = 1;
    if (has_u0()) {
      total_size += 1 + 8;
    }

    // optional double u1 = 2;
    if (has_u1()) {
      total_size += 1 + 8;
    }

    // optional double u2 = 3;
    if (has_u2()) {
      total_size += 1 + 8;
    }

    // optional double u3 = 4;
    if (has_u3()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Quaternion::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Quaternion)
  GOOGLE_DCHECK_NE(&from, this);
  const Quaternion* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Quaternion>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Quaternion)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Quaternion)
    MergeFrom(*source);
  }
}

void Quaternion::MergeFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Quaternion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      u0_ = from.u0_;
    }
    if (cached_has_bits & 0x00000002u) {
      u1_ = from.u1_;
    }
    if (cached_has_bits & 0x00000004u) {
      u2_ = from.u2_;
    }
    if (cached_has_bits & 0x00000008u) {
      u3_ = from.u3_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Quaternion::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quaternion::IsInitialized() const {
  return true;
}

void Quaternion::Swap(Quaternion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Quaternion::InternalSwap(Quaternion* other) {
  using std::swap;
  swap(u0_, other->u0_);
  swap(u1_, other->u1_);
  swap(u2_, other->u2_);
  swap(u3_, other->u3_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Quaternion::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void CartesianPose::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_CartesianPose_default_instance_._instance.get_mutable()->position_ = const_cast< ::abb::egm::wrapper::Cartesian*>(
      ::abb::egm::wrapper::Cartesian::internal_default_instance());
  ::abb::egm::wrapper::_CartesianPose_default_instance_._instance.get_mutable()->euler_ = const_cast< ::abb::egm::wrapper::Euler*>(
      ::abb::egm::wrapper::Euler::internal_default_instance());
  ::abb::egm::wrapper::_CartesianPose_default_instance_._instance.get_mutable()->quaternion_ = const_cast< ::abb::egm::wrapper::Quaternion*>(
      ::abb::egm::wrapper::Quaternion::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CartesianPose::kPositionFieldNumber;
const int CartesianPose::kEulerFieldNumber;
const int CartesianPose::kQuaternionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CartesianPose::CartesianPose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_CartesianPose.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.CartesianPose)
}
CartesianPose::CartesianPose(const CartesianPose& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    position_ = new ::abb::egm::wrapper::Cartesian(*from.position_);
  } else {
    position_ = NULL;
  }
  if (from.has_euler()) {
    euler_ = new ::abb::egm::wrapper::Euler(*from.euler_);
  } else {
    euler_ = NULL;
  }
  if (from.has_quaternion()) {
    quaternion_ = new ::abb::egm::wrapper::Quaternion(*from.quaternion_);
  } else {
    quaternion_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.CartesianPose)
}

void CartesianPose::SharedCtor() {
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&quaternion_) -
      reinterpret_cast<char*>(&position_)) + sizeof(quaternion_));
}

CartesianPose::~CartesianPose() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.CartesianPose)
  SharedDtor();
}

void CartesianPose::SharedDtor() {
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete euler_;
  if (this != internal_default_instance()) delete quaternion_;
}

void CartesianPose::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* CartesianPose::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CartesianPose& CartesianPose::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_CartesianPose.base);
  return *internal_default_instance();
}


void CartesianPose::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.CartesianPose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(position_ != NULL);
      position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(euler_ != NULL);
      euler_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(quaternion_ != NULL);
      quaternion_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool CartesianPose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.CartesianPose)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Cartesian position = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Euler euler = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_euler()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Quaternion quaternion = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_quaternion()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.CartesianPose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.CartesianPose)
  return false;
#undef DO_
}

void CartesianPose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.CartesianPose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Cartesian position = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_position(), output);
  }

  // optional .abb.egm.wrapper.Euler euler = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_euler(), output);
  }

  // optional .abb.egm.wrapper.Quaternion quaternion = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->_internal_quaternion(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.CartesianPose)
}

::google::protobuf::uint8* CartesianPose::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.CartesianPose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Cartesian position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_position(), deterministic, target);
  }

  // optional .abb.egm.wrapper.Euler euler = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_euler(), deterministic, target);
  }

  // optional .abb.egm.wrapper.Quaternion quaternion = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->_internal_quaternion(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.CartesianPose)
  return target;
}

size_t CartesianPose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.CartesianPose)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional .abb.egm.wrapper.Cartesian position = 1;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *position_);
    }

    // optional .abb.egm.wrapper.Euler euler = 2;
    if (has_euler()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *euler_);
    }

    // optional .abb.egm.wrapper.Quaternion quaternion = 3;
    if (has_quaternion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *quaternion_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CartesianPose::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.CartesianPose)
  GOOGLE_DCHECK_NE(&from, this);
  const CartesianPose* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CartesianPose>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.CartesianPose)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.CartesianPose)
    MergeFrom(*source);
  }
}

void CartesianPose::MergeFrom(const CartesianPose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.CartesianPose)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_position()->::abb::egm::wrapper::Cartesian::MergeFrom(from.position());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_euler()->::abb::egm::wrapper::Euler::MergeFrom(from.euler());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_quaternion()->::abb::egm::wrapper::Quaternion::MergeFrom(from.quaternion());
    }
  }
}

void CartesianPose::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.CartesianPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartesianPose::CopyFrom(const CartesianPose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.CartesianPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartesianPose::IsInitialized() const {
  return true;
}

void CartesianPose::Swap(CartesianPose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CartesianPose::InternalSwap(CartesianPose* other) {
  using std::swap;
  swap(position_, other->position_);
  swap(euler_, other->euler_);
  swap(quaternion_, other->quaternion_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata CartesianPose::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void CartesianVelocity::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_CartesianVelocity_default_instance_._instance.get_mutable()->linear_ = const_cast< ::abb::egm::wrapper::Cartesian*>(
      ::abb::egm::wrapper::Cartesian::internal_default_instance());
  ::abb::egm::wrapper::_CartesianVelocity_default_instance_._instance.get_mutable()->angular_ = const_cast< ::abb::egm::wrapper::Euler*>(
      ::abb::egm::wrapper::Euler::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CartesianVelocity::kLinearFieldNumber;
const int CartesianVelocity::kAngularFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CartesianVelocity::CartesianVelocity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_CartesianVelocity.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.CartesianVelocity)
}
CartesianVelocity::CartesianVelocity(const CartesianVelocity& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_linear()) {
    linear_ = new ::abb::egm::wrapper::Cartesian(*from.linear_);
  } else {
    linear_ = NULL;
  }
  if (from.has_angular()) {
    angular_ = new ::abb::egm::wrapper::Euler(*from.angular_);
  } else {
    angular_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.CartesianVelocity)
}

void CartesianVelocity::SharedCtor() {
  ::memset(&linear_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&angular_) -
      reinterpret_cast<char*>(&linear_)) + sizeof(angular_));
}

CartesianVelocity::~CartesianVelocity() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.CartesianVelocity)
  SharedDtor();
}

void CartesianVelocity::SharedDtor() {
  if (this != internal_default_instance()) delete linear_;
  if (this != internal_default_instance()) delete angular_;
}

void CartesianVelocity::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* CartesianVelocity::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CartesianVelocity& CartesianVelocity::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_CartesianVelocity.base);
  return *internal_default_instance();
}


void CartesianVelocity::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.CartesianVelocity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(linear_ != NULL);
      linear_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(angular_ != NULL);
      angular_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool CartesianVelocity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.CartesianVelocity)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Cartesian linear = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_linear()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Euler angular = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_angular()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.CartesianVelocity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.CartesianVelocity)
  return false;
#undef DO_
}

void CartesianVelocity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.CartesianVelocity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Cartesian linear = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_linear(), output);
  }

  // optional .abb.egm.wrapper.Euler angular = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_angular(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.CartesianVelocity)
}

::google::protobuf::uint8* CartesianVelocity::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.CartesianVelocity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Cartesian linear = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_linear(), deterministic, target);
  }

  // optional .abb.egm.wrapper.Euler angular = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_angular(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.CartesianVelocity)
  return target;
}

size_t CartesianVelocity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.CartesianVelocity)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .abb.egm.wrapper.Cartesian linear = 1;
    if (has_linear()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *linear_);
    }

    // optional .abb.egm.wrapper.Euler angular = 2;
    if (has_angular()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *angular_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CartesianVelocity::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.CartesianVelocity)
  GOOGLE_DCHECK_NE(&from, this);
  const CartesianVelocity* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CartesianVelocity>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.CartesianVelocity)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.CartesianVelocity)
    MergeFrom(*source);
  }
}

void CartesianVelocity::MergeFrom(const CartesianVelocity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.CartesianVelocity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_linear()->::abb::egm::wrapper::Cartesian::MergeFrom(from.linear());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_angular()->::abb::egm::wrapper::Euler::MergeFrom(from.angular());
    }
  }
}

void CartesianVelocity::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.CartesianVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartesianVelocity::CopyFrom(const CartesianVelocity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.CartesianVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartesianVelocity::IsInitialized() const {
  return true;
}

void CartesianVelocity::Swap(CartesianVelocity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CartesianVelocity::InternalSwap(CartesianVelocity* other) {
  using std::swap;
  swap(linear_, other->linear_);
  swap(angular_, other->angular_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata CartesianVelocity::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void CartesianSpace::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_CartesianSpace_default_instance_._instance.get_mutable()->pose_ = const_cast< ::abb::egm::wrapper::CartesianPose*>(
      ::abb::egm::wrapper::CartesianPose::internal_default_instance());
  ::abb::egm::wrapper::_CartesianSpace_default_instance_._instance.get_mutable()->velocity_ = const_cast< ::abb::egm::wrapper::CartesianVelocity*>(
      ::abb::egm::wrapper::CartesianVelocity::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CartesianSpace::kPoseFieldNumber;
const int CartesianSpace::kVelocityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CartesianSpace::CartesianSpace()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_CartesianSpace.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.CartesianSpace)
}
CartesianSpace::CartesianSpace(const CartesianSpace& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_pose()) {
    pose_ = new ::abb::egm::wrapper::CartesianPose(*from.pose_);
  } else {
    pose_ = NULL;
  }
  if (from.has_velocity()) {
    velocity_ = new ::abb::egm::wrapper::CartesianVelocity(*from.velocity_);
  } else {
    velocity_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.CartesianSpace)
}

void CartesianSpace::SharedCtor() {
  ::memset(&pose_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&velocity_) -
      reinterpret_cast<char*>(&pose_)) + sizeof(velocity_));
}

CartesianSpace::~CartesianSpace() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.CartesianSpace)
  SharedDtor();
}

void CartesianSpace::SharedDtor() {
  if (this != internal_default_instance()) delete pose_;
  if (this != internal_default_instance()) delete velocity_;
}

void CartesianSpace::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* CartesianSpace::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CartesianSpace& CartesianSpace::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_CartesianSpace.base);
  return *internal_default_instance();
}


void CartesianSpace::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.CartesianSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(pose_ != NULL);
      pose_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(velocity_ != NULL);
      velocity_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool CartesianSpace::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.CartesianSpace)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.CartesianPose pose = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.CartesianSpace)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.CartesianSpace)
  return false;
#undef DO_
}

void CartesianSpace::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.CartesianSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_pose(), output);
  }

  // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_velocity(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.CartesianSpace)
}

::google::protobuf::uint8* CartesianSpace::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.CartesianSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_pose(), deterministic, target);
  }

  // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_velocity(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.CartesianSpace)
  return target;
}

size_t CartesianSpace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.CartesianSpace)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .abb.egm.wrapper.CartesianPose pose = 1;
    if (has_pose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *pose_);
    }

    // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
    if (has_velocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *velocity_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CartesianSpace::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.CartesianSpace)
  GOOGLE_DCHECK_NE(&from, this);
  const CartesianSpace* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CartesianSpace>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.CartesianSpace)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.CartesianSpace)
    MergeFrom(*source);
  }
}

void CartesianSpace::MergeFrom(const CartesianSpace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.CartesianSpace)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_pose()->::abb::egm::wrapper::CartesianPose::MergeFrom(from.pose());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_velocity()->::abb::egm::wrapper::CartesianVelocity::MergeFrom(from.velocity());
    }
  }
}

void CartesianSpace::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.CartesianSpace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartesianSpace::CopyFrom(const CartesianSpace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.CartesianSpace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartesianSpace::IsInitialized() const {
  return true;
}

void CartesianSpace::Swap(CartesianSpace* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CartesianSpace::InternalSwap(CartesianSpace* other) {
  using std::swap;
  swap(pose_, other->pose_);
  swap(velocity_, other->velocity_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata CartesianSpace::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Robot::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Robot_default_instance_._instance.get_mutable()->joints_ = const_cast< ::abb::egm::wrapper::JointSpace*>(
      ::abb::egm::wrapper::JointSpace::internal_default_instance());
  ::abb::egm::wrapper::_Robot_default_instance_._instance.get_mutable()->cartesian_ = const_cast< ::abb::egm::wrapper::CartesianSpace*>(
      ::abb::egm::wrapper::CartesianSpace::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Robot::kJointsFieldNumber;
const int Robot::kCartesianFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Robot::Robot()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_Robot.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Robot)
}
Robot::Robot(const Robot& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_joints()) {
    joints_ = new ::abb::egm::wrapper::JointSpace(*from.joints_);
  } else {
    joints_ = NULL;
  }
  if (from.has_cartesian()) {
    cartesian_ = new ::abb::egm::wrapper::CartesianSpace(*from.cartesian_);
  } else {
    cartesian_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Robot)
}

void Robot::SharedCtor() {
  ::memset(&joints_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cartesian_) -
      reinterpret_cast<char*>(&joints_)) + sizeof(cartesian_));
}

Robot::~Robot() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Robot)
  SharedDtor();
}

void Robot::SharedDtor() {
  if (this != internal_default_instance()) delete joints_;
  if (this != internal_default_instance()) delete cartesian_;
}

void Robot::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Robot::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Robot& Robot::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_Robot.base);
  return *internal_default_instance();
}


void Robot::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Robot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(joints_ != NULL);
      joints_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(cartesian_ != NULL);
      cartesian_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Robot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Robot)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.JointSpace joints = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_cartesian()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Robot)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Robot)
  return false;
#undef DO_
}

void Robot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Robot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_joints(), output);
  }

  // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_cartesian(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Robot)
}

::google::protobuf::uint8* Robot::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Robot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_joints(), deterministic, target);
  }

  // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_cartesian(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Robot)
  return target;
}

size_t Robot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Robot)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .abb.egm.wrapper.JointSpace joints = 1;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *joints_);
    }

    // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
    if (has_cartesian()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *cartesian_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Robot::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Robot)
  GOOGLE_DCHECK_NE(&from, this);
  const Robot* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Robot>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Robot)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Robot)
    MergeFrom(*source);
  }
}

void Robot::MergeFrom(const Robot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Robot)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_joints()->::abb::egm::wrapper::JointSpace::MergeFrom(from.joints());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_cartesian()->::abb::egm::wrapper::CartesianSpace::MergeFrom(from.cartesian());
    }
  }
}

void Robot::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Robot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Robot::CopyFrom(const Robot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Robot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Robot::IsInitialized() const {
  return true;
}

void Robot::Swap(Robot* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Robot::InternalSwap(Robot* other) {
  using std::swap;
  swap(joints_, other->joints_);
  swap(cartesian_, other->cartesian_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Robot::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void External::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_External_default_instance_._instance.get_mutable()->joints_ = const_cast< ::abb::egm::wrapper::JointSpace*>(
      ::abb::egm::wrapper::JointSpace::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int External::kJointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

External::External()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_External.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.External)
}
External::External(const External& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_joints()) {
    joints_ = new ::abb::egm::wrapper::JointSpace(*from.joints_);
  } else {
    joints_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.External)
}

void External::SharedCtor() {
  joints_ = NULL;
}

External::~External() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.External)
  SharedDtor();
}

void External::SharedDtor() {
  if (this != internal_default_instance()) delete joints_;
}

void External::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* External::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const External& External::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_External.base);
  return *internal_default_instance();
}


void External::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.External)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(joints_ != NULL);
    joints_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool External::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.External)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.JointSpace joints = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.External)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.External)
  return false;
#undef DO_
}

void External::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.External)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_joints(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.External)
}

::google::protobuf::uint8* External::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.External)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_joints(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.External)
  return target;
}

size_t External::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.External)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (has_joints()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *joints_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void External::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.External)
  GOOGLE_DCHECK_NE(&from, this);
  const External* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const External>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.External)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.External)
    MergeFrom(*source);
  }
}

void External::MergeFrom(const External& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.External)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_joints()) {
    mutable_joints()->::abb::egm::wrapper::JointSpace::MergeFrom(from.joints());
  }
}

void External::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.External)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void External::CopyFrom(const External& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.External)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool External::IsInitialized() const {
  return true;
}

void External::Swap(External* other) {
  if (other == this) return;
  InternalSwap(other);
}
void External::InternalSwap(External* other) {
  using std::swap;
  swap(joints_, other->joints_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata External::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Feedback::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Feedback_default_instance_._instance.get_mutable()->robot_ = const_cast< ::abb::egm::wrapper::Robot*>(
      ::abb::egm::wrapper::Robot::internal_default_instance());
  ::abb::egm::wrapper::_Feedback_default_instance_._instance.get_mutable()->external_ = const_cast< ::abb::egm::wrapper::External*>(
      ::abb::egm::wrapper::External::internal_default_instance());
  ::abb::egm::wrapper::_Feedback_default_instance_._instance.get_mutable()->time_ = const_cast< ::abb::egm::wrapper::Clock*>(
      ::abb::egm::wrapper::Clock::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Feedback::kRobotFieldNumber;
const int Feedback::kExternalFieldNumber;
const int Feedback::kTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Feedback::Feedback()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_Feedback.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Feedback)
}
Feedback::Feedback(const Feedback& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_robot()) {
    robot_ = new ::abb::egm::wrapper::Robot(*from.robot_);
  } else {
    robot_ = NULL;
  }
  if (from.has_external()) {
    external_ = new ::abb::egm::wrapper::External(*from.external_);
  } else {
    external_ = NULL;
  }
  if (from.has_time()) {
    time_ = new ::abb::egm::wrapper::Clock(*from.time_);
  } else {
    time_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Feedback)
}

void Feedback::SharedCtor() {
  ::memset(&robot_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&time_) -
      reinterpret_cast<char*>(&robot_)) + sizeof(time_));
}

Feedback::~Feedback() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Feedback)
  SharedDtor();
}

void Feedback::SharedDtor() {
  if (this != internal_default_instance()) delete robot_;
  if (this != internal_default_instance()) delete external_;
  if (this != internal_default_instance()) delete time_;
}

void Feedback::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Feedback::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Feedback& Feedback::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_Feedback.base);
  return *internal_default_instance();
}


void Feedback::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Feedback)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(robot_ != NULL);
      robot_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(external_ != NULL);
      external_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(time_ != NULL);
      time_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Feedback::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Feedback)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Clock time = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Feedback)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Feedback)
  return false;
#undef DO_
}

void Feedback::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Feedback)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_robot(), output);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_external(), output);
  }

  // optional .abb.egm.wrapper.Clock time = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->_internal_time(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Feedback)
}

::google::protobuf::uint8* Feedback::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Feedback)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_robot(), deterministic, target);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_external(), deterministic, target);
  }

  // optional .abb.egm.wrapper.Clock time = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->_internal_time(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Feedback)
  return target;
}

size_t Feedback::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Feedback)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional .abb.egm.wrapper.Robot robot = 1;
    if (has_robot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *robot_);
    }

    // optional .abb.egm.wrapper.External external = 2;
    if (has_external()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *external_);
    }

    // optional .abb.egm.wrapper.Clock time = 3;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *time_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Feedback::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Feedback)
  GOOGLE_DCHECK_NE(&from, this);
  const Feedback* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Feedback>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Feedback)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Feedback)
    MergeFrom(*source);
  }
}

void Feedback::MergeFrom(const Feedback& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Feedback)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_robot()->::abb::egm::wrapper::Robot::MergeFrom(from.robot());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_external()->::abb::egm::wrapper::External::MergeFrom(from.external());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_time()->::abb::egm::wrapper::Clock::MergeFrom(from.time());
    }
  }
}

void Feedback::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Feedback)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Feedback::CopyFrom(const Feedback& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Feedback)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Feedback::IsInitialized() const {
  return true;
}

void Feedback::Swap(Feedback* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Feedback::InternalSwap(Feedback* other) {
  using std::swap;
  swap(robot_, other->robot_);
  swap(external_, other->external_);
  swap(time_, other->time_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Feedback::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Planned::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Planned_default_instance_._instance.get_mutable()->robot_ = const_cast< ::abb::egm::wrapper::Robot*>(
      ::abb::egm::wrapper::Robot::internal_default_instance());
  ::abb::egm::wrapper::_Planned_default_instance_._instance.get_mutable()->external_ = const_cast< ::abb::egm::wrapper::External*>(
      ::abb::egm::wrapper::External::internal_default_instance());
  ::abb::egm::wrapper::_Planned_default_instance_._instance.get_mutable()->time_ = const_cast< ::abb::egm::wrapper::Clock*>(
      ::abb::egm::wrapper::Clock::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Planned::kRobotFieldNumber;
const int Planned::kExternalFieldNumber;
const int Planned::kTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Planned::Planned()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_Planned.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Planned)
}
Planned::Planned(const Planned& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_robot()) {
    robot_ = new ::abb::egm::wrapper::Robot(*from.robot_);
  } else {
    robot_ = NULL;
  }
  if (from.has_external()) {
    external_ = new ::abb::egm::wrapper::External(*from.external_);
  } else {
    external_ = NULL;
  }
  if (from.has_time()) {
    time_ = new ::abb::egm::wrapper::Clock(*from.time_);
  } else {
    time_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Planned)
}

void Planned::SharedCtor() {
  ::memset(&robot_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&time_) -
      reinterpret_cast<char*>(&robot_)) + sizeof(time_));
}

Planned::~Planned() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Planned)
  SharedDtor();
}

void Planned::SharedDtor() {
  if (this != internal_default_instance()) delete robot_;
  if (this != internal_default_instance()) delete external_;
  if (this != internal_default_instance()) delete time_;
}

void Planned::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Planned::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Planned& Planned::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_Planned.base);
  return *internal_default_instance();
}


void Planned::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Planned)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(robot_ != NULL);
      robot_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(external_ != NULL);
      external_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(time_ != NULL);
      time_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Planned::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Planned)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Clock time = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Planned)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Planned)
  return false;
#undef DO_
}

void Planned::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Planned)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_robot(), output);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_external(), output);
  }

  // optional .abb.egm.wrapper.Clock time = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->_internal_time(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Planned)
}

::google::protobuf::uint8* Planned::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Planned)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_robot(), deterministic, target);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_external(), deterministic, target);
  }

  // optional .abb.egm.wrapper.Clock time = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->_internal_time(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Planned)
  return target;
}

size_t Planned::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Planned)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional .abb.egm.wrapper.Robot robot = 1;
    if (has_robot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *robot_);
    }

    // optional .abb.egm.wrapper.External external = 2;
    if (has_external()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *external_);
    }

    // optional .abb.egm.wrapper.Clock time = 3;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *time_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Planned::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Planned)
  GOOGLE_DCHECK_NE(&from, this);
  const Planned* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Planned>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Planned)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Planned)
    MergeFrom(*source);
  }
}

void Planned::MergeFrom(const Planned& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Planned)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_robot()->::abb::egm::wrapper::Robot::MergeFrom(from.robot());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_external()->::abb::egm::wrapper::External::MergeFrom(from.external());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_time()->::abb::egm::wrapper::Clock::MergeFrom(from.time());
    }
  }
}

void Planned::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Planned)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Planned::CopyFrom(const Planned& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Planned)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Planned::IsInitialized() const {
  return true;
}

void Planned::Swap(Planned* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Planned::InternalSwap(Planned* other) {
  using std::swap;
  swap(robot_, other->robot_);
  swap(external_, other->external_);
  swap(time_, other->time_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Planned::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Input::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Input_default_instance_._instance.get_mutable()->header_ = const_cast< ::abb::egm::wrapper::Header*>(
      ::abb::egm::wrapper::Header::internal_default_instance());
  ::abb::egm::wrapper::_Input_default_instance_._instance.get_mutable()->feedback_ = const_cast< ::abb::egm::wrapper::Feedback*>(
      ::abb::egm::wrapper::Feedback::internal_default_instance());
  ::abb::egm::wrapper::_Input_default_instance_._instance.get_mutable()->planned_ = const_cast< ::abb::egm::wrapper::Planned*>(
      ::abb::egm::wrapper::Planned::internal_default_instance());
  ::abb::egm::wrapper::_Input_default_instance_._instance.get_mutable()->status_ = const_cast< ::abb::egm::wrapper::Status*>(
      ::abb::egm::wrapper::Status::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Input::kHeaderFieldNumber;
const int Input::kFeedbackFieldNumber;
const int Input::kPlannedFieldNumber;
const int Input::kStatusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Input::Input()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_Input.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Input)
}
Input::Input(const Input& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::abb::egm::wrapper::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_feedback()) {
    feedback_ = new ::abb::egm::wrapper::Feedback(*from.feedback_);
  } else {
    feedback_ = NULL;
  }
  if (from.has_planned()) {
    planned_ = new ::abb::egm::wrapper::Planned(*from.planned_);
  } else {
    planned_ = NULL;
  }
  if (from.has_status()) {
    status_ = new ::abb::egm::wrapper::Status(*from.status_);
  } else {
    status_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Input)
}

void Input::SharedCtor() {
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&header_)) + sizeof(status_));
}

Input::~Input() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Input)
  SharedDtor();
}

void Input::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete feedback_;
  if (this != internal_default_instance()) delete planned_;
  if (this != internal_default_instance()) delete status_;
}

void Input::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Input::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Input& Input::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_Input.base);
  return *internal_default_instance();
}


void Input::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Input)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != NULL);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(feedback_ != NULL);
      feedback_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(planned_ != NULL);
      planned_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(status_ != NULL);
      status_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Input::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Input)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Feedback feedback = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_feedback()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Planned planned = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_planned()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Status status = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Input)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Input)
  return false;
#undef DO_
}

void Input::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Input)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Header header = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_header(), output);
  }

  // optional .abb.egm.wrapper.Feedback feedback = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_feedback(), output);
  }

  // optional .abb.egm.wrapper.Planned planned = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->_internal_planned(), output);
  }

  // optional .abb.egm.wrapper.Status status = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->_internal_status(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Input)
}

::google::protobuf::uint8* Input::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Input)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Header header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_header(), deterministic, target);
  }

  // optional .abb.egm.wrapper.Feedback feedback = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_feedback(), deterministic, target);
  }

  // optional .abb.egm.wrapper.Planned planned = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->_internal_planned(), deterministic, target);
  }

  // optional .abb.egm.wrapper.Status status = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->_internal_status(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Input)
  return target;
}

size_t Input::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Input)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional .abb.egm.wrapper.Header header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *header_);
    }

    // optional .abb.egm.wrapper.Feedback feedback = 2;
    if (has_feedback()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *feedback_);
    }

    // optional .abb.egm.wrapper.Planned planned = 3;
    if (has_planned()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *planned_);
    }

    // optional .abb.egm.wrapper.Status status = 4;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *status_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Input::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Input)
  GOOGLE_DCHECK_NE(&from, this);
  const Input* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Input>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Input)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Input)
    MergeFrom(*source);
  }
}

void Input::MergeFrom(const Input& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Input)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_header()->::abb::egm::wrapper::Header::MergeFrom(from.header());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_feedback()->::abb::egm::wrapper::Feedback::MergeFrom(from.feedback());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_planned()->::abb::egm::wrapper::Planned::MergeFrom(from.planned());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_status()->::abb::egm::wrapper::Status::MergeFrom(from.status());
    }
  }
}

void Input::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Input)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Input::CopyFrom(const Input& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Input)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Input::IsInitialized() const {
  return true;
}

void Input::Swap(Input* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Input::InternalSwap(Input* other) {
  using std::swap;
  swap(header_, other->header_);
  swap(feedback_, other->feedback_);
  swap(planned_, other->planned_);
  swap(status_, other->status_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Input::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Output::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Output_default_instance_._instance.get_mutable()->robot_ = const_cast< ::abb::egm::wrapper::Robot*>(
      ::abb::egm::wrapper::Robot::internal_default_instance());
  ::abb::egm::wrapper::_Output_default_instance_._instance.get_mutable()->external_ = const_cast< ::abb::egm::wrapper::External*>(
      ::abb::egm::wrapper::External::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Output::kRobotFieldNumber;
const int Output::kExternalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Output::Output()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_egm_5fwrapper_2eproto::scc_info_Output.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Output)
}
Output::Output(const Output& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_robot()) {
    robot_ = new ::abb::egm::wrapper::Robot(*from.robot_);
  } else {
    robot_ = NULL;
  }
  if (from.has_external()) {
    external_ = new ::abb::egm::wrapper::External(*from.external_);
  } else {
    external_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Output)
}

void Output::SharedCtor() {
  ::memset(&robot_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&external_) -
      reinterpret_cast<char*>(&robot_)) + sizeof(external_));
}

Output::~Output() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Output)
  SharedDtor();
}

void Output::SharedDtor() {
  if (this != internal_default_instance()) delete robot_;
  if (this != internal_default_instance()) delete external_;
}

void Output::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* Output::descriptor() {
  ::protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Output& Output::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_egm_5fwrapper_2eproto::scc_info_Output.base);
  return *internal_default_instance();
}


void Output::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Output)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(robot_ != NULL);
      robot_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(external_ != NULL);
      external_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Output::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Output)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Output)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Output)
  return false;
#undef DO_
}

void Output::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Output)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_robot(), output);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_external(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Output)
}

::google::protobuf::uint8* Output::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Output)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_robot(), deterministic, target);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_external(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Output)
  return target;
}

size_t Output::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Output)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .abb.egm.wrapper.Robot robot = 1;
    if (has_robot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *robot_);
    }

    // optional .abb.egm.wrapper.External external = 2;
    if (has_external()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *external_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Output::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Output)
  GOOGLE_DCHECK_NE(&from, this);
  const Output* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Output>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Output)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Output)
    MergeFrom(*source);
  }
}

void Output::MergeFrom(const Output& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Output)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_robot()->::abb::egm::wrapper::Robot::MergeFrom(from.robot());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_external()->::abb::egm::wrapper::External::MergeFrom(from.external());
    }
  }
}

void Output::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Output)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Output::CopyFrom(const Output& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Output)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Output::IsInitialized() const {
  return true;
}

void Output::Swap(Output* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Output::InternalSwap(Output* other) {
  using std::swap;
  swap(robot_, other->robot_);
  swap(external_, other->external_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata Output::GetMetadata() const {
  protobuf_egm_5fwrapper_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_5fwrapper_2eproto::file_level_metadata[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace wrapper
}  // namespace egm
}  // namespace abb
namespace google {
namespace protobuf {
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::Header* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Header >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Header >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::Status* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Status >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Status >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::Clock* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Clock >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Clock >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::Joints* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Joints >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Joints >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::JointSpace* Arena::CreateMaybeMessage< ::abb::egm::wrapper::JointSpace >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::JointSpace >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::Cartesian* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Cartesian >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Cartesian >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::Euler* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Euler >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Euler >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::Quaternion* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Quaternion >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Quaternion >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::CartesianPose* Arena::CreateMaybeMessage< ::abb::egm::wrapper::CartesianPose >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::CartesianPose >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::CartesianVelocity* Arena::CreateMaybeMessage< ::abb::egm::wrapper::CartesianVelocity >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::CartesianVelocity >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::CartesianSpace* Arena::CreateMaybeMessage< ::abb::egm::wrapper::CartesianSpace >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::CartesianSpace >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::Robot* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Robot >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Robot >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::External* Arena::CreateMaybeMessage< ::abb::egm::wrapper::External >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::External >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::Feedback* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Feedback >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Feedback >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::Planned* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Planned >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Planned >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::Input* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Input >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Input >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::abb::egm::wrapper::Output* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Output >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Output >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
